
type Maybe<x> zero None = Some { content:x } | None;

let .get-or(m: Maybe<x>, default: x): x = (
   match m {
      Some{content=content} => content;
      None{} => default;
   }
);

# Don't add this to lib2, it is just a backwards compatibility feature
let .get-or(m: x, default: x): x = m;
let .get-or-panic(m: x): x = m;

let .get-or-panic(m: Maybe<x>): x = (
   match m {
      Some{content=content} => content;
   }
);

let .is-none(m: Maybe<x>): U64 = (
   match m {
      Some{} => false;
      None{} => true;
   }
);

let .is-some(m: Maybe<x>): U64 = (
   match m {
      Some{} => true;
      None{} => false;
   }
);

let cmp(l: Maybe<x>, r: Maybe<x>): Ord = (
   if l.discriminator-case-tag != r.discriminator-case-tag then cmp(l.discriminator-case-tag, r.discriminator-case-tag)
   else if l.is-some then cmp(l.get-or-panic, r.get-or-panic)
   else Equal()
);

let .into(l: Maybe<x>, tt: Type<String>): String = (
   match l {
      Some{content=content} => "Some{\{content}}";
      _ => "None";
   }
);

let .expect(l: Maybe<x>, msg: CString): x = (
   match l {
      Some{content=content} => content;
      _ => fail(msg);
   }
);

let .expect(l: Maybe<x>, msg: String): x = (
   match l {
      Some{content=content} => content;
      _ => fail(msg);
   }
);
