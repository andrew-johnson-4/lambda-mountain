
type OwnedData<t> = {
   reference-count: USize,
   occupied: USize,
   capacity: USize,
   data: t[]+FlexibleArrayMember
};

let mk-owned-data(tt: Type<t>, capacity: USize, occupied: USize): CompatOwnedData<t>[] = (
   let od = safe-alloc(
      # TODO: make sizeof return USize
      (sizeof(CompatOwnedData<t>) as USize) + (sizeof(t) as USize) * capacity,
      type(CompatOwnedData<t>)
   );
   od.reference-count = 1;
   od.occupied = occupied;
   od.capacity = capacity;
   od
);

let mk-owned-data(tt: Type<t>, capacity: USize): CompatOwnedData<t>[] = (
   mk-owned-data(tt, capacity, 0)
);

let $"[]"(od: CompatOwnedData<t>[], idx: USize): t = (
   if (od as USize)==0
   then fail(c"OwnedData [] Access Null Pointer");
   if idx >= od.occupied then fail("OwnedData [\{idx}] Index Access Out of Bounds");
   od.data[idx]
);

let $"set[]"(od: CompatOwnedData<t>[], idx: USize, val: t): Nil = (
   if (od as USize)==0
   then fail(c"OwnedData set[] Access Null Pointer");
   if idx >= od.occupied then fail("OwnedData set[\{idx}] Index Access Out of Bounds");
   if type(t) <: type(MustRelease) then od.data[idx].release;
   od.data[idx] = val;
);

let .push(od: CompatOwnedData<t>[], d: t): Nil = (
   if (od as USize)==0
   then fail(c"OwnedData .push Into Null Pointer");
   if od.occupied >= od.capacity
   then fail(c"OwnedData .push Exceeds Maximum Length");
   od.data[od.occupied] = d;
   od.occupied = od.occupied + 1;
);

let .pop(od: CompatOwnedData<t>[]): t = (
   if (od as USize)==0
   then fail(c"OwnedData .pop From Null Pointer");
   if od.occupied == 0
   then fail(c"OwnedData .pop From Empty Data");
   od.occupied = od.occupied - 1;
   od.data[od.occupied]
);

let open(od: CompatOwnedData<t>[]): t = (
   od[0];
);

let close-owned(d: t): CompatOwnedData<t>[] = (
   let od = mk-owned-data(type(t), 1);
   od.push(d);
   od
);

let .release(od: CompatOwnedData<t>[]): Nil = (
   if (od as USize)!=0 {
      if od.reference-count==0 then fail(c"OwnedData.release called when reference count is already zero. This object has already been freed!");
      od.reference-count = od.reference-count - 1;
      if od.reference-count == 0 {
         if type(t) <: type(MustRelease) {
            let dlo = 0_sz;
            let dhi = od.occupied;
            while dlo < dhi {
               od.data[dlo].release;
               dlo = dlo + 1;
            };
         };
         safe-free(od);
      };
   };
);

let .retain(od: CompatOwnedData<t>[]): Nil = (
   if (od as USize)!=0 {
      if od.reference-count==0 then fail(c"OwnedData.retain called when reference count is zero. This object has already been freed!");
      od.reference-count = od.reference-count + 1;
   }
);
