
let ta = TAny;

let t0(tag: String): Type = TGround(tag, mk-vector(type(Type)));
let t1(tag: String, p1: Type): Type = TGround(tag, mk-vector(type(Type),1).push(p1));
let t2(tag: String, p1: Type, p2: Type): Type = TGround(tag, mk-vector(type(Type),2).push(p1).push(p2));

let tv(name: String): Type = TVar(name);

let $"&&"(lt: Type, rt: Type): Type = (
   let x = open((lt, rt));
   #match (lt, rt) {
   #   Tuple{first:TAny{}} => rt;
   #   Tuple{second:TAny{}} => lt;
   #   Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
   #      let result = mk-vector(type(Type), lconjugate.length+rconjugate.length);
   #      for c in lconjugate { result = result.push(c) };
   #      for c in rconjugate { result = result.push(c) };
   #      TAnd(result)#.sort
   #   );
   #   Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
   #      let result = mk-vector(type(Type), 1+rconjugate.length);
   #      result = result.push(first);
   #      for c in rconjugate { result = result.push(c) };
   #      TAnd(result)#.sort
   #   );
   #   Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
   #      let result = mk-vector(type(Type), lconjugate.length+1);
   #      for c in lconjugate { result = result.push(c) };
   #      result = result.push(second);
   #      TAnd(result)#.sort
   #   );
   #   Tuple{first=first,second=second} => (
   #      let result = mk-vector(type(Type), 2);
   #      result = result.push(first);
   #      result = result.push(second);
   #      TAnd(result)#.sort
   #   );
   #}
   TAny
);
