
type OwnedData<t> = {
   reference-count: USize,
   current-length: USize,
   capacity: USize,
   data: t[]+FlexibleArrayMember
};

let mk-owned-data(tt: Type<t>, capacity: USize): OwnedData<t>[] = (
   let od = safe-alloc(
      # TODO: make sizeof return USize
      (sizeof(OwnedData<t>) as USize) + (sizeof(t) as USize) * capacity,
      type(OwnedData<t>)
   );
   od.reference-count = 0;
   od.current-length = 0;
   od.capacity = capacity;
   od
);

let $"[]"(od: OwnedData<t>[], idx: USize): t = (
   if idx >= od.current-length then fail(c"OwnedData [] Index Access Out of Bounds");
   od.data[idx]
);

let .push(od: OwnedData<t>[], d: s): Nil = (
   if od.current-length == od.capacity
   then fail(c"OwnedData .push Exceeds Maximum Length");
   od.data[od.current-length] = d;
   od.current-length = od.current-length + 1;
);

let .pop(od: OwnedData<t>[]): t = (
   if od.current-length == 0
   then fail(c"OwnedData .pop From Empty Data");
   od.current-length = od.current-length - 1;
   od.data[od.current-length]
);

let :Blob .release(_: Any): Nil = ();
let .release(od: OwnedData<t>[]): Nil = (
   # TODO: make the default release implementation unnecessary here
   # TODO: the insides of this if statement should not be typechecked if the condition is false
   if type(t) <: type(MustRelease) {
      let dlo = 0_sz;
      let dhi = od.current-length;
      while dlo < dhi {
         od.data[dlo].release;
         dlo = dlo + 1;
      };
   };
   od.reference-count = od.reference-count - 1;
   if od.reference-count == 0
   then safe-free(od);
);

let .retain(od: OwnedData<t>[]): Nil = (
   od.reference-count = od.reference-count + 1;
);
