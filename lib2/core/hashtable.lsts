
type HashtableRowExists = HashtableRowEmpty | HashtableRowFilled | HashtableRowMoved;

type Hashtable<k,v> implies MustRetain, MustRelease
   = { data: SparseOwnedData<(HashtableRowExists,k,v)>[] };


let .release(x: Hashtable<k,v>): Nil = (
   if (x.data as USize) != 0 {
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Hashtable<k,v>): Hashtable<k,v> = (
   if (x.data as USize) != 0 {
      x.data.retain;
   };
   x
);

# new allocations = 0 if capacity==0
#                 | 1
let mk-hashtable(tyk: Type<k>, tyv: Type<v>, capacity: USize): Hashtable<k,v> = (
   if capacity==0
   then Hashtable( 0 as SparseOwnedData<(HashtableRowExists,k,v)>[] )
   else Hashtable( mk-sparse-owned-data(type((HashtableRowExists,k,v)), capacity) )
);

# new allocations = 0
let mk-hashtable(tyk: Type<k>, tyv: Type<v>): Hashtable<k,v> = (
   mk-hashtable(tyk, tyv, 0)
);

# new allocations = 0 if capacity==0
#                 | 1
let mk-hashtable(capacity: USize): Hashtable<k,v> = (
   mk-hashtable(type(k), type(v), capacity)
);

# new allocations = 0
let mk-hashtable(): Hashtable<k,v> = (
   mk-hashtable(type(k), type(v), 0)
);

# new allocations = 0 if capacity==0
#                 | 1
let mk-hashtable-is(tyk: Type<k>, tyv: Type<v>, capacity: USize): Hashtable<Sized<k>,v> = (
   mk-hashtable(type(Sized<k>), type(v), capacity)
);

# new allocations = 0
let mk-hashtable-is(tyk: Type<k>, tyv: Type<v>): Hashtable<Sized<k>,v> = (
   mk-hashtable-is(tyk, tyv, 0)
);

# new allocations = 0 if capacity==0
#                 | 1
let mk-hashtable-is(capacity: USize): Hashtable<Sized<k>,v> = (
   mk-hashtable-is(type(k), type(v), capacity)
);

# new allocations = 0
let mk-hashtable-is(): Hashtable<Sized<k>,v> = (
   mk-hashtable-is(type(k), type(v), 0)
);

# new allocations = 0
let .length(h: Hashtable<k,v>): USize = (
   if (h.data as USize) == 0 then 0 else {
      let count = 0_sz;
      let old-i = 0_sz;
      while old-i < h.data.capacity {
         if is(h.data[old-i].first,HashtableRowFilled)
         then count = count + 1;
         old-i = old-i + 1;
      };
      count;
   }
);

# new allocations = 1
# Reallocates the hashtable with a new capacity, rehashing all existing entries.
# Used internally when the hashtable needs to grow.
let .realloc(h: Hashtable<k,v>, target-capacity: USize): Hashtable<k,v> = (
   print("Realloc \{target-capacity}\n");
   let new-data = mk-sparse-owned-data(type((HashtableRowExists,k,v)), target-capacity);
   let old-i = 0_sz;
   while old-i < h.data.capacity {
      let old-kv = h.data[old-i];
      if is(old-kv.first,HashtableRowFilled)
      then new-data[old-i] = h.data[old-i];
      new-data.occupied = new-data.occupied + 1;
      old-i = old-i + 1;
   };
   print("Reallocated \{target-capacity}\n");
   Hashtable(new-data)
);

# new allocations = 1 if realloc is necessary
#                 | 0
let .bind(h: Hashtable<k,v>, key: k, val: v): Hashtable<k,v> = (
   if (h.data as USize) == 0 or h.data.capacity == 0 {
      # Hashtables can be allocated on the stack as empty values
      # Resize these to size 32 next
      h = mk-hashtable(32) : Hashtable<k,v>;
   };
   let occupied = h.data.occupied;
   let capacity = h.data.capacity;
   let contents = h.data;
   # Resize if >= 2/3 full
   if occupied >= capacity * 2 / 3 {
      h = h.realloc(capacity * 2);
   };
   h.bind-direct(key, val);
   h
);

# new allocations = 0
let .bind-direct(h: Hashtable<k,v>, key: k, val: v): Nil = (
   if (h.data as USize) != 0 and h.data.capacity > 0 {
      let key-hash = hash(key);
      let found = false;
      let contents = h.data;
      let ki = (key-hash as USize) % contents.capacity;
      let kv = contents[ki];
      if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      while not(found) and is(kv.first,HashtableRowFilled) {
         ki = (ki + 1) % contents.capacity;
         kv = contents[ki];
         if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      };
      if not(is(kv.first,HashtableRowFilled)) then contents.occupied = contents.occupied + 1;
      contents[ki] = (HashtableRowFilled,key,val);
   };
);

# new allocations = 1 if realloc is necessary
#                 | 0
let $"map::cons"(key: k, val: v, h: Hashtable<k,v>): Hashtable<k,v> = (
   h.bind(key,val);
);


# new allocations = 0
let $"[]"(h: Hashtable<k,v>, key: k): Maybe<v> = (
   let row-index = h.find-row-index-by-key(key);
   if row-index == (-1 as USize)
   then (None : Maybe<v>)
   else Some(h.data[row-index].third)
);

# new allocations = 0
let .find-row-index-by-key(h: Hashtable<k,v>, key: k): USize = (
   let row-index = -1 as USize;
   if (h.data as USize) != 0 and h.data.capacity > 0 {
      let key-hash = hash(key);
      let found = false;
      let contents = h.data;
      let ki = (key-hash as USize) % contents.capacity;
      let kv = contents[ki];
      if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      while not(is(kv.first,HashtableRowEmpty)) and not(found) {
         ki = (ki + 1) % contents.capacity;
         kv = contents[ki];
         if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      };
      if found then row-index = ki;
   };
   row-index
);

# new allocations = 0
let .lookup(h: Hashtable<k,v>, key: k, default: v): v = h[key].get-or(default);

# new allocations = 0
let .has(h: Hashtable<k,v>, key: k): Bool = h[key].is-some;

let .as-vector(table: Hashtable<Sized<k>,v>): Vector<(k,v)> = (
   let v = mk-vector(type((k,v)));
   v
);

let .as-vector(table: Hashtable<k,v>): Vector<(k,v)> = (
   let v = mk-vector(type((k,v)));
   v
);
