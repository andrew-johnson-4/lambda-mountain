
type HashtableRowExists = HashtableRowEmpty | HashtableRowFilled | HashtableRowMoved;

type Hashtable<k,v> implies MustRetain, MustRelease
   = { data: OwnedData<(HashtableRowExists,k,v)>[] };


let .release(x: Hashtable<k,v>): Nil = (
   if (x.data as USize) != 0 {
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Hashtable<k,v>): Hashtable<k,v> = (
   if (x.data as USize) != 0 {
      x.data.retain;
   };
   x
);

let mk-hashtable(tyk: Type<k>, tyv: Type<v>, capacity: USize): Hashtable<k,v> = (
   Hashtable( mk-owned-data(type((Bool,k,v)), capacity) )
);

let mk-hashtable(tyk: Type<k>, tyv: Type<v>): Hashtable<k,v> = (
   Hashtable( mk-owned-data(type((Bool,k,v)), 0) )
);

let mk-hashtable(capacity: USize): Hashtable<k,v> = (
   Hashtable( mk-owned-data(type((Bool,k,v)), capacity) )
);

let mk-hashtable(): Hashtable<k,v> = (
   Hashtable( mk-owned-data(type((Bool,k,v)), 0) )
);

let .bind(h: Hashtable<k,v>, key: k): Hashtable<k,v> = (
   h
);

let $"map::cons"(key: k, val: v, h: Hashtable<k,v>): Hashtable<k,v> = (
   h
);


let $"[]"(h: Hashtable<k,v>, key: k): Maybe<k> = (
   let row-index = h.find-row-index-by-key(key);
   print("Row Index \{row-index}\n");
   None : Maybe<k>
   #if row-index == (-1 as USize)
   #then (None : Maybe<k>)
   #else Some(h.data[row-index])
);

let .find-row-index-by-key(h: Hashtable<k,v>, key: k): USize = (
   let row-index = -1 as USize;
   if (h.data as USize) != 0 {
      let key-hash = hash(key);
      let found = false;
      let contents = h.data;
      let ki = (key-hash as USize) % contents.capacity;
      let kv = contents[ki];
      if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      while not(is(kv.first,HashtableRowEmpty)) and not(found) {
         ki = (ki + 1) % contents.capacity;
         kv = contents[ki];
         if is(kv.first,HashtableRowFilled) and kv.second==key { found = true; };
      };
      if found then row-index = ki as Usize;
   };
   row-index
);
