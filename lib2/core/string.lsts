
type String suffix _ss implies MustRetain, MustRelease
          = { start-offset:USize, end-offset:USize, data:OwnedData<U8>[] };

# String is NOT null terminated like a C String, it is more like a PASCAL style string

let .release(x: String): Nil = (
   if mem-is-non-zero(x) {
      # normally if x is not released by the end of scope, then it will be auto-released
      # however, mark-as-released prevents this case of infinite recursion
      # this is necessary when writing custom .release implementations
      # but normally most users won't need to use "mark-as-released" very often
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: String): String = (
   if mem-is-non-zero(x) {
      # Several inference rules are at play here
      # > normally a reference to a variable will auto-retain
      # > however field access is marked as MustNotRetain, so x.data does not auto-retain
      # > the second case of the return value is also not retained
      # > when a local variable is returned
      #    1) the local variable is referenced (retain)
      #    2) the local variable goes out of scope (release)
      #    3) so they cancel each other out
      x.data.retain;
   };
   x
);

# new allocations = 0
let .length(s: String): USize = s.end-offset - s.start-offset;

# new allocations = 0
let non-zero(s: String): Bool = s.length > 0;

# new allocations = 0
let cmp(l: String, r: String): Ord = (
   let l-size = l.end-offset - l.start-offset;
   let r-size = r.end-offset - r.start-offset;
   let c = memcmp(
      (l.data.data + l.start-offset) as C<"void">[],
      (r.data.data + r.start-offset) as C<"void">[],
      min(l-size, r-size)
   ) as I64;
   if c < 0 then LessThan
   else if c > 0 then GreaterThan
   else if l-size < r-size then LessThan
   else if l-size > r-size then GreaterThan
   else Equal
);

# new allocations = 1
let intern(cs: CString): String = cs.into(type(String));

# new allocations = 0
let intern(s: String): String = s;

# new allocations = 0
let .into(s: String, tt: Type<String>): String = s;

# new allocations = 1
# TODO: fix to use Vector.buffer-into-string
# this would change the allocations used to 0 if string is empty
let .into(cs: CString, tt: Type<String>): String = (
   let cs-length = cs.length;
   let od = mk-owned-data(type(U8), cs-length);
   let csi = 0_sz;
   while csi < cs-length {
      od.push(cs[csi] as U8);
      csi = csi + 1;
   };
   # This constructor will call .retain on itself before exiting
   String(0 as USize, cs-length, od)
);

# new allocations = 0
# leaked allocations = 1
#
# TODO: consider removing this method entirely
# it intentionally leaks memory and could be better framed as a `with` managed resource
#
# Example alternative:
# ```
# with cs = s.into(type(CString)) {
#    it is legal and safe to use this CString here
#    the dangling reference is properly scoped and managed
# }
# ```
let .into(s: String, tt: Type<CString>): CString = (
   let s-length = s.length;
   let od = mk-owned-data(type(U8), s-length+1);
   let si = 0_sz;
   while si < s-length {
      od.push(s[si] as U8);
      si = si + 1;
   };
   od.push(0);
   od.data.data as CString
);

let $"[:]"(x: String, low: U64, hi: U64): String = x[low as I64 : hi as I64];
let $"[:]"(x: String, low: I64, hi: U64): String = x[low : hi as I64];
let $"[:]"(x: String, low: U64, hi: I64): String = x[low as I64 : hi];

# new allocations = 0
let $"[:]"(s: String, begin: I64, end: I64): String = (
   let s-length = s.length as I64;
   if end == minimum-I64 then end = s-length;
   if begin < 0_i64 then begin = s-length + begin;
   if end < 0_i64 then end = s-length + end;
   if begin < 0_i64 or begin > s-length then fail(c"String [:] Slice Start Index Out of Bounds");
   if end < 0_i64 or end > s-length then fail(c"String [:] Slice End Index Out of Bounds");
   let start-offset = ((s.start-offset as I64) + begin) as USize;
   let end-offset = ((s.start-offset as I64) + end) as USize;
   s.data.retain;
   String(start-offset, end-offset, s.data)
);

# new allocations = 0
let $"[]"(s: String, idx: USize): U8 = (
   s.data[s.start-offset + idx]
);

# new allocations = 0
let print(s: String): Nil = (
   fwrite((s.data.data + s.start-offset) as C<"void">[], sizeof(U8) as USize, s.length as USize, stdout);
   ()
);

# new allocations = 0
let eprint(s: String): Nil = (
   fwrite((s.data.data + s.start-offset) as C<"void">[], sizeof(U8) as USize, s.length as USize, stderr);
   ()
);

# new allocations = 1
let $"+"(l: String, r: String): String = (
   let l-length = l.length;
   let r-length = r.length;
   let cs-length = l-length + r-length;
   let od = mk-owned-data(type(U8), cs-length);
   memcpy(od.data as C<"void">[], (l.data.data + l.start-offset) as C<"void">[], l-length as USize);
   memcpy((od.data + l-length) as C<"void">[], (r.data.data + r.start-offset) as C<"void">[], r-length as USize);
   String(0 as USize, cs-length, od) 
);

# new allocations = 0
let fail(msg: String): Never = (
   fwrite((msg.data.data + msg.start-offset) as C<"void">[], sizeof(U8) as USize, msg.length, stderr);
   exit(1) as Never;
);

let fail(msg: String, loc: String): Never = (
   fwrite((msg.data.data + msg.start-offset) as C<"void">[], sizeof(U8) as USize, msg.length, stderr);
   fwrite(c" at " as C<"void">[], sizeof(U8) as USize, c" at ".length, stderr);
   fwrite((loc.data.data + loc.start-offset) as C<"void">[], sizeof(U8) as USize, loc.length, stderr);
   exit(1) as Never;
);

# new allocations = 0
let hash(key: String): U64 = (
   let i = 0_sz;
   let key-length = key.length;
   let result = 0_u64;
   while i < key-length {
      result = result + key[i];
      result = result + (result << 10);
      result = result ^ (result >> 6);
      i = i + 1;
   };
   result = result + (result << 3);
   result = result ^ (result >> 11);
   result = result + (result << 15);
   result
);

# new allocations = 1
let .into(tt: Type<t>, dst: Type<String>): String = type(t).into(type(CString)).into(type(String));

let .has-suffix(base: String, sfx: String): Bool = (
   base.length >= sfx.length and
   base[ (base.length - sfx.length) as I64 : base.length as I64 ] == sfx
);

let .remove-suffix(base: String, sfx: String): String? = (
   if base.has-suffix(sfx)
   then Some(base[ 0_i64 : (base.length - sfx.length) as I64 ])
   else (None : String?)
);

let .has-prefix(base: String, pfx: String): Bool = (
   base.length >= pfx.length and
   base[ 0_i64 : pfx.length as I64 ] == pfx
);

let .remove-prefix(base: String, pfx: String): String? = (
   if base.has-prefix(pfx)
   then Some(base[ pfx.length as I64 : minimum-I64 ])
   else (None : String?)
);

let tail(x: String): String = x[ 1_i64 : x.length as I64 ];
let head(x: String): U8 = x[0];
