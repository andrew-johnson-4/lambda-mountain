
# The "LMCString" makes the CString a subtype of C<"char">[] instead of a direct alias
type opaque alias CString suffix _s = C<"char">[];

declare-unop( $".c-pointer", raw-type(CString), raw-type(C<"char">[]), x );

let .length(l: CString): USize = strlen(l.c-pointer) as USize;

let cmp(l: CString, r: CString): Ord = (
   let c = strcmp( l.c-pointer, r.c-pointer ) as I64;
   if c < 0 then LessThan
   else if c > 0 then GreaterThan
   else Equal
);

let fail(msg: CString): Never = (
   fputs(msg.c-pointer, stderr);
   exit(1);
   () as Never
);

let fail(msg1: CString, msg2: CString): Never = (
   fputs(msg1.c-pointer, stderr);
   fputs(msg2.c-pointer, stderr);
   exit(1);
   () as Never
);

let print(msg: CString): Nil = (
   fputs(msg.c-pointer, stdout); ()
);

let eprint(msg: CString): Nil = (
   fputs(msg.c-pointer, stderr); ()
);

let $"[]"(l: CString, idx: USize): U8 = (
   (l as U8[])[idx]
);

let hash(key: CString): U64 = (
   let i = 0_sz;
   let key_length = key.length;
   let result = 0_u64;
   while i < key_length {
      result = result + key[i];
      result = result + (result << 10);
      result = result ^ (result >> 6);
      i = i + 1;
   };
   result = result + (result << 3);
   result = result ^ (result >> 11);
   result = result + (result << 15);
   result
);

let $"+"(l: CString, r: CString): CString = (
   let buf = malloc(l.length + r.length + 1) as C<"char">[];
   memset(buf.void-pointer, 0, l.length+r.length+1);
   strcat(buf, l as C<"char">[]);
   strcat(buf, r as C<"char">[]);
   buf as CString
);
