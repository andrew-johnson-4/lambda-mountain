
# The "LMCString" makes the CString a subtype of C<"char">[] instead of a direct alias
type alias CString suffix _s = C<"char">[];

let .length(l: CString): USize = strlen(l) as USize;
let non-zero(l: CString): Bool = l.length > 0;

let cmp(l: CString, r: CString): Ord = (
   let c = strcmp( l, r ) as I64;
   if c < 0 then LessThan
   else if c > 0 then GreaterThan
   else Equal
);

# TODO: replace this with a macro or something
# [specialize(x = CString)]
let $"=="(l: CString, r: CString): Bool = cmp(l, r) == Equal;
let $"!="(l: CString, r: CString): Bool = cmp(l, r) != Equal;
let $"<"(l: CString, r: CString): Bool  = cmp(l, r) <  Equal;
let $"<="(l: CString, r: CString): Bool = cmp(l, r) <= Equal;
let $">"(l: CString, r: CString): Bool  = cmp(l, r) >  Equal;
let $">="(l: CString, r: CString): Bool = cmp(l, r) >= Equal;

let fail(msg: CString): Never = (
   fputs(msg, stderr);
   exit(1);
   () as Never
);

let fail(msg1: CString, msg2: CString): Never = (
   fputs(msg1, stderr);
   fputs(msg2, stderr);
   exit(1);
   () as Never
);

let print(msg: CString): Nil = (
   fputs(msg, stdout); ()
);

let eprint(msg: CString): Nil = (
   fputs(msg, stderr); ()
);

let $"[]"(l: CString, idx: USize): U8 = (
   (l as U8[])[idx]
);

let deep-hash(key: CString): U64 = hash(key);
let hash(key: CString): U64 = (
   let i = 0_sz;
   let key-length = key.length;
   let result = 0_u64;
   while i < key-length {
      result = result + key[i];
      result = result + (result << 10);
      result = result ^ (result >> 6);
      i = i + 1;
   };
   result = result + (result << 3);
   result = result ^ (result >> 11);
   result = result + (result << 15);
   result
);

let $"+"(l: CString, r: CString): CString = (
   let buf = malloc(l.length + r.length + 1) as C<"char">[];

   memset(buf.void-pointer, 0, l.length+r.length+1);
   strcat(buf, l as C<"char">[]);
   strcat(buf, r as C<"char">[]);
   buf as CString
);

let .has-suffix(s2: CString, s1: CString): Bool = (
   let s1-length = s1.length;
   let s2-length = s2.length;
   if s1-length > s2-length then false else {
      let i = 0_sz;
      let return = true;
      while i < s1-length {
         if s1[s1-length - i - 1] != s2[s2-length - i - 1]
         then return = false;
         i = i + 1;
      };
      return
   }
);

let .has-prefix(s2: CString, s1: CString): Bool = (
   let s1-length = s1.length;
   let s2-length = s2.length;
   if s1-length > s2-length then false else {
      let i = 0_sz;
      let return = true;
      while i < s1-length {
         if s1[i] != s2[i]
         then return = false;
         i = i + 1;
      };
      return
   }
);

let head(x: CString): U8 = if non-zero(x) then (x as U8[])[0] else 0;
let tail(x: CString): CString = if non-zero(x) then ((x as U8[]) + 1) as CString else c"";

let .contains(base: CString, pat: CString): Bool = (
   let r = false;
   while not(r) and non-zero(base) {
      r = base.has-prefix(pat);
      base = tail(base);
   };
   r
);

let .remove-prefix(base: CString, prefix: CString): CString? = (
   if not(base.has-prefix(prefix)) then None : CString?
   else {
      let base_length = base.length;
      let prefix_length = prefix.length;
      let buf = malloc(base_length - prefix_length + 1) as C<"char">[];
      strcat(buf, (base as C<"char">[])+prefix_length);
      buf[base_length - prefix_length] = 0 as C<"char">;
      Some(buf as CString)
   }
);

let .remove-suffix(base: CString, suffix: CString): CString? = (
   if not(base.has-suffix(suffix)) then None : CString?
   else {
      let new_length = base.length - suffix.length;
      let buf = malloc(new_length + 1) as C<"char">[];
      let si = 0_sz;
      while si < new_length {
         buf[si] = base[si] as C<"char">;
         si = si + 1;
      };
      buf[si] = 0 as C<"char">;
      Some(buf as CString)
   }
);

let .split(s: CString, sep: CString): Vector<CString> = (
   let r = mk-vector(type(CString));
   let remainder = s;
   while non-zero(remainder) {
      if remainder.has-prefix(sep) {
         if non-zero(s) then r = r.push(s.remove-suffix(remainder).get-or-panic);
         remainder = remainder.remove-prefix(sep).get-or-panic;
         s = remainder;
      } else remainder = tail(remainder);
   };
   if non-zero(s) then r = r.push(s);
   r;
);
