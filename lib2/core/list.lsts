
type List<x> implies MustRetain, MustRelease zero LEOF = LEOF | LCons { head: x, tail: OwnedData<List<x>>[] };

let .release(t: List<x>): Nil = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag {
      if type(x) <: type(MustRelease) then (t as Tag::LCons).head.release;
      (t as Tag::LCons).tail.release;
   };
   mark-as-released(t);
);

let .retain(t: List<x>): List<x> = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag {
      if type(x) <: type(MustRetain) then mark-as-released((t as Tag::LCons).head.retain);
      (t as Tag::LCons).tail.retain
   };
   t
);

# new allocations = 1
let $"list::cons"(hd: x, tl: List<x>): List<x> = LCons(hd, close(tl));

# new allocations = 1
let cons(hd: x, tl: List<x>): List<x> = LCons(hd, close(tl));

# new allocations = 0
let cmp(l: List<x>, r: List<x>): Ord = (
   if  l.discriminator-case-tag==(l as Tag::LCons).discriminator-case-tag
   and r.discriminator-case-tag==(r as Tag::LCons).discriminator-case-tag {
      cmp( (l as Tag::LCons).head, (r as Tag::LCons).head ) &&
      cmp( open((l as Tag::LCons).tail), open((r as Tag::LCons).tail) )
   } else cmp(l.discriminator-case-tag, r.discriminator-case-tag)
);

# new allocations = 0
let hash(t: List<x>): U64 = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag
   then hash((t as Tag::LCons).head) + hash(open((t as Tag::LCons).tail))
   else 0
);

let .into(l: List<x>, tt: Type<String>): String = (
   let s = "[";
   for vector li in l {
      if s.length > 1 then s = s + ",";
      s = s + li.into(type(String));
   };
   s + "]";
);

# new allocations = 0
let .has-head(tt: List<x>): Bool = non-zero(tt);

# new allocations = 0
let .nth(tt: List<x>, idx: USize): Maybe<x> = (
   let err = false;
   while idx > 0 and not(err) {
      if tt.has-head() {
         tt = tail(tt);
         idx = idx - 1;
      } else {
         err = true;
      }
   };

   if err or not(tt.has-head()) {
      None : Maybe<x>
   } else {
      Some(head(tt))
   }
);

# new allocations = 0
let $"[]"(tt: List<x>, idx: USize): x = (
   while idx > 0 {
      if not(tt.has-head()) {
         fail(c"list index out of bounds");
      };
      tt = tail(tt);
   };
   head(tt)
);

# new allocations = l.length
let .reverse(l: List<x>): List<x> = (
   let r = [] : List<x>;
   for list v in l { r = cons(v,r); };
   r
);

# new allocations = 0
let head(l: List<x>): x = if l.has-head then (l as Tag::LCons).head else fail(c"list::head is fallible");

# new allocations = 0
let tail(l: List<x>): List<x> = if l.has-head then open((l as Tag::LCons).tail) else fail(c"list::tail is fallible");

# new allocations = 0
let .length(l: List<x>): USize = (
   let li = 0_sz;
   for list _ in l { li = li + 1 };
   li
);

# new allocations = 0         if tl.length == 0
#                 | hd.length if hd.length <= 1
#                 | hd.length + 1
let $"+"(hd: List<x>, tl: List<x>): List<x> = (
   let hd_length = hd.length;
   if hd_length==0 then tl
   else if not(non-zero(tl)) then hd
   else if hd_length==1 then cons(head(hd),tl)
   else {
      # Here we use a temporary vector as a reverse iterator
      # the .reverse list operator would be relatively expensive compared to a contiguous vector
      let hdv = hd.into(type(Vector<x>));
      let reverse-iterator-index = hd_length;
      while reverse-iterator-index > 0 {
         reverse-iterator-index = reverse-iterator-index - 1;
         tl = cons(hdv[reverse-iterator-index], tl);
      };
      tl
   }
);

# new allocations = 1
let .into(ls: List<x>, tt: Type<Vector<x>>): Vector<x> = (
   let dst = mk-vector(type(x), ls.length);
   for list l in ls { dst = dst.push(l); };
   dst
);

let .lookup(ls: List<Tuple<k,v>>, key: k, default: v): v = (
   let found = false;
   for list Tuple{lkey=first, rval=second} in ls {
      if not(found) and key==lkey { default=rval; found=true; }
   };
   default;
);

let .lookup(ls: List<Tuple<k,v1,v2>>, key: k, default: Tuple<v1,v2>): Tuple<v1,v2> = (
   let found = false;
   for list Tuple{lkey=first, val1=second, val2=third} in ls {
      if not(found) and key==lkey { default=Tuple(val1,val2); found=true; }
   };
   default;
);

let .lookup(ls: List<Tuple<k,v1,v2,v3>>, key: k, default: Tuple<v1,v2,v3>): Tuple<v1,v2,v3> = (
   let found = false;
   for list Tuple{lkey=first, val1=second, val2=third, val3=fourth} in ls {
      if not(found) and key==lkey { default=Tuple(val1,val2,val3); found=true; }
   };
   default;
);

let deep-hash(ts: List<t>): U64 = (
   let return = 0_u64;
   for list t0 in ts { return = return + deep-hash(t0); };
   return;
);

let .contains(v: List<t>, i: t): Bool = (
   let result = false;
   for list vi in v {
      if vi==i then result = true;
   };
   result
);
