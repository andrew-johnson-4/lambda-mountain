
type List<x> implies MustRetain, MustRelease zero LEOF = LEOF | LCons { head: x, tail: OwnedData<List<x>>[] };

let $"list::cons"(hd: x, tl: List<x>): List<x> = LCons(hd, close(tl));
let cons(hd: x, tl: List<x>): List<x> = LCons(hd, close(tl));

let .release(t: List<x>): Nil = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag {
      if type(x) <: type(MustRelease) then (t as Tag::LCons).head.release;
      (t as Tag::LCons).tail.release;
   };
   mark-as-released(t);
);

let .retain(t: List<x>): List<x> = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag {
      if type(x) <: type(MustRetain) then mark-as-released((t as Tag::LCons).head.retain);
      (t as Tag::LCons).tail.retain
   };
   t
);

let cmp(l: List<x>, r: List<x>): Ord = (
   if  l.discriminator-case-tag==(l as Tag::LCons).discriminator-case-tag
   and r.discriminator-case-tag==(r as Tag::LCons).discriminator-case-tag {
      cmp( (l as Tag::LCons).head, (r as Tag::LCons).head ) &&
      cmp( open((l as Tag::LCons).tail), open((r as Tag::LCons).tail) )
   } else cmp(l.discriminator-case-tag, r.discriminator-case-tag)
);

let deep-hash(t: List<x>): U64 = (
   if t.discriminator-case-tag==(t as Tag::LCons).discriminator-case-tag
   then deep-hash((t as Tag::LCons).head) + deep-hash(open((t as Tag::LCons).tail))
   else 0
);

let .into(l: List<x>, tt: Type<String>): String = (
   "[..TODO..List.into(String)..]"
);

let .has-head(tt: List<x>): Bool = non-zero(tt);

let .nth(tt: List<x>, idx: USize): Maybe<x> = (
   let err = false;
   while idx > 0 and not(err) {
      if tt.has-head() {
         tt = tail(tt);
         idx = idx - 1;
      } else {
         err = true;
      }
   };

   if err or not(tt.has-head()) {
      None : Maybe<x>
   } else {
      Some(head(tt))
   }
);

let $"[]"(tt: List<x>, idx: USize): x = (
   while idx > 0 {
      if not(tt.has-head()) {
         fail(c"list index out of bounds");
      };
      tt = tail(tt);
   };
   head(tt)
);

let .reverse(l: List<x>): List<x> = (
   let r = [] : List<x>;
   for list v in l { r = cons(v,r); };
   r
);

let head(l: List<x>): x = if l.has-head then (l as Tag::LCons).head else fail(c"list::head is fallible");
let tail(l: List<x>): List<x> = if l.has-head then open((l as Tag::LCons).tail) else fail(c"list::tail is fallible");

let .length(l: List<x>): U64 = (
   let li = 0_u64;
   for list _ in l { li = li + 1 };
   li
);

let $"+"(hd: List<x>, tl: List<x>): List<x> = (
   for list hdhd in hd.reverse { tl = cons(hdhd,tl); };
   tl
);
