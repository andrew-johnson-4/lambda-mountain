
let .into(b: Bool, tt: Type<String>): String = if b then "true" else "false";
let .into(i: U8, tt: Type<String>): String = (i as U64).into(type(String));
let .into(i: USize, tt: Type<String>): String = (i as U64).into(type(String));

let .into(i: I64, tt: Type<String>): String = (
   let od = mk-owned-data(type(U8), 20_sz);
   let cs-length = 0_sz;
   let is-negative = false;
   if i < 0_i64 {
      is-negative = true;
      od.push(45);
      cs-length = cs-length + 1;
   } else if i == 0_i64 {
      od.push(48);
      cs-length = cs-length + 1;
   };
   while i != 0_i64 {
      od.push(48 + (abs(i % 10) as U8));
      cs-length = cs-length + 1;
      i = i / 10;
   };
   let start-i = if is-negative then 1_sz else 0_sz;
   let end-i = cs-length - 1_sz;
   while start-i < end-i {
      let tmpc = od.data[start-i];
      od.data[start-i] = od.data[end-i];
      od.data[end-i] = tmpc;
      start-i = start-i + 1_sz;
      end-i = end-i - 1_sz;
   };
   String(0 as USize, cs-length, od)
);

let .into(i: U64, tt: Type<String>): String = (
   let od = mk-owned-data(type(U8), 20_sz);
   let cs-length = 0_sz;
   if i == 0_u64 {
      od.push(48);
      cs-length = cs-length + 1;
   };
   while i != 0_u64 {
      od.push(48 + ((i % 10) as U8));
      cs-length = cs-length + 1;
      i = i / 10;
   };
   let start-i = 0_sz;
   let end-i = cs-length - 1_sz;
   while start-i < end-i {
      let tmpc = od.data[start-i];
      od.data[start-i] = od.data[end-i];
      od.data[end-i] = tmpc;
      start-i = start-i + 1_sz;
      end-i = end-i - 1_sz;
   };
   String(0 as USize, cs-length, od)
);

let .to-hex(i: U64): String = (
   let buff = mk-vector(type(U8), 17);
   let rpt = 16_u64;
   while rpt > 0_u64 {
      match i % 16 {
         0 => buff = buff.push(48);
         1 => buff = buff.push(49);
         2 => buff = buff.push(50);
         3 => buff = buff.push(51);
         4 => buff = buff.push(52);
         5 => buff = buff.push(53);
         6 => buff = buff.push(54);
         7 => buff = buff.push(55);
         8 => buff = buff.push(56);
         9 => buff = buff.push(57);
         10 => buff = buff.push(97);
         11 => buff = buff.push(98);
         12 => buff = buff.push(99);
         13 => buff = buff.push(100);
         14 => buff = buff.push(101);
         15 => buff = buff.push(102);
      };
      i = i / 16;
      rpt = rpt - 1;
   };
   buff.buffer-into-string
);

let clone-rope(s: U8): CString = (
   let x = safe-alloc(2, type(U8));
   x[0] = s;
   x[1] = 0_u8;
   x as CString;
);

# TODO: optimize, this is really inefficient
let .replace(base: CString, pat: CString, n: CString): CString = (
   let r = SNil;
   while head(base)!=0 {
      if base.has-prefix(pat) {
         base = base.remove-prefix(pat).get-or(c"");
         r = r + SAtom(n);
      } else {
         r = r + SAtom(clone-rope(head(base)));
         base = tail(base);
      }
   };
   clone-rope(r);
);

let read-binary-file-to(out: Vector<U8>, path: CString): Vector<U8> = (
   let fp = fopen(path as C<"char">[], c"rb");
   if (fp as U64) == 0_u64 {
      # Cannot use format strings here because this file is used in "baremetal" package that doesn't use GC
      # TODO: add support for format strings inside of CStrings
      fail(c"Unable to read from file: " + path);
   };
   let buffer = mk-vector(type(U8), 1024 as USize);
   let bytes-read = 1_sz;
   while bytes-read > 0 {
      bytes-read = fread(buffer.data.data as C<"void">[], 1 as USize, 1024 as USize, fp);
      let bi = 0_sz;
      while bi < (bytes-read as USize) {
         out = out.push(buffer.data.data[bi]);
         bi = bi + 1;
      };
   };
   fclose(fp);
   out
);

let read-file(fp: CString): CString = (
   let v = read-binary-file-to(mk-vector(type(U8)), fp);
   v.buffer-into-string.into(type(CString))
);

let .into(i: x, tt: Type<CString>): CString = (
   i.into(type(String)).into(type(CString))
);

