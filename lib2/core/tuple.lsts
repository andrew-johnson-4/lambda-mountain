

type Tuple<x,y> implies MustRetain, MustRelease = { first: x, second: y };
type Tuple<x,y,z> implies MustRetain, MustRelease = { first: x, second: y, third: z };
type Tuple<w,x,y,z> implies MustRetain, MustRelease = { first: w, second: x, third: y, fourth: z };

let .release(t: Tuple<x,y>): Nil = (
   if type(x) <: type(MustRelease) { t.first.release; };
   if type(y) <: type(MustRelease) { t.second.release; };
   mark-as-released(t);
);

let .retain(t: Tuple<x,y>): Tuple<x,y> = (
   if type(x) <: type(MustRetain) { let r = t.first.retain; mark-as-released(r); };
   if type(y) <: type(MustRetain) { let r = t.second.retain; mark-as-released(r); };
   t
);

let cmp(l: Tuple<x,y>, r: Tuple<x,y>): Ord = (
   cmp(l.first, r.first) && cmp(l.second, r.second)
);

let deep-hash(l: Tuple<x,y>): U64 = (
   deep-hash(l.first) + deep-hash(l.second)
);

#let .into(l: Tuple<x,y>, tt: Type<String>): String = (
#   "(" + l.first.into(type(String)) + ","
#       + l.second.into(type(String)) + ")"
#);

#let cmp(l: Tuple<x,y,z>, r: Tuple<x,y,z>): Ord = (
#   cmp(l.first, r.first) && cmp(l.second, r.second) && cmp(l.third, r.third)
#);

#let deep-hash(l: Tuple<x,y,z>): U64 = (
#   deep-hash(l.first) + deep-hash(l.second) + deep-hash(l.third)
#);

#let .into(l: Tuple<x,y,z>, tt: Type<String>): String = (
#   "(" + l.first.into(type(String)) + ","
#       + l.second.into(type(String)) + ","
#       + l.third.into(type(String)) + ")"
#);

#let cmp(l: Tuple<w,x,y,z>, r: Tuple<w,x,y,z>): Ord = (
#   cmp(l.first, r.first) && cmp(l.second, r.second) && cmp(l.third, r.third) && cmp(l.fourth, r.fourth)
#);

#let deep-hash(l: Tuple<x,y,z>): U64 = (
#   deep-hash(l.first) + deep-hash(l.second) + deep-hash(l.third) + deep-hash(l.fourth)
#);

#let .into(l: Tuple<w,x,y,z>, tt: Type<String>): String = (
#   "(" + l.first.into(type(String)) + ","
#       + l.second.into(type(String)) + ","
#       + l.third.into(type(String)) + ","
#       + l.fourth.into(type(String)) + ")"
#);
