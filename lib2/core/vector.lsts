
## faster than [type(List<t>)]. should be used when you append or remove data a lot
type Vector<t> implies MustRetain, MustRelease
   = { data: OwnedData<t>[], start-offset: USize, end-offset: USize };

let .release(x: Vector<t>): Nil = (
   if (x.data as USize) != 0 {
      print(c"Release Vector\n");
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Vector<t>): Vector<t> = (
   if (x.data as USize) != 0 {
      print(c"Retain Vector\n");
      x.data.retain;
   };
   x
);

let mk-vector(ty: Type<t>, capacity: USize): Vector<t> = (
   print(c"mk-vector\n");
   let ptr = mk-owned-data(type(t), capacity);
   Vector( ptr, 0_sz, 0_sz )
);

let mk-vector(ty: Type<t>): Vector<t> = (
   mk-vector(type(t), 0)
);

let .length(v: Vector<t>): USize = (
   v.end-offset - v.start-offset
);

let $"[]"(v: Vector<t>, idx: USize): t = (
   v.data[v.start-offset + idx]
);

let .realloc(v: Vector<t>, target-capacity: USize): Vector<t> = (
   print(c"Realloc\n");
   let new-data = mk-owned-data(type(t), target-capacity);
   let dlo = 0_sz;
   let dhi = v.length;
   while dlo < dhi {
      new-data.push(v[dlo]);
      dlo = dlo + 1;
   };
   Vector( new-data, 0, new-data.current-length )
);

# TODO: Vector<t> and i: t should have the same type variable and it should unify
let .push(v: Vector<t>, i: x): Vector<t> = (
   print(c"push Vector Start\n");
   # if this vector is a view, or if it is full, then we need to reallocate
   if (v.data as USize)==0 or v.end-offset < v.data.current-length or v.end-offset >= v.data.capacity {
      let new_capacity = if v.start-offset==v.end-offset then 4_sz
      else (v.length >> 1_sz) + v.length; # this is mul 1.5, not 3
      let old-data = v; # TODO automatically call .release on mov destination
      v = v.realloc(new_capacity);
      old-data.release;
   };
   v.data.push(i);
   v.end-offset = v.end-offset + 1_sz;
   print(c"push Vector End\n");
   v
);

let cmp(x: Vector<x>, y: Vector<x>): Ord = (
   let r = Equal;
   if not(is(x, y)) {
      let xi = 0_sz;
      let yi = 0_sz;
      while xi < x.length and yi < y.length {
         let xycmp = cmp(x[xi], y[yi]);
         if is(xycmp,LessThan) {
            r = LessThan;
            xi = x.length;
            yi = y.length;
         } else if is(xycmp,GreaterThan) {
            r = GreaterThan;
            xi = x.length;
            yi = y.length;
         } else {
            xi = xi + 1;
            yi = yi + 1;
         }
      };
      if xi < x.length { r = GreaterThan };
      if yi < y.length { r = LessThan };
   };
   r
);
