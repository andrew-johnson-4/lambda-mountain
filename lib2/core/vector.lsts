
## faster than [type(List<t>)]. should be used when you append or remove data a lot
type Vector<t> implies MustRetain, MustRelease
   = { data: OwnedData<t>[] };

let .release(x: Vector<t>): Nil = (
   if (x.data as USize) != 0 {
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Vector<t>): Vector<t> = (
   if (x.data as USize) != 0 {
      x.data.retain;
   };
   x
);

let mk-vector(ty: Type<t>, capacity: USize): Vector<t> = (
   Vector( mk-owned-data(type(t), capacity) )
);

let mk-vector(ty: Type<t>): Vector<t> = (
   mk-vector(type(t), 0)
);

let mk-vector(capacity: USize): Vector<t> = (
   Vector( mk-owned-data(type(t), capacity) )
);

let mk-vector(): Vector<t> = (
   mk-vector(type(t), 0)
);

let .length(v: Vector<t>): USize = (
   if (v.data as USize) != 0 then 0 else v.data.occupied
);

let $"[]"(v: Vector<t>, idx: USize): t = (
   v.data[idx]
);

let .realloc(v: Vector<t>, target-capacity: USize): Vector<t> = (
   let new-data = mk-owned-data(type(t), target-capacity);
   let dlo = 0_sz;
   let dhi = v.length;
   while dlo < dhi {
      new-data.push(v[dlo]);
      dlo = dlo + 1;
   };
   Vector( new-data )
);

# TODO: Vector<t> and i: t should have the same type variable and it should unify
let .push(v: Vector<t>, i: x): Vector<t> = (
   # if this vector is a view, or if it is full, then we need to reallocate
   if (v.data as USize)==0 or v.data.occupied==v.data.capacity {
      let new_capacity = if v.length==0 then 4_sz
      else (v.length >> 1_sz) + v.length; # this is mul 1.5, not 3
      let old-data = v.data; # TODO automatically call .release on mov destination
      v = v.realloc(new_capacity);
      old-data.release;
   };
   v.data.push(i);
   v
);

let cmp(x: Vector<x>, y: Vector<x>): Ord = (
   let r = Equal;
   if not(is(x, y)) {
      let xi = 0_sz;
      let yi = 0_sz;
      while xi < x.length and yi < y.length {
         let xycmp = cmp(x[xi], y[yi]);
         if is(xycmp,LessThan) {
            r = LessThan;
            xi = x.length;
            yi = y.length;
         } else if is(xycmp,GreaterThan) {
            r = GreaterThan;
            xi = x.length;
            yi = y.length;
         } else {
            xi = xi + 1;
            yi = yi + 1;
         }
      };
      if xi < x.length { r = GreaterThan };
      if yi < y.length { r = LessThan };
   };
   r
);

let .sort(v: Vector<t>): Vector<t> = (
   let n = v.length;
   let i = 0_sz;
   while i < n - 1_sz {
      let swapped = false;
      let j = 0_sz;
      while j < n - i - 1_sz {
         if v[j + 1_sz] < v[j] {
            let tmp = v[j];
            v[j] = v[j + 1_sz];
            v[j + 1_sz] = tmp;
            swapped = true;
         };
         j = j + 1_sz;
      };
      i = i + 1_sz;
      if not(swapped) {
         i = n;
      };
   };
   v
);
