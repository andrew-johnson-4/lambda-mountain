
## faster than [type(List<t>)]. should be used when you append or remove data a lot
type Vector<t> implies MustRetain, MustRelease
   = { data: OwnedData<t>[], start-offset: USize, end-offset: USize };

let .release(x: Vector<t>): Nil = (
   if x.data as USize != 0 {
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Vector<t>): Vector<t> = (
   if x.data as USize != 0 {
      x.data.retain;
   };
   x
);

let mk-vector(ty: Type<t>, capacity: USize): Vector<t> = (
   let ptr = if capacity==0 then (0 as OwnedData<t>[]) else mk-owned-data(type(t), capacity);
   Vector( ptr, 0_sz, 0_sz )
);

let mk-vector(ty: Type<t>): Vector<t> = (
   mk-vector(type(t), 0)
);

let .length(v: Vector<t>): USize = (
   v.end-offset - v.start-offset
);

let $"[]"(v: Vector<t>, idx: USize): t = (
   v.data[v.start-offset + idx]
);

let .realloc(v: Vector<t>, target-capacity: USize): Vector<t> = (
   if target-capacity==0
   then Vector( 0 as OwnedData<t>[], 0, target-capacity )
   else {
      let new-data = mk-owned-data(type(t), target-capacity);
      let dlo = 0_sz;
      let dhi = v.length;
      while dlo < dhi {
         new-data.push(v[dlo]);
         dlo = dlo + 1;
      };
      Vector( new-data, 0, new-data.current-length )
   }
);

# TODO: Vector<t> and i: t should have the same type variable and it should unify
let .push(v: Vector<t>, i: x): Vector<t> = (
   # if this vector is a view, or if it is full, then we need to reallocate
   if (v.data as USize)==0 or v.end-offset < v.data.current-length or v.end-offset >= v.data.capacity {
      let new_capacity = if v.start-offset==v.end-offset then 4_sz
      else (v.length >> 1_sz) + v.length; # this is mul 1.5, not 3
      v = v.realloc(new_capacity);
   };
   v.data.push(i);
   v.end-offset = v.end-offset + 1_sz;
   v
);

let cmp(x: Vector<x>, y: Vector<x>): Ord = (
   let r = Equal;
   if not(is(x, y)) {
      let xi = 0_sz;
      let yi = 0_sz;
      while xi < x.length and yi < y.length {
         if x[xi] < y[yi] {
            r = LessThan;
            xi = x.length;
            yi = y.length;
         } else if x[xi] > y[yi] {
            r = GreaterThan;
            xi = x.length;
            yi = y.length;
         } else {
            xi = xi + 1;
            yi = yi + 1;
         }
      };
      if xi < x.length { r = GreaterThan };
      if yi < y.length { r = LessThan };
   };
   r
);
