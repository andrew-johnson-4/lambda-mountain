
## faster than [type(List<t>)]. should be used when you append or remove data a lot
type Vector<t> implies MustRetain, MustRelease
   = { data: OwnedData<t>[] };

let .release(x: Vector<t>): Nil = (
   if (x.data as USize) != 0 {
      x.data.release;
   };
   mark-as-released(x);
);

let .retain(x: Vector<t>): Vector<t> = (
   if (x.data as USize) != 0 {
      x.data.retain;
   };
   x
);

let mk-vector(ty: Type<t>, capacity: USize): Vector<t> = (
   if capacity==0 then Vector(0 as OwnedData<t>[]) else Vector( mk-owned-data(type(t), capacity) )
);

let mk-vector(ty: Type<t>): Vector<t> = (
   mk-vector(type(t), 0)
);

let mk-vector(capacity: USize): Vector<t> = (
   if capacity==0 then Vector(0 as OwnedData<t>[]) else Vector( mk-owned-data(type(t), capacity) )
);

let mk-vector(): Vector<t> = (
   mk-vector(type(t), 0)
);

let .length(v: Vector<t>): USize = (
   if (v.data as USize) == 0 then 0 else v.data.occupied
);

let $"[]"(v: Vector<t>, idx: USize): t = (
   v.data[idx]
);

let .realloc(v: Vector<t>, target-capacity: USize): Vector<t> = (
   let new-data = mk-owned-data(type(t), target-capacity);
   let dlo = 0_sz;
   let dhi = v.length;
   while dlo < dhi {
      new-data.push(v[dlo]);
      dlo = dlo + 1;
   };
   Vector( new-data )
);

# TODO: Vector<t> and i: t should have the same type variable and it should unify
let .push(v: Vector<t>, i: x): Vector<t> = (
   # if this vector is a view, or if it is full, then we need to reallocate
   if (v.data as USize)==0 or v.data.occupied==v.data.capacity {
      let new-capacity = if v.length==0 then 4_sz
      else (v.length >> 1_sz) + v.length; # this is mul 1.5, not 3
      v = v.realloc(new-capacity);
   };
   v.data.push(i);
   v
);

let cmp(x: Vector<x>, y: Vector<x>): Ord = (
   let r = Equal;
   if not(is(x, y)) {
      let xi = 0_sz;
      let yi = 0_sz;
      while xi < x.length and yi < y.length {
         let xycmp = cmp(x[xi], y[yi]);
         if is(xycmp,LessThan) {
            r = LessThan;
            xi = x.length;
            yi = y.length;
         } else if is(xycmp,GreaterThan) {
            r = GreaterThan;
            xi = x.length;
            yi = y.length;
         } else {
            xi = xi + 1;
            yi = yi + 1;
         }
      };
      if xi < x.length { r = GreaterThan };
      if yi < y.length { r = LessThan };
   };
   r
);

let .sort(v: Vector<t>): Vector<t> = (
   let n = v.length;
   let i = 0_sz;
   while i < n - 1_sz {
      let swapped = false;
      let j = 0_sz;
      while j < n - i - 1_sz {
         if v[j + 1_sz] < v[j] {
            let tmp = v[j];
            v[j] = v[j + 1_sz];
            v[j + 1_sz] = tmp;
            swapped = true;
         };
         j = j + 1_sz;
      };
      i = i + 1_sz;
      if not(swapped) {
         i = n;
      };
   };
   v
);

let .buffer-into-string(v: Vector<U8>): String = (
   v = v.push(0);
   v.data.retain;
   String(0, v.length - 1, v.data)
);

let $"set[]"( v: Vector<t>, i: USize, val: t ): Nil = (
   if i >= v.length then fail(c"Vector Index Out of Bounds");
   v.data[i] = val;
);

let .reverse(v: Vector<t>): Vector<t> = (
   let vi = 0_sz;
   while vi < (v.length/2) {
      let tmp = v[vi];
      v[vi] = v[v.length - vi - 1];
      v[v.length - vi - 1] = tmp;
      vi = vi + 1;
   };
   v
);

let .into(v: Vector<t>, tt: Type<Vector<t>>): Vector<t> = v;
