
## order is important here because
## [type(LessThan).discriminator-case-tag] = 0
## [type(Equal).discriminator-case-tag] = 1
## [type(GreaterThan).discriminator-case-tag] = 2
type Ord = LessThan | Equal | GreaterThan;

interface self implements Comparable {
   let cmp(l: self, r: self): Ord;
};

let $"=="(l: Ord, r: Ord): Bool = l.discriminator-case-tag == r.discriminator-case-tag;
let $"!="(l: Ord, r: Ord): Bool = l.discriminator-case-tag != r.discriminator-case-tag;
let $"<"(l: Ord, r: Ord): Bool  = l.discriminator-case-tag <  r.discriminator-case-tag;
let $"<="(l: Ord, r: Ord): Bool = l.discriminator-case-tag <= r.discriminator-case-tag;
let $">"(l: Ord, r: Ord): Bool  = l.discriminator-case-tag >  r.discriminator-case-tag;
let $">="(l: Ord, r: Ord): Bool = l.discriminator-case-tag >= r.discriminator-case-tag;

let $"=="(l: x+Comparable, r: x+Comparable): Bool = cmp(l, r) == Equal;
let $"!="(l: x+Comparable, r: x+Comparable): Bool = cmp(l, r) != Equal;
let $"<"(l: x+Comparable, r: x+Comparable): Bool  = cmp(l, r) <  Equal;
let $"<="(l: x+Comparable, r: x+Comparable): Bool = cmp(l, r) <= Equal;
let $">"(l: x+Comparable, r: x+Comparable): Bool  = cmp(l, r) >  Equal;
let $">="(l: x+Comparable, r: x+Comparable): Bool = cmp(l, r) >= Equal;

let $"&&"(l: Ord, r: Ord): Ord = if l == Equal then r else l;
