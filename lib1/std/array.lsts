
declare-binop-retain( $"[]", raw-type(base-type[]), raw-type(USize), raw-type(base-type), ( l"("; x; l"["; y; l"])"; ) );
declare-ternop( $"set[]", raw-type(base-type[]), raw-type(USize), raw-type(base-type), raw-type(Nil), ( l"("; x; l"["; y; l"]="; z; l")"; ) );

declare-binop( $"!=", raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l"!="; y; l")"; ) );
declare-binop( $"==", raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l"=="; y; l")"; ) );
declare-binop( $"<",  raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l"<"; y; l")"; ) );
declare-binop( $"<=", raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l"<="; y; l")"; ) );
declare-binop( $">",  raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l">"; y; l")"; ) );
declare-binop( $">=", raw-type(base-type[]), raw-type(base-type[]), raw-type(Bool), ( l"("; x; l">="; y; l")"; ) );

declare-binop( $"+", raw-type(base-type[]), raw-type(USize), raw-type(base-type[]), ( l"("; x; l"+"; y; l")"; ) );
declare-binop( $"+", raw-type(base-type[]), raw-type(ISize), raw-type(base-type[]), ( l"("; x; l"+"; y; l")"; ) );
declare-binop( $"-", raw-type(base-type[]), raw-type(USize), raw-type(base-type[]), ( l"("; x; l"-"; y; l")"; ) );
declare-binop( $"-", raw-type(base-type[]), raw-type(ISize), raw-type(base-type[]), ( l"("; x; l"-"; y; l")"; ) );
declare-binop( $"-", raw-type(base-type[]), raw-type(base-type[]), raw-type(USize), ( l"("; x; l"-"; y; l")"; ) );

declare-unop( $"&", raw-type(t+MustNotRetain), raw-type(t[]), (l"(&"; x; l")";) );
declare-unop( $".void-pointer", raw-type(?[]), raw-type(C<"void">[]), x );

let mark-memory-as-safe(ptr: t[], len: USize): Nil = (
   # BEFORE CHANGING THIS: talk to alex

   while len > 0_sz {
      let ignored = ptr[0_sz];
      len = len - 1_sz;
      ptr = ((ptr as U8[]) + (sizeof(t) as USize)) as t[];
   };
);

# TODO: configure this with conditional compilation to remove if unused
# EXAMPLE: # if CFG.debug
#          let safe-alloc-block-count = 0_u64;
#          let safe-alloc-block-count-monotonic = 0_u64;
#          # endif
# safe-alloc-block-count is an increment/decrement counter to track active malloc blocks
# safe-alloc-block-count-monotonic is an increment-only counter to track historical malloc blocks
let safe-alloc-block-count = 0_u64;
let safe-alloc-block-count-monotonic = 0_u64;

let safe-alloc-impl(nb: USize): ?[] = (
   # BEFORE CHANGING THIS: talk to alex

   let ptr = malloc(nb) as ?[];

   if ptr as USize == 0_sz {
      fail(c"malloc fail");
   };

   # Zero Out Memory
   memset(ptr as C<"void">[], 0, nb);

   mark-memory-as-safe(ptr as U8[], nb);

   # TODO: wrap counter adjustments in conditional compilation
   safe-alloc-block-count = safe-alloc-block-count + 1;
   safe-alloc-block-count-monotonic = safe-alloc-block-count-monotonic + 1;

   ptr
);

let safe-realloc-impl(ptr: ?[], nb: USize): ?[] = (
   # BEFORE CHANGING THIS: talk to alex

   let new-ptr = realloc(ptr as C<"void">[], nb) as ?[];

   if new-ptr as USize == 0_sz {
      fail(c"realloc fail");
   };

   # Zero Out Memory
   memset(new-ptr as C<"void">[], 0, nb);

   mark-memory-as-safe(new-ptr as U8[], nb);

   # TODO: wrap counter adjustments in conditional compilation
   safe-alloc-block-count-monotonic = safe-alloc-block-count-monotonic + 1;

   new-ptr
);

## this will fail() if len is 0
let safe-alloc(len: USize, ty: Type<t>): t[] = (
   # BEFORE CHANGING THIS: talk to alex

   let nb = len * (sizeof(t) as USize);
   safe-alloc-impl(nb) as t[]
);

## this will fail() if len is 0
let safe-realloc(ptr: t[], len: USize, ty: Type<t>): t[] = (
   # BEFORE CHANGING THIS: talk to alex

   let nb = len * (sizeof(t) as USize);
   safe-realloc-impl(ptr as ?[], nb) as t[]
);

let safe-free(ptr: ?[]): Nil = (
   # BEFORE CHANGING THIS: talk to alex

   # TODO: wrap counter adjustments in conditional compilation
   safe-alloc-block-count = safe-alloc-block-count - 1;

   free(ptr as C<"void">[]);
   ()
);

declare-unop( open, raw-type(t), raw-type(t), x );
declare-unop( open, raw-type(base-type[]), raw-type(base-type), (l"(*"; x; l")";) );
declare-unop( $"&", raw-type(t), raw-type(t[]), (l"(&"; x; l")";) );

declare-unop( raw, raw-type(t), raw-type(t), x );
declare-unop( raw, raw-type(base-type[]), raw-type(base-type[]+Raw), x );

let close(x: p): p[] = (
   let r = safe-alloc(1_u64, type(p));
   r[0_u64] = x;
   r
);
