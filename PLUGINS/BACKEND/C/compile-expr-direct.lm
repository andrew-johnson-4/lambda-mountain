
compile-smart-string-index := (: (HashtableEq( 0_u64 0_u64 (as 0_u64 Tuple<String,String>[]) )) HashtableEq<String,String>);

compile-expr-direct := Î»(: ctx FContext)(: term AST)(: stack-offset I64)(: used IsUsed). (: (
   (let e (mk-fragment()))
   (set.context( e (close ctx) ))
   (match term (
      ()
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (Var( 'scope_s _ )) t )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (@( o-t (Var( 'open_s _ )) )) t )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (Var( 'sizeof_s _ )) (AType tt) )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (
         (set e (std-c-compile-expr( ctx term false )))
      ))
      ( (App( (Abs( (@( lhs-t (Var( lhs _ )) )) ASTNil tlt )) rhs )) (
         (let rtype (.without-modifiers(typeof lhs-t)))
         (let fr (mk-expression(uuid())))
         (set std-c-fragment-context (.bind( std-c-fragment-context lhs-t fr )))
         (set ctx (.bind( ctx lhs rtype fr )))
         (let prepost (std-c-mangle-declaration( rtype term )))
         (if false () (
            (match rhs (
               ()
               ( (App( (Lit( ':_s _ )) (App( (Var( '__uninitialized_s _ )) (AType tt) )) )) () )
               ( _ (
                  (set e (compile-expr( ctx rhs stack-offset (Used()) )))
                  (set e (.set( e 'expression_s (
                     (+(
                        (+(
                           (SAtom '\[{_s)
                           (.get( fr 'expression_s ))
                        ))
                        (+(
                           (SAtom '=_s)
                           (+(
                              (.get( e 'expression_s ))
                              (SAtom '\:\[{}\]\:}\]\n_s)
                           ))
                        ))
                     ))
                  ))))
               ))
            ))
            (set e (.set( e 'frame_s (
               (+(
                  (.get( e 'frame_s ))
                  (+(
                     (+(
                        (.first prepost)
                        (SAtom '\s_s)
                     ))
                     (+(
                        (.get( fr 'expression_s ))
                        (+(
                           (.second prepost)
                           (SAtom '\:\n_s)
                        ))
                     ))
                  ))
               ))
            ))))
         ))
         (set.context( e (close ctx) ))
         (set.type( e (typeof term) ))
      ))
      ( (App( is-cons f a )) (
         (if (&&( (not is-cons) (.is-arrow(typeof f)) )) (
            (match f (
               ()
               ( (Var( fname _ )) (
                  (set e (std-c-compile-call( ctx fname a )))
               ))
               ( (Lit( fname _ )) (
                  (let return-type (normalize(typeof term)))
                  (set e (std-c-compile-call( ctx fname return-type a )))
               ))
               ( (App( (Lit( ':_s _ )) (App( (Lit( fname _ )) (AType ft) )) )) (
                  (let return-type (normalize(typeof term)))
                  (set e (std-c-compile-call( ctx fname return-type a )))
               ))
               ( _ (
                  (let call (compile-expr( ctx f stack-offset (Unused()) )))
                  (let args (std-c-compile-push-args( ctx a )))
                  (set e (std-c-chain( call args false )))
                  (set e (.set( e 'expression_s (+(
                     (+( (.get( call 'expression_s )) (SAtom '\[_s) ))
                     (+( (.get( args 'expression_s )) (SAtom '\]_s) ))
                  )))))
               ))
            ))
         ) (
            (if (is( used (Unused()) )) (scope(
               (let e1 (compile-expr( ctx f stack-offset (Unused()) )))
               (let e2 (compile-expr( (open(.context e1)) a 0_i64 (Unused()) )))
               (set e (std-c-chain( e1 e2 false )))
               (set.type( e (typeof term) ))
            )) (scope(
               (let e1 (compile-expr( ctx f stack-offset (Unused()) )))
               (let e2 (compile-expr( (open(.context e1)) a 0_i64 (Used()) )))
               (set e (std-c-chain( e1 e2 false )))
               (set.type( e (typeof term) ))
            )))
         ))
      ))
      ( _ (set e (std-c-compile-expr( ctx term false ))) )
   ))
   e
) Fragment);

