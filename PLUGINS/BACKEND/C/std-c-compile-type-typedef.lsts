
let std-c-compile-type-typedef(td: AST): Nil = (
   match td { Typedef{} => (); };
   let location = (td as Tag::Typedef).location;
   let lhs-type = (td as Tag::Typedef).lhs-type;
   let implements = (td as Tag::Typedef).implements;
   let implies = (td as Tag::Typedef).implies;
   let size = (td as Tag::Typedef).size;
   let alias = (td as Tag::Typedef).alias;
   let opaque-alias = (td as Tag::Typedef).opaque-alias;
   let cases = (td as Tag::Typedef).cases;

   if cases.length > 0 {
   for vector concrete-type in concrete-type-instances-index.lookup(lhs-type.ground-tag-and-arity, mk-vector(type(Type))) {
      let tctx = unify(lhs-type, concrete-type, td);
      continue-compile-c-typedefs-concrete = cons( (tctx, concrete-type), continue-compile-c-typedefs-concrete );
   }};
);

let concrete-typedef-compiled-index = {} : Hashtable<Type,Bool>;

let std-c-compile-type-typedef-concrete(tctx: Maybe<TypeContext>, concrete-type: Type): Nil = (
   concrete-type = concrete-type.with-only-datatype;
   let td = index-typedef.lookup(concrete-type.ground-tag-and-arity, mk-eof());
   match td { Typedef{} => (); _ => (fail("Invalid compile type \{concrete-type} \{td}\n"); ()); };
   let location = (td as Tag::Typedef).location;
   let implements = (td as Tag::Typedef).implements;
   let implies = (td as Tag::Typedef).implies;
   let size = (td as Tag::Typedef).size;
   let alias = (td as Tag::Typedef).alias;
   let opaque-alias = (td as Tag::Typedef).opaque-alias;
   let cases = (td as Tag::Typedef).cases;

   let is-incomplete = false;
   for vector Tuple{case-tag1=first, case-fields=second} in cases {
      for vector Tuple{field-name1=first, field-type=second} in case-fields {
         field-type = tctx.substitute(field-type).rewrite-type-alias;
         if is-incomplete-typedef(field-type) {
            is-incomplete = true;
         }
      }
   };
   if concrete-typedef-compiled-index.lookup(concrete-type,false) or cases.length==0 {
   } else if is-incomplete {
      continue-compile-c-typedefs-concrete = cons( (tctx, concrete-type), continue-compile-c-typedefs-concrete );
   } else {
      concrete-typedef-compiled-index = concrete-typedef-compiled-index.bind(concrete-type, true);
      is-cstruct-hard-compiled-index = is-cstruct-hard-compiled-index.bind(concrete-type, true);

      assemble-header-section = assemble-header-section + SAtom(c"typedef struct ") + std-c-mangle-type(concrete-type, td)
                              + SAtom(c" ") + std-c-mangle-type(concrete-type, td) + SAtom(c";\n");

      assemble-types-section = assemble-types-section + SAtom(c"struct ") + std-c-mangle-type(concrete-type, td) + SAtom(c"{\n");
      
      let has-cases = false;
      for vector Tuple{case-tag2=first, case-fields=second} in cases {
         if case-tag2==c"" {
            for vector Tuple{field-name2=first, field-type=second} in case-fields {
               let mangled-field-name1 = c"0_" + field-name2;
               field-type = tctx.substitute(field-type);
               (let pre-tt, let post-tt) = std-c-mangle-declaration(field-type, td);
               assemble-types-section = assemble-types-section + SAtom(c"  ") + pre-tt + SAtom(c" ") + mangle-identifier(mangled-field-name1) + post-tt + SAtom(c";\n");
            }
         } else has-cases = true;
      };

      if has-cases {
         assemble-types-section = assemble-types-section + SAtom(c"unsigned int discriminator_case_tag") + SAtom(c";\n");

         assemble-types-section = assemble-types-section + SAtom(c"  union {\n");
         let case-number = 0_u64;
         for vector Tuple{case-tag3=first, case-fields=second} in cases {
            if case-tag3!=c"" and case-fields.length > 0 {
               assemble-types-section = assemble-types-section + SAtom(c"    struct {\n");
               for vector Tuple{field-name3=first, field-type=second} in case-fields {
                  let mangled-field-name2 = case-number.into(type(CString)) + c"_" + field-name3;
                  field-type = tctx.substitute(field-type);
                  (let pre-tt, let post-tt) = std-c-mangle-declaration(field-type, td);
                  assemble-types-section = assemble-types-section + SAtom(c"      ") + pre-tt + SAtom(c" ") + mangle-identifier(mangled-field-name2) + post-tt + SAtom(c";\n");
               };
               assemble-types-section = assemble-types-section + SAtom(c"    };\n");
            };
            case-number = case-number + 1;
         };
         assemble-types-section = assemble-types-section + SAtom(c"  };\n");
      };
      assemble-types-section = assemble-types-section + SAtom(c"};\n");

      for vector Tuple{case-tag4=first, case-fields=second} in cases {
         for vector Tuple{field-name4=first, field-type=second} in case-fields {
            let closed-field-type = tctx.substitute(field-type);

            match closed-field-type {
               TGround{tag:c"Array", parameters:[cp2..cp1..]} => (
                  let field-td = index-typedef.lookup(cp1.ground-tag-and-arity,mk-eof());
                  let field-lhs-type = match field-td { Typedef{field-lhs-type=lhs-type} => field-lhs-type; _ => ta; };
                  if non-zero(field-lhs-type) {
                    let field-tctx = unify(field-lhs-type, cp1, field-td);
                    continue-compile-c-typedefs-concrete = cons( (field-tctx, cp1.rewrite-type-alias), continue-compile-c-typedefs-concrete );
                  };

                  field-td = index-typedef.lookup(cp2.ground-tag-and-arity,mk-eof());
                  field-lhs-type = match field-td { Typedef{field-lhs-type2=lhs-type} => field-lhs-type2; _ => ta; };
                  if non-zero(field-lhs-type) {
                    let field-tctx = unify(field-lhs-type, cp2, field-td);
                    continue-compile-c-typedefs-concrete = cons( (field-tctx, cp2.rewrite-type-alias), continue-compile-c-typedefs-concrete );
                  };
               );
               _ => (
                  let field-td = index-typedef.lookup(closed-field-type.ground-tag-and-arity,mk-eof());
                  let field-lhs-type = match field-td { Typedef{field-lhs-type=lhs-type} => field-lhs-type; _ => ta; };
                  if non-zero(field-lhs-type) {
                    let field-tctx = unify(field-lhs-type, closed-field-type, field-td);
                    continue-compile-c-typedefs-concrete = cons( (field-tctx, closed-field-type.rewrite-type-alias), continue-compile-c-typedefs-concrete );
                  };
               );
            };
         };
      };
   };
);

let is-incomplete-typedef(tt: Type): Bool = is-incomplete-typedef(tt, tt.is-t(c"FlexibleArrayMember",0));
let is-incomplete-typedef(tt: Type, is-flexible-array-member: Bool): Bool = (
   match tt {
      TAnd{conjugate=conjugate} => (
         let r = false;
         for vector c in conjugate { r = r or is-incomplete-typedef(c, is-flexible-array-member) };
         r
      );
      TAny{} => false;
      TVar{} => false;
      TGround{tag:c"Sized",parameters:[st..]} => is-incomplete-typedef(st);
      TGround{tag:c"Array",parameters:[_..base-type..]} => if is-flexible-array-member then is-incomplete-typedef(base-type) else false;
      TGround{} => complex-type-index.lookup(tt.ground-tag-and-arity,false)
                and not(is-cstruct-hard-compiled-index.lookup(tt, false));
   }
);

let continue-compile-c-typedefs-concrete = [] : List<(TypeContext?,Type)>;
let continue-compile-c-typedefs-count = 0_u64;
let is-cstruct-hard-compiled-index = {} : Hashtable<Type,Bool>;

let try-continue-compile-c-typedefs(): Nil = (
   let continue = continue-compile-c-typedefs-concrete;
   continue-compile-c-typedefs-concrete = [] : List<(TypeContext?,Type)>;
   while non-zero(continue) {
      continue-compile-c-typedefs-count = continue-compile-c-typedefs-count + 1;
      if continue-compile-c-typedefs-count > 200
      then (
         eprint("Unable To Resolve Circular Type Dependency During Compilation\n");
         for list Tuple{base-type=second} in continue {
            eprint("Typedef: \{base-type}\n")
         };
         exit(1);
      );
      for list Tuple{tctx=first, base-type=second} in continue {
         if not(base-type.is-open) then std-c-compile-type-typedef-concrete(tctx, base-type);
      };
      continue = continue-compile-c-typedefs-concrete;
      continue-compile-c-typedefs-concrete = [] : List<(TypeContext?,Type)>;
   }
);
