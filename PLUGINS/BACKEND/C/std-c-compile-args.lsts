

let std-c-compile-args(callee-ctx: FContext, caller-ctx: FContext, lhs: AST, rhs: AST, f: Fragment): Tuple<Fragment,FContext,FContext> = (
   match lhs {
      App{lhs-rst=left, right:App{ left:Lit{key:c":"}, right:App{left-lhs=left:Var{k1=key}, right:AType{kt=tt}} }} => (
         if typeof-term(rhs).is-t(c"Cons",2) {
            match rhs {
               App{le=left, re=right} => (
                  if kt.is-t(c"...",0) {
                     kt = kt.slot(c"...",0).r1;
                     if can-unify(kt, typeof-term(re)) {
                        if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(re), rhs)); };
                        let c1 = std-c-compile-expr(caller-ctx, re, false);
                        caller-ctx = open(c1.context);
                        callee-ctx = bind-vararg(callee-ctx, k1, kt, c1);
                        (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs, le, f);
                        f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
                     } else {
                        (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs-rst, rhs, f);  
                     }
                  } else {
                     if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(re), rhs)); };
                     let c1 = std-c-compile-expr(caller-ctx, re, false);
                     caller-ctx = open(c1.context);
                     callee-ctx = callee-ctx.bind(k1, kt, c1);
                     std-c-fragment-context = std-c-fragment-context.bind( left-lhs, c1 );
                     (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs-rst, le, f);
                     f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
                  }
               );
            }
         } else {
            if kt.is-t(c"...",0) {
               kt = kt.slot(c"...",0).r1;
               if can-unify(kt, typeof-term(rhs)) {
                  if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(rhs), rhs)); };
                  let c1 = std-c-compile-expr(caller-ctx, rhs, false);
                  f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
                  caller-ctx = open(c1.context);
                  callee-ctx = bind-vararg(callee-ctx, k1, kt, c1);
               } else {
                  (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs-rst, rhs, f);  
               }
            } else {
               if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(rhs), rhs)); };
               let c1 = std-c-compile-expr(caller-ctx, rhs, false);
               caller-ctx = open(c1.context);
               std-c-fragment-context = std-c-fragment-context.bind( left-lhs, c1 );
               callee-ctx = callee-ctx.bind(k1, kt, c1);
               f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
            }
         };
         (f, callee-ctx, caller-ctx)
      );
      App{ left:Lit{key:c":"}, right:App{left-lhs=left:Var{k2=key}, right:AType{kt=tt}} } => (
         if typeof-term(rhs).is-t(c"Cons",2) {
            match rhs {
               App{le=left, re=right} => (
                  if kt.is-t(c"...",0) {
                     kt = kt.slot(c"...",0).r1;
                     if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(re), rhs)); };
                     let c1 = std-c-compile-expr(caller-ctx, re, false);
                     caller-ctx = open(c1.context);
                     callee-ctx = bind-vararg(callee-ctx, k2, kt, c1);
                     (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs, le, f);
                     f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
                  } else {
                     fail("std-c-compile-args unexpected RHS, vararg mismatch");
                  }
               );
            }
         } else {
            if kt.is-t(c"...",0) {
               kt = kt.slot(c"...",0).r1;
               if can-unify(kt, typeof-term(rhs)) {
                  if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(rhs), rhs)); };
                  let c1 = std-c-compile-expr(caller-ctx, rhs, false);
                  caller-ctx = open(c1.context);
                  callee-ctx = bind-vararg(callee-ctx, k2, kt, c1);
                  f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
               } else {
                  (f, callee-ctx, caller-ctx) = std-c-compile-args(callee-ctx, caller-ctx, lhs, rhs, f);
               }
            } else {
               if kt.is-open { callee-ctx = union(callee-ctx, unify(kt, typeof-term(rhs), rhs)); };
               let c1 = std-c-compile-expr(caller-ctx, rhs, false);
               caller-ctx = open(c1.context);
               std-c-fragment-context = std-c-fragment-context.bind( left-lhs, c1 );
               callee-ctx = callee-ctx.bind(k2, kt, c1);
               f = f.set(c"frame", f.get(c"frame") + c1.get(c"frame"));
            }
         };
         (f, callee-ctx, caller-ctx)
      );
      ASTNil{} => (f, callee-ctx, caller-ctx);
      _ => (
         print("std-c-compile-args Invalid Args: "); std-c-print(lhs); print("\n"); exit(1);
         (f, callee-ctx, caller-ctx)
      );
   }
);
