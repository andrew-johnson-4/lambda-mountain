
# Loosely based on the attached EBNF (c-grammar.ebnf) for ANSI C
# (Katayama Hirofumi MZ. License: MIT)
#
# The naming of production rules try to follow this format.
# However, there are also a large number of compiler-specific extensions that are parsed but mostly ignored
# Example: __extension__ ( f, g )

type CTerm = CInteger{value:String}
            | CCharacter{value:String}
            | CFloating{value:String}
            | CEnumeration{value:String}
            | CString{value:String}
            | CIdentifier{value:String}
            | CType1{value:String}
            | CList{value:OwnedData<List<CTerm>>[]}
            | CIList{value:OwnedData<List<String>>[]}
            | CMaybe{value:OwnedData<Maybe<CTerm>>[]}
            | CZOp{op:String}
            | CCompound{terms:OwnedData<List<CTerm>>[]}
            | CPointer{qualifiers:OwnedData<Maybe<List<CTerm>>>[], next:OwnedData<Maybe<CTerm>>[]}
            | CInitializer{designator:OwnedData<List<CTerm>>[], initializer:OwnedData<CTerm>[]}
            | CInitializerList{terms:OwnedData<List<CTerm>>[]}
            | CUnaryPostfix{op:String, arg:OwnedData<CTerm>[]}
            | CUnaryPrefix{op:String, arg:OwnedData<CTerm>[]}
            | CBinaryOp{op:String, arg1:OwnedData<CTerm>[], arg2:OwnedData<CTerm>[]}
            | CTernaryOp{op:String, arg1:OwnedData<CTerm>[], arg2:OwnedData<CTerm>[], arg3: OwnedData<CTerm>[]}
            | CFor{op:String, arg1:OwnedData<Maybe<CTerm>>[], arg2:OwnedData<Maybe<CTerm>>[], arg3: OwnedData<Maybe<CTerm>>[], stmt:OwnedData<CTerm>[]}
            | CFunctionDefinition{specifiers:OwnedData<CTerm>[], declarator:OwnedData<CTerm>[], declaration-list:OwnedData<CTerm>[], statement:OwnedData<CTerm>[]}
            | CAccessor{accessor:String, field:String, arg:OwnedData<CTerm>[]};

let cmp(l: CTerm, r: CTerm): Ord = (
   if l.discriminator-case-tag != r.discriminator-case-tag then cmp(l.discriminator-case-tag, r.discriminator-case-tag)
   else match Tuple(l, r) {
      Tuple{ first:CInteger{lv=value}, second:CInteger{rv=value} } => cmp(lv, rv);
      Tuple{ first:CCharacter{lv=value}, second:CCharacter{rv=value} } => cmp(lv, rv);
      Tuple{ first:CFloating{lv=value}, second:CFloating{rv=value} } => cmp(lv, rv);
      Tuple{ first:CEnumeration{lv=value}, second:CEnumeration{rv=value} } => cmp(lv, rv);
      Tuple{ first:CString{lv=value}, second:CString{rv=value} } => cmp(lv, rv);
      Tuple{ first:CIdentifier{lv=value}, second:CIdentifier{rv=value} } => cmp(lv, rv);
      Tuple{ first:CType1{lv=value}, second:CType1{rv=value} } => cmp(lv, rv);
      Tuple{ first:CList{lv=value}, second:CList{rv=value} } => cmp(lv, rv);
      Tuple{ first:CIList{lv=value}, second:CIList{rv=value} } => cmp(lv, rv);
      Tuple{ first:CMaybe{lv=value}, second:CMaybe{rv=value} } => cmp(lv, rv);
      Tuple{ first:CZOp{lv=op}, second:CZOp{rv=op} } => cmp(lv, rv);
      Tuple{ first:CCompound{lterms=terms}, second:CCompound{rterms=terms} } => cmp(lterms, rterms);
      Tuple{ first:CPointer{lq=qualifiers,ln=next}, second:CPointer{rq=qualifiers,rn=next} } => cmp(lq,rq) && cmp(ln,rn);
      Tuple{ first:CInitializer{ld=designator,li=initializer}, second:CInitializer{rd=designator,ri=initializer} } => cmp(ld,rd) && cmp(li,ri);
      Tuple{ first:CInitializerList{lterms=terms}, second:CInitializerList{rterms=terms} } => cmp(lterms, rterms);
      Tuple{ first:CUnaryPrefix{lop=op,larg=arg}, second:CUnaryPrefix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CUnaryPostfix{lop=op,larg=arg}, second:CUnaryPostfix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CBinaryOp{lop=op,larg1=arg1,larg2=arg2}, second:CBinaryOp{rop=op,rarg1=arg1,rarg2=arg2} } => cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2);
      Tuple{ first:CTernaryOp{lop=op,larg1=arg1,larg2=arg2,larg3=arg3}, second:CTernaryOp{rop=op,rarg1=arg1,rarg2=arg2,rarg3=arg3} } => cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2) && cmp(larg3,rarg3);
      Tuple{ first:CFor{lop=op,larg1=arg1,larg2=arg2,larg3=arg3,lst=stmt}, second:CFor{rop=op,rarg1=arg1,rarg2=arg2,rarg3=arg3,rst=stmt} } =>
      cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2) && cmp(larg3,rarg3) && cmp(lst,rst);
      Tuple{ first:CAccessor{lacc=accessor,lf=field,larg=arg}, second:CAccessor{racc=accessor,rf=field,rarg=arg} } => cmp(lacc,racc) && cmp(lf,rf) && cmp(larg,rarg);
   }
);

let .into(l: CTerm, tt: Type<String>): String = (
   match l {
      CInteger{rv=value} => "{Integer \{rv}}";
      CCharacter{rv=value} => "{Character \{rv}}";
      CFloating{rv=value} => "{Floating \{rv}}";
      CEnumeration{rv=value} => "{Enumeration \{rv}}";
      CString{rv=value} => "{String \{rv}}";
      CIdentifier{rv=value} => "{Identifier \{rv}}";
      CType1{rv=value} => "{Type \{rv}}";
      CList{rv=value} => "{List \{rv}}";
      CIList{rv=value} => "{IList \{rv}}";
      CMaybe{rv=value} => "{Maybe \{rv}}";
      CZOp{op=op} => "{ZOp \{op}}";
      CCompound{rv=terms} => "{Compound \{rv}}";
      CPointer{q=qualifiers,n=next} => "{Pointer \{q} \{n}}";
      CInitializer{q=designator,n=initializer} => "{Initializer \{q} \{n}}";
      CInitializerList{q=terms} => "{InitializerList \{q}}";
      CUnaryPostfix{rop=op,rarg=arg} => "{Postfix \{rop} \{rarg}}";
      CUnaryPrefix{rop=op,rarg=arg} => "{Prefix \{rop} \{rarg}}";
      CBinaryOp{op=op,arg1=arg1,arg2=arg2} => "{BinaryOp \{op} \{arg1} \{arg2}}";
      CTernaryOp{op=op,arg1=arg1,arg2=arg2,arg3=arg3} => "{TernaryOp \{op} \{arg1} \{arg2} \{arg3}}";
      CFor{op=op,arg1=arg1,arg2=arg2,arg3=arg3,stmt=stmt} => "{For \{op} \{arg1} \{arg2} \{arg3} \{stmt}}";
      CFunctionDefinition{spec=specifiers,decl=declarator,dl=declaration-list,stmt=statement} => "{Function\n\t\{spec}\n\t\{decl}\n\t\{dl}\n\t\{stmt}\n}";
      CAccessor{racc=accessor,rf=field,rarg=arg} => "{Accessor \{racc} \{rf} \{rarg}}";
   }
);

let std-c-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let original-tokens = tokens;
      tokens = std-c-parse-external-declaration(tokens);
      if is(tokens, original-tokens) {
         fail("Expected token '\{head(tokens).key}' at \{tokens.formatted-location}\n");
      };
   };
);

let std-c-is-reserved-word(tk: String): Bool = (
   let reserved = false;
   if tk == "auto" then (reserved = true);
   if tk == "double" then (reserved = true);
   if tk == "int" then (reserved = true);
   if tk == "struct" then (reserved = true);
   if tk == "break" then (reserved = true);
   if tk == "else" then (reserved = true);
   if tk == "long" then (reserved = true);
   if tk == "switch" then (reserved = true);
   if tk == "case" then (reserved = true);
   if tk == "enum" then (reserved = true);
   if tk == "register" then (reserved = true);
   if tk == "typedef" then (reserved = true);
   if tk == "__extension__" then (reserved = true);
   if tk == "char" then (reserved = true);
   if tk == "extern" then (reserved = true);
   if tk == "return" then (reserved = true);
   if tk == "union" then (reserved = true);
   if tk == "const" then (reserved = true);
   if tk == "float" then (reserved = true);
   if tk == "short" then (reserved = true);
   if tk == "unsigned" then (reserved = true);
   if tk == "continue" then (reserved = true);
   if tk == "for" then (reserved = true);
   if tk == "signed" then (reserved = true);
   if tk == "void" then (reserved = true);
   if tk == "default" then (reserved = true);
   if tk == "goto" then (reserved = true);
   if tk == "sizeof" then (reserved = true);
   if tk == "volatile" then (reserved = true);
   if tk == "do" then (reserved = true);
   if tk == "if" then (reserved = true);
   if tk == "static" then (reserved = true);
   if tk == "while" then (reserved = true);
   if tk == "_Bool" then (reserved = true);
   if tk == "_Imaginary" then (reserved = true);
   if tk == "restrict" then (reserved = true);
   if tk == "__restrict" then (reserved = true);
   if tk == "_Complex" then (reserved = true);
   if tk == "inline" then (reserved = true);
   if tk == "_Alignas" then (reserved = true);
   if tk == "_Generic" then (reserved = true);
   if tk == "_Thread_local" then (reserved = true);
   if tk == "_Alignof" then (reserved = true);
   if tk == "_Noreturn" then (reserved = true);
   if tk == "_Atomic" then (reserved = true);
   if tk == "_Static_assert" then (reserved = true);
   reserved
);

let std-c-has-class(tks: String, cls: String): Bool = (
   let tk = tks.into(type(CString));
   match cls {
      "identifier" => tk == r/^[a-zA-Z_][a-zA-Z0-9_]*/ and not(std-c-is-reserved-word(tks));
      "integer" => tk == r/^[0-9]+([uU]|[lL]|wb|WB)*/                # decimal constant
                or tk == r/^[0][0-7]+([uU]|[lL]|wb|WB)*/             # octal constant
                or tk == r/^[0][x][0-9a-fA-F]+([uU]|[lL]|wb|WB)*/    # hexadecimal constant
                or tk == r/^[0][bB][01]+([uU]|[lL]|wb|WB)*/;         # binary constant
      "character" => tk == r/^(u8|u|U|L)?[']([^']|([\\][']))+[']/;    # character constant
      "floating" => tk == r/^[0-9]+([.][0-9]+)?([eE][0-9]+)?[fF]?/                                        # decimal constant
                 or tk == r/^[0][x][0-9a-fA-F]+([.][0-9a-fA-F]+)?([eE][0-9a-fA-F]+)?([pP][0-9]+)[fF]?/;   # hexadecimal constant
      "string" => tk == r/^[RLuU8]*["]([^"\\]|([\\].))*["]/;
      "enumeration" => std-c-enumeration-constant-index.has(tks);
      _ => tks == cls;
   }
);

let std-c-can-take(tokens: List<Token>, cls: String): Bool = (
   non-zero(tokens) and std-c-has-class(head(tokens).skey, cls)
);

let std-c-take-expect(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) and std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else (print("Expected token [\{cls}] at \{tokens.formatted-location}\n"); exit(1); tokens);
);

let std-c-take-maybe(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) and std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else tokens;
);

let std-c-parse-external-declaration(tokens: List<Token>): List<Token> = (
   let fd = std-c-parse-function-definition(tokens); tokens = fd.second;
   if fd.first.is-some { std-c-declare(fd.first.get-or-panic); };
   let d = std-c-parse-declaration(tokens); tokens = d.second;
   if d.first.is-some { std-c-declare(d.first.get-or-panic); };
   tokens;
);

let std-c-parse-attribute(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   # https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html
   # just ignore attributes for now
   let no = (None : Maybe<CTerm>)();
   while std-c-can-take(tokens, "__attribute__") or std-c-can-take(tokens, "__asm__") {
      if std-c-can-take(tokens, "__attribute__") {
         tokens = std-c-take-expect(tokens, "__attribute__");
         tokens = std-c-take-expect(tokens, "(");
         tokens = std-c-take-expect(tokens, "(");
         let depth = 2_u64;
         while non-zero(tokens) and depth > 0 {
            if head(tokens).key == c"(" then depth = depth + 1;
            if head(tokens).key == c")" then depth = depth - 1;
            tokens = tail(tokens);
         };
      } else {
         tokens = std-c-take-expect(tokens, "__asm__");
         tokens = std-c-take-expect(tokens, "(");
         let depth = 1_u64;
         while non-zero(tokens) and depth > 0 {
            if head(tokens).key == c"(" then depth = depth + 1;
            if head(tokens).key == c")" then depth = depth - 1;
            tokens = tail(tokens);
         };
      }
   };
   Tuple( no, tokens )
);

let std-c-parse-function-definition(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let original-tokens = tokens;
   let no = (None : Maybe<CTerm>)();
   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
   let return = if declaration-specifiers.first.is-some {
      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
      let declaration-list = std-c-parse-declaration-list(tokens); tokens = declaration-list.second;
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let compound-statement = std-c-parse-compound-statement(tokens); tokens = compound-statement.second;
      if declarator.first.is-some and compound-statement.first.is-some
      then Tuple( Some(CFunctionDefinition(
         close-owned(declaration-specifiers.first.get-or-panic),
         close-owned(declarator.first.get-or-panic),
         close-owned(CMaybe(close-owned(declaration-list.first))),
         close-owned(compound-statement.first.get-or-panic)
      )), tokens )
      else Tuple( no, original-tokens )
   } else Tuple( no, original-tokens );
   return
);

let std-c-parse-declaration(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens);
   if declaration-specifiers.first.is-some {
      tokens = declaration-specifiers.second;
      let init-declarator-list = std-c-parse-init-declarator-list(tokens); tokens = init-declarator-list.second;
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      tokens = std-c-take-expect(tokens, ";");
      Tuple( Some(CBinaryOp("Declaration", close-owned(declaration-specifiers.first.get-or-panic), close-owned(CMaybe(close-owned(init-declarator-list.first))) )), tokens )
   } else {
      let ad = std-c-parse-static-assert-declaration(tokens); tokens = ad.second;
      tokens = std-c-take-maybe(tokens, ";");
      Tuple( ad.first, tokens )
   };
);

let std-c-parse-declaration-specifiers(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let attr = std-c-parse-attribute(tokens); tokens = attr.second;
   let spec = std-c-parse-declaration-specifier(tokens); tokens = spec.second;
   if spec.first.is-some {
      let specs = [spec.first.get-or-panic];
      while spec.first.is-some {
         let attr2 = std-c-parse-attribute(tokens); tokens = attr2.second;
         spec = std-c-parse-declaration-specifier(tokens); tokens = spec.second;
         if spec.first.is-some { specs = cons( spec.first.get-or-panic, specs ); };
      };
      Tuple( Some(CList(close-owned(specs.reverse))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-declaration-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let spec = std-c-parse-storage-class-specifier(tokens);
   if spec.first.is-none then { spec = std-c-parse-type-specifier(tokens); };
   if spec.first.is-none then { spec = std-c-parse-type-qualifier(tokens); };
   if spec.first.is-none then { spec = std-c-parse-function-specifier(tokens); };
   if spec.first.is-none then { spec = std-c-parse-alignment-specifier(tokens); };
   spec
);

let std-c-parse-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let pointer = std-c-parse-pointer(tokens); tokens = pointer.second;
   let dd = std-c-parse-direct-declarator(tokens); tokens = dd.second;
   if pointer.first.is-some and dd.first.is-some
   then Tuple( Some(CBinaryOp("Declarator*", close-owned(pointer.first.get-or-panic), close-owned(dd.first.get-or-panic))), tokens )
   else dd
);

let std-c-parse-declaration-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
   if declaration.first.is-some {
      let decls = [declaration.first.get-or-panic];
      declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
      while declaration.first.is-some {
         decls = cons(declaration.first.get-or-panic, decls);
         declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
      };
      Tuple( Some(CList(close-owned(decls))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-compound-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "{") {
      let stmts = [] : List<CTerm>;
      tokens = std-c-take-expect(tokens, "{");
      let declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
      while declaration-or-statement.first.is-some {
         stmts = cons( declaration-or-statement.first.get-or-panic, stmts );
         declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
      };
      tokens = std-c-take-expect(tokens, "}");
      Tuple( Some(CCompound(close-owned(stmts.reverse))), tokens );
   } else Tuple( no, tokens)
);

let std-c-parse-declaration-or-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let declaration = std-c-parse-declaration(tokens);
   if declaration.first.is-some then declaration else std-c-parse-statement(tokens);
);

let std-c-parse-init-declarator-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let id = std-c-parse-init-declarator(tokens);
   if id.first.is-some {
      let ids = [id.first.get-or-panic];
      tokens = id.second;
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         id = std-c-parse-init-declarator(tokens); tokens = id.second;
         if id.first.is-some { ids = cons( id.first.get-or-panic, ids ) };
      };
      Tuple( Some(CList(close-owned(ids.reverse))), tokens )
   } else Tuple(no, tokens);
);

let std-c-parse-init-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let declarator = std-c-parse-declarator(tokens);
   if declarator.first.is-some {
      tokens = declarator.second;
      if std-c-can-take(tokens, "=") {
         let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "=");
         let initializer = std-c-parse-initializer(tokens); tokens = initializer.second;
         if initializer.first.is-none then std-c-take-expect(tokens, "[Initializer]");
         Tuple( Some(CBinaryOp( op, close-owned(declarator.first.get-or-panic), close-owned(initializer.first.get-or-panic) )), tokens )
      } else declarator
   } else declarator
);

let std-c-parse-static-assert-declaration(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "_Static_assert") {
      let op = head(tokens).skey;
      tokens = std-c-take-expect(tokens, "_Static_assert");
      tokens = std-c-take-expect(tokens, "(");
      let constant-expression = std-c-parse-constant-expression(tokens);
      if constant-expression.first.is-none { std-c-take-expect(tokens, "[Constant Expression]"); };
      tokens = std-c-take-expect(tokens, ",");
      let s = if non-zero(tokens) then head(tokens).skey else "";
      tokens = std-c-take-expect(tokens, "string");
      tokens = std-c-take-expect(tokens, ")");
      tokens = std-c-take-expect(tokens, ";");
      Tuple( Some(CBinaryOp( op, close-owned(constant-expression.first.get-or-panic), close-owned(CString(s)) )), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-storage-class-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "typedef") then (tokens = std-c-take-expect(tokens, "typedef"); Tuple(Some(CType1("typedef")), tokens) )
   else if std-c-can-take(tokens, "__extension__") then (tokens = std-c-take-expect(tokens, "__extension__"); Tuple(Some(CType1("__extension__")), tokens) )
   else if std-c-can-take(tokens, "extern") then (tokens = std-c-take-expect(tokens, "extern"); Tuple(Some(CType1("extern")), tokens) )
   else if std-c-can-take(tokens, "static") then (tokens = std-c-take-expect(tokens, "static"); Tuple(Some(CType1("static")), tokens) )
   else if std-c-can-take(tokens, "_Thread_local") then (tokens = std-c-take-expect(tokens, "_Thread_local"); Tuple(Some(CType1("_Thread_local")), tokens) )
   else if std-c-can-take(tokens, "auto") then (tokens = std-c-take-expect(tokens, "auto"); Tuple(Some(CType1("auto")), tokens) )
   else if std-c-can-take(tokens, "register") then (tokens = std-c-take-expect(tokens, "register"); Tuple(Some(CType1("register")), tokens) )
   else Tuple(no, tokens)
);

let std-c-parse-type-qualifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "const") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "const"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "restrict") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "restrict"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "__restrict") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "__restrict"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "volatile") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "volatile"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "_Atomic") and not(std-c-can-take(tail(tokens), "("))
   then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Atomic"); Tuple(Some(CType1(t)), tokens) )
   else Tuple(no, tokens)
);

let std-c-parse-function-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "inline") {
      let spec = head(tokens).skey; tokens = std-c-take-expect(tokens, "inline");
      Tuple( Some(CType1(spec)), tokens )
   } else if std-c-can-take(tokens, "_Noreturn") {
      let spec = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Noreturn");
      Tuple( Some(CType1(spec)), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-alignment-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "_Alignas") then {
      tokens = std-c-take-expect(tokens, "_Alignas");
      tokens = std-c-take-expect(tokens, "(");
      let tn = std-c-parse-type-name(tokens);
      if tn.first.is-none { tn = std-c-parse-constant-expression(tokens); tokens = tn.second; };
      if tn.first.is-none { tokens = std-c-take-expect(tokens, "[Alignment Specifier]"); };
      Tuple( Some( CUnaryPrefix("_Alignas",close-owned(tn.first.get-or-panic)) ), tokens )
   } else Tuple(no, tokens)
);

let std-c-parse-direct-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let yes = Some(CIdentifier("")) : Maybe<CTerm>; # syntax extension: in parameter lists the identifier can be empty
   let no = (None : Maybe<CTerm>)();
   let original-tokens = tokens;
   let be = if std-c-can-take(tokens, "identifier") then {
      let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      Tuple( Some(CIdentifier(id)), tokens )
   } else if std-c-can-take(tokens, "(") then {
      tokens = std-c-take-expect(tokens, "(");
      let decl = std-c-parse-declarator(tokens); tokens = decl.second;
      if decl.first.is-some then {
         tokens = std-c-take-expect(tokens, ")");
         Tuple( decl.first, tokens )
      } else Tuple( no, original-tokens )
   } else Tuple( yes, tokens );
   tokens = be.second;
   while be.first.is-some and (std-c-can-take(tokens,"(") or std-c-can-take(tokens, "[")) {
      if std-c-can-take(tokens,"[") and std-c-can-take(tail(tokens),"*") {
         tokens = std-c-take-expect(tokens, "[");
         tokens = std-c-take-expect(tokens, "*");
         tokens = std-c-take-expect(tokens, "]");
         be = Tuple( Some(CUnaryPrefix("Declarator:*", close-owned(be.first.get-or-panic))), tokens )
      } else if std-c-can-take(tokens,"[") and std-c-can-take(tail(tokens),"static") {
         tokens = std-c-take-expect(tokens, "[");
         tokens = std-c-take-expect(tokens, "static");
         let tql = std-c-parse-type-qualifier-list(tokens); tokens = tql.second;
         let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
         tokens = std-c-take-expect(tokens, "]");
         if ae.first.is-some and tql.first.is-some
         then { be = Tuple( Some(CTernaryOp(
            "Declarator:static",
             close-owned(be.first.get-or-panic),
             close-owned(CList(close-owned(tql.first.get-or-panic))),
             close-owned(ae.first.get-or-panic)
         )), tokens )}
         else if ae.first.is-some
         then { be = Tuple( Some(CBinaryOp(
            "Declarator:static",
             close-owned(be.first.get-or-panic),
             close-owned(ae.first.get-or-panic)
         )), tokens )}
         else {be = Tuple( no, tokens )}
      } else if std-c-can-take(tokens,"[") {
         tokens = std-c-take-expect(tokens, "[");
         let tql = std-c-parse-type-qualifier-list(tokens); tokens = tql.second;
         let static = if std-c-can-take(tokens, "static")
         then { tokens = std-c-take-expect(tokens, "static"); true; }
         else { false; };
         let pointer = if std-c-can-take(tokens, "*")
         then { tokens = std-c-take-expect(tokens, "*"); true; }
         else { false; };
         let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
         tokens = std-c-take-expect(tokens, "]");
         if tql.first.is-some and pointer
         then {be = Tuple( Some(CBinaryOp("Declarator[:*", close-owned(be.first.get-or-panic), close-owned(CList(close-owned(tql.first.get-or-panic))))), tokens )}
         else if tql.first.is-some and static and ae.first.is-some
         then {be = Tuple( Some(CTernaryOp("Declarator[:*", close-owned(be.first.get-or-panic), close-owned(CList(close-owned(tql.first.get-or-panic))), close-owned(ae.first.get-or-panic))), tokens )}
         else if tql.first.is-some and ae.first.is-some
         then {be = Tuple( Some(CTernaryOp("Declarator[", close-owned(be.first.get-or-panic), close-owned(CList(close-owned(tql.first.get-or-panic))), close-owned(ae.first.get-or-panic))), tokens )}
         else if ae.first.is-some
         then {be = Tuple( Some(CBinaryOp("Declarator[", close-owned(be.first.get-or-panic), close-owned(ae.first.get-or-panic))), tokens )}
         else {be = Tuple( no, tokens )}
      } else if std-c-can-take(tokens,"(") {
         tokens = std-c-take-expect(tokens, "(");
         let te = (None : Maybe<CTerm>)();
         let ptl = std-c-parse-parameter-type-list(tokens);
         if ptl.first.is-some {
            te = ptl.first;
            tokens = ptl.second;
         } else {
            if let Tuple{first:Some{content=content}, second=second} = std-c-parse-identifier-list(tokens) {
               te = Some(CIList(close-owned(content)));
               tokens = second;
            };
         };
         tokens = std-c-take-expect(tokens, ")");
         if te.is-some
         then {be = Tuple( Some(CBinaryOp("Declarator(", close-owned(be.first.get-or-panic), close-owned(te.get-or-panic))), tokens )}
         else {be = Tuple( Some(CUnaryPrefix("Declarator(", close-owned(be.first.get-or-panic))), tokens )}
      }
   };
   be
);

let std-c-parse-identifier-list(tokens: List<Token>): Tuple<Maybe<List<String>>,List<Token>> = (
   let no = (None : Maybe<List<String>>)();
   if std-c-can-take(tokens, "identifier") then {
      let ids = [head(tokens).skey];
      tokens = std-c-take-expect(tokens, "identifier");
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         if non-zero(tokens) {
            ids = cons( head(tokens).skey, ids );
         };
         tokens = std-c-take-expect(tokens, "identifier");
      };
      Tuple( Some(ids.reverse), tokens )
   } else Tuple(no, tokens);
);

let std-c-parse-designative-initializer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let designation = std-c-parse-designation(tokens); tokens = designation.second;
   let initializer = std-c-parse-initializer(tokens); tokens = initializer.second;
   if designation.first.is-some and initializer.first.is-some
   then Tuple( Some(CInitializer(close-owned(designation.first.get-or-panic),close-owned(initializer.first.get-or-panic))), tokens )
   else if initializer.first.is-some
   then Tuple( Some(CInitializer(close-owned([] : List<CTerm>),close-owned(initializer.first.get-or-panic))), tokens )
   else Tuple( no, tokens );
);

let std-c-parse-initializer-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = (None : Maybe<List<CTerm>>)();
   let di = std-c-parse-designative-initializer(tokens); tokens = di.second;
   if di.first.is-some {
      let dis = [di.first.get-or-panic];
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         di = std-c-parse-designative-initializer(tokens); tokens = di.second;
         if di.first.is-some { dis = cons(di.first.get-or-panic, dis); };
      };
      Tuple( Some(dis.reverse), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-initializer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "{") {
      tokens = std-c-take-expect(tokens, "{");
      let initializer-list = std-c-parse-initializer-list(tokens); tokens = initializer-list.second;
      if std-c-can-take(tokens, ",") {
         initializer-list.second = std-c-take-expect(tokens, ",");
      };
      initializer-list.second = std-c-take-expect(tokens, "}");
      if initializer-list.first.is-some
      then Tuple( Some(CInitializerList(close-owned(initializer-list.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else std-c-parse-assignment-expression(tokens);
);

let std-c-parse-atomic-type-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "_Atomic") and std-c-can-take(tail(tokens), "(") then {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Atomic");
      tokens = std-c-take-expect(tokens, "(");
      let tn = std-c-parse-type-name(tokens); tokens = tn.second;
      tokens = std-c-take-expect(tokens, ")");
      if tn.first.is-some
      then Tuple( Some(CUnaryPrefix(op, close-owned(tn.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-struct-or-union-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "struct") or std-c-can-take(tokens, "union") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let id = if std-c-can-take(tokens, "identifier") {
         let id = head(tokens).skey;
         tokens = std-c-take-expect(tokens, "identifier");
         id
      } else "";
      let sdl = no;
      if std-c-can-take(tokens, "{") {
         tokens = std-c-take-expect(tokens, "{");
         let sdlm = std-c-parse-struct-declaration-list(tokens); tokens = sdlm.second;
         sdl = sdlm.first;
         tokens = std-c-take-expect(tokens, "}");
      };
      let attr2 = std-c-parse-attribute(tokens); tokens = attr2.second;
      Tuple( Some(CBinaryOp(op, close-owned(CIdentifier(id)), close-owned(CMaybe(close-owned(sdl))))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-struct-declaration-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let sq = std-c-parse-struct-declaration(tokens);
   if sq.first.is-some {
      let sql = [sq.first.get-or-panic];
      tokens = sq.second;
      while sq.first.is-some {
         sq = std-c-parse-struct-declaration(tokens);
         if sq.first.is-some {
            sql = cons( sq.first.get-or-panic, sql );
            tokens = sq.second;
         };
      };
      Tuple( Some(CList(close-owned(sql.reverse))), tokens )
   } else Tuple ( no, tokens )
);

let std-c-parse-struct-declaration(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let sql = std-c-parse-specifier-qualifier-list(tokens);
   if sql.first.is-some {
      tokens = sql.second;
      let sdl = std-c-parse-struct-declarator-list(tokens); tokens = sdl.second;
      tokens = std-c-take-expect(tokens, ";");
      if sdl.first.is-some
      then Tuple( Some(CBinaryOp( "StructDeclaration", close-owned(CList(close-owned(sql.first.get-or-panic))), close-owned(sdl.first.get-or-panic) )), tokens )
      else Tuple( Some(CUnaryPrefix( "StructDeclaration", close-owned(CList(close-owned(sql.first.get-or-panic))) )), tokens )
   } else std-c-parse-static-assert-declaration(tokens);
);

let std-c-parse-enumerator-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "enum") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "enum");
      let id = if std-c-can-take(tokens, "identifier") {
         let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
         id
      } else "";
      let es = if std-c-can-take(tokens, "{") {
         tokens = std-c-take-expect(tokens, "{");
         let el = std-c-parse-enumerator-list(tokens); tokens = el.second;
         tokens = std-c-take-expect(tokens, "}");
         if el.first.is-some
         then el.first.get-or-panic
         else CList(close-owned([] : List<CTerm>));
      } else CList(close-owned([] : List<CTerm>));
      Tuple( Some(CBinaryOp(op, close-owned(CIdentifier(id)), close-owned(es) )), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-enumerator-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let e = std-c-parse-enumerator(tokens);
   if e.first.is-some {
      tokens = e.second;
      let es = [e.first.get-or-panic];
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         e = std-c-parse-enumerator(tokens);
         tokens = e.second;
         if e.first.is-some { es = cons( e.first.get-or-panic, es ); };
      };
      e = Tuple( Some(CList(close-owned(es))), tokens );
   };
   e
);

let std-c-enumeration-constant-index = {} : Hashtable<String,Bool>;

let std-c-parse-enumerator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "identifier") {
      let ec = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      std-c-enumeration-constant-index = std-c-enumeration-constant-index.bind(ec, true);
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let ce = if std-c-can-take(tokens,"=") {
         tokens = std-c-take-expect(tokens, "=");
         std-c-parse-constant-expression(tokens);
      } else Tuple( no, tokens );
      tokens = ce.second;
      Tuple( Some(CBinaryOp("Enumerator", close-owned(CIdentifier(ec)), close-owned(CMaybe(close-owned(ce.first))) )), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-type-name(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let sql = std-c-parse-specifier-qualifier-list(tokens);
   if sql.first.is-some then {
      tokens = sql.second;
      let ad = std-c-parse-abstract-declarator(tokens); tokens = ad.second;
      Tuple( Some(CBinaryOp( "TypeName", close-owned(CList(close-owned(sql.first.get-or-panic))), close-owned(CMaybe(close-owned(ad.first))) )), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-specifier-qualifier-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = (None : Maybe<List<CTerm>>)();
   let sq = std-c-parse-specifier-qualifier(tokens);
   if sq.first.is-some {
      let sql = [sq.first.get-or-panic];
      tokens = sq.second;
      while sq.first.is-some {
         sq = std-c-parse-specifier-qualifier(tokens);
         if sq.first.is-some {
            sql = cons( sq.first.get-or-panic, sql );
            tokens = sq.second;
         };
      };
      Tuple( Some(sql.reverse), tokens )
   } else Tuple ( no, tokens )
);

let std-c-parse-specifier-qualifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let sq = std-c-parse-type-specifier(tokens);
   if sq.first.is-none { sq = std-c-parse-type-qualifier(tokens); };
   sq
);

let std-c-typedef-name-index = {} : Hashtable<String,Bool>;

# some C things are non-standard but still just hard-coded
std-c-typedef-name-index = std-c-typedef-name-index.bind("__builtin_va_list", true);

let std-c-parse-typedef-name(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if non-zero(tokens) and std-c-typedef-name-index.has(head(tokens).skey) {
      Tuple( Some(CType1(head(tokens).skey)), tail(tokens) )
   } else Tuple( no, tokens )
);

let std-c-parse-type-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   if std-c-can-take(tokens, "void") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "void"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "char") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "char"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "short") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "short"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "int") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "int"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "long") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "long"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "float") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "float"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "double") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "double"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "signed") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "signed"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "unsigned") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "unsigned"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "_Bool") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Bool"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "_Complex") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Complex"); Tuple(Some(CType1(t)), tokens) )
   else if std-c-can-take(tokens, "_Imaginary") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Imaginary"); Tuple(Some(CType1(t)), tokens) )
   else if let Tuple{first:Some{ats=content},tokens2=second} = std-c-parse-atomic-type-specifier(tokens) then Tuple(Some(ats), tokens2)
   else if std-c-can-take(tokens, "struct") or std-c-can-take(tokens, "union") then std-c-parse-struct-or-union-specifier(tokens)
   else if std-c-can-take(tokens, "enum") then std-c-parse-enumerator-specifier(tokens)
   else std-c-parse-typedef-name(tokens)
);

let std-c-parse-pointer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "*") then {
      tokens = std-c-take-expect(tokens, "*");
      let type-qualifier-list = std-c-parse-type-qualifier-list(tokens); tokens = type-qualifier-list.second;
      let next-pointer = std-c-parse-pointer(tokens); tokens = next-pointer.second;
      Tuple( Some(CPointer( close-owned(type-qualifier-list.first), close-owned(next-pointer.first) )), tokens )
   } else Tuple(no, tokens)   
);

let std-c-parse-abstract-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let p = std-c-parse-pointer(tokens); tokens = p.second;
   let dac = std-c-parse-direct-abstract-declarator(tokens); tokens = dac.second;
   if p.first.is-some and dac.first.is-some
   then Tuple( Some(CBinaryOp("AbstractDeclarator",close-owned(p.first.get-or-panic),close-owned(dac.first.get-or-panic))), tokens )
   else if dac.first.is-some
   then Tuple( dac.first, tokens )
   else Tuple( no, tokens )
);

let std-c-parse-direct-abstract-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#direct-abstract-declarator = '(', abstract-declarator, ')'
#                           | '(', parameter-type-list, ')'
#                           | '(', ')'
#                           | '[', ['*'], ']'
#                           | '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '[', ['*'], ']'
#                           | direct-abstract-declarator, '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | direct-abstract-declarator, '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | direct-abstract-declarator, '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '(', parameter-type-list, ')'
#                           | direct-abstract-declarator, '(', ')';
   let no = (None : Maybe<CTerm>)();
   let original-tokens = tokens;
   if std-c-can-take(tokens, "(") then {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "(");
      let ad = std-c-parse-abstract-declarator(tokens);
      # '(', parameter-type-list, ')'
      if ad.first.is-none {
         ad.first = Some(CUnaryPrefix("AbstractDeclarator",close-owned(CZOp(op))));
      };
      ad.second = std-c-take-expect(tokens, ")");
      ad
   } else if std-c-can-take(tokens, "[") then {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "[");
      if std-c-can-take(tokens, "*") {
         let p = head(tokens).skey; tokens = std-c-take-expect(tokens, "*");
         tokens = std-c-take-expect(tokens, "]");
         Tuple( Some(CBinaryOp("AbstractDeclarator",close-owned(CZOp(op)),close-owned(CType1(p)))), tokens )
      } else if std-c-can-take(tokens, "]") {
         tokens = std-c-take-expect(tokens, "]");
         Tuple( Some(CUnaryPrefix("AbstractDeclarator",close-owned(CZOp(op)))), tokens )
      } else if std-c-can-take(tokens, "static") {
         Tuple( no, tokens )
      } else {
         Tuple( no, tokens )
      }
   } else Tuple( no, tokens )   
);

let std-c-parse-type-qualifier-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = (None : Maybe<List<CTerm>>)();
   let tq = std-c-parse-type-qualifier(tokens);
   if tq.first.is-some {
      tokens = tq.second;
      let tqs = [tq.first.get-or-panic];
      while tq.first.is-some {
         tq = std-c-parse-type-qualifier(tokens); tokens = tq.second;
         if tq.first.is-some { tqs = cons(tq.first.get-or-panic, tqs); };
      };
      Tuple( Some(tqs.reverse), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-parameter-type-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let ptl = std-c-parse-parameter-list(tokens);
   if ptl.first.is-some {
      tokens = ptl.second;
      if std-c-can-take(tokens, ",") and std-c-can-take(tail(tokens),"...") {
         tokens = std-c-take-expect(tokens, ",");
         tokens = std-c-take-expect(tokens, "...");
         Tuple( Some(CUnaryPrefix( "ParameterTypeList...", close-owned(ptl.first.get-or-panic) )), tokens )
      } else ptl
   } else Tuple( no, tokens )
);

let std-c-parse-struct-declarator-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let sq = std-c-parse-struct-declarator(tokens);
   if sq.first.is-some {
      let sql = [sq.first.get-or-panic];
      tokens = sq.second;
      while sq.first.is-some and std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         sq = std-c-parse-struct-declarator(tokens);
         if sq.first.is-some {
            sql = cons( sq.first.get-or-panic, sql );
            tokens = sq.second;
         };
      };
      Tuple( Some(CList(close-owned(sql.reverse))), tokens )
   } else Tuple ( no, tokens )
);

let std-c-parse-struct-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, ":") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, ":");
      let ce = std-c-parse-constant-expression(tokens);
      if ce.first.is-some
      then Tuple( Some(CUnaryPrefix("StructDeclarator:", close-owned(ce.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   } else {
      let decl = std-c-parse-declarator(tokens); tokens = decl.second;
      let ce = if std-c-can-take(tokens,":") {
         tokens = std-c-take-expect(tokens, ":");
         let ce-next = std-c-parse-constant-expression(tokens); tokens = ce-next.second;
         ce-next.first;
      } else no;
      if decl.first.is-some and ce.is-some
      then Tuple( Some(CBinaryOp("StructDeclarator:", close-owned(decl.first.get-or-panic), close-owned(ce.get-or-panic))), tokens )
      else if decl.first.is-some
      then Tuple( Some(CUnaryPrefix("StructDeclarator", close-owned(decl.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   }
);

let std-c-parse-assignment-operator(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = (None : Maybe<String>)();
   if not(non-zero(tokens)) then Tuple( no, tokens )
   else if head(tokens).skey == "=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "*=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "/=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "%=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "+=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "-=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "<<=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == ">>=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "&=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "^=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "|=" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else Tuple( no, tokens )
);

let std-c-parse-struct-or-union(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = (None : Maybe<String>)();
   if not(non-zero(tokens)) then Tuple( no, tokens )
   else if head(tokens).skey == "struct" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else if head(tokens).skey == "union" then Tuple( Some(head(tokens).skey), tail(tokens) )
   else Tuple( no, tokens )
);

let std-c-parse-identifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "identifier") then Tuple( Some(CIdentifier(head(tokens).skey)), tail(tokens) )
   else Tuple( no, tokens )
);

let std-c-parse-constant(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "integer") then Tuple( Some(CInteger(head(tokens).skey)), tail(tokens) )
   else if std-c-can-take(tokens, "character") then Tuple( Some(CCharacter(head(tokens).skey)), tail(tokens) )
   else if std-c-can-take(tokens, "floating") then Tuple( Some(CFloating(head(tokens).skey)), tail(tokens) )
   else if std-c-can-take(tokens, "enumeration") then Tuple( Some(CEnumeration(head(tokens).skey)), tail(tokens) )
   else Tuple( no, tokens )
);

let std-c-parse-string(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "string") then Tuple( Some(CString(head(tokens).skey)), tail(tokens) )
   else if std-c-can-take(tokens, "__func__") then Tuple( Some(CString(head(tokens).skey)), tail(tokens) )
   else Tuple( no, tokens )
);

let std-c-parse-primary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let original-tokens = tokens;
   let ts = std-c-parse-generic-selection(tokens);
   if ts.first.is-none then (ts = std-c-parse-constant(tokens));
   if ts.first.is-none then (ts = std-c-parse-identifier(tokens));
   if ts.first.is-none then (ts = std-c-parse-string(tokens));
   if ts.first.is-none and std-c-can-take(tokens, "(") {
      let tokens2 = std-c-take-expect(tokens, "(");
      ts = std-c-parse-expression(tokens2);
      if ts.first.is-some {
         ts.second = std-c-take-expect(ts.second, ")");
         ts;
      } else Tuple( no, original-tokens );
   };
   ts
);

let std-c-parse-parameter-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let ptl = std-c-parse-parameter-declaration(tokens);
   if ptl.first.is-some {
      let pts = [ptl.first.get-or-panic];
      tokens = ptl.second;
      while std-c-can-take(tokens, ",") and not(std-c-can-take(tail(tokens),"...")) {
         tokens = std-c-take-expect(tokens, ",");
         ptl = std-c-parse-parameter-declaration(tokens); tokens = ptl.second;
         if ptl.first.is-some { pts = cons( ptl.first.get-or-panic, pts ); };
      };
      Tuple( Some(CList(close-owned(pts.reverse))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-parameter-declaration(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let ds = std-c-parse-declaration-specifiers(tokens);
   if ds.first.is-some {
      tokens = ds.second;
      let declarator = std-c-parse-declarator(tokens);
      if declarator.first.is-none { declarator = std-c-parse-abstract-declarator(tokens); };
      tokens = declarator.second;
      if declarator.first.is-some {
         Tuple( Some(CBinaryOp("ParameterDeclaration", close-owned(ds.first.get-or-panic), close-owned(declarator.first.get-or-panic) )), tokens )
      } else Tuple( Some(CUnaryPrefix("ParameterDeclaration", close-owned(ds.first.get-or-panic) )), tokens );
   } else Tuple( no, tokens )
);

let std-c-parse-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-assignment-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, ",")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-assignment-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-assignment-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let ue = std-c-parse-unary-expression(tokens);
   if ue.first.is-some and (
      std-c-can-take(ue.second, "=")
   or std-c-can-take(ue.second, "*=")
   or std-c-can-take(ue.second, "/=")
   or std-c-can-take(ue.second, "%=")
   or std-c-can-take(ue.second, "+=")
   or std-c-can-take(ue.second, "-=")
   or std-c-can-take(ue.second, "<<=")
   or std-c-can-take(ue.second, ">>=")
   or std-c-can-take(ue.second, "&=")
   or std-c-can-take(ue.second, "^=")
   or std-c-can-take(ue.second, "|=")) {
      let op = head(ue.second).skey;
      let rest = std-c-parse-assignment-expression(tail(ue.second));
      if rest.first.is-some {
         Tuple( Some(CBinaryOp(op, close-owned(ue.first.get-or-panic), close-owned(rest.first.get-or-panic))), rest.second )
      } else std-c-parse-conditional-expression(tokens);
   } else std-c-parse-conditional-expression(tokens);
);

let std-c-parse-constant-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   std-c-parse-conditional-expression(tokens)
);

let std-c-parse-conditional-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let base = std-c-parse-logical-or-expression(tokens); tokens = base.second;
   if base.first.is-some and std-c-can-take(tokens, "?") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "?");
      (let e1, tokens) = std-c-parse-expression(tokens);
      tokens = std-c-take-expect(tokens, ":");
      (let e2, tokens) = std-c-parse-conditional-expression(tokens);
      base = Tuple( Some(CTernaryOp(op, close-owned(base.first.get-or-panic), close-owned(e1.get-or-panic), close-owned(e2.get-or-panic))), tokens );
   };
   base
);

let std-c-parse-logical-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-logical-and-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "or")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-logical-and-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-logical-and-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-inclusive-or-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "&&")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-inclusive-or-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-inclusive-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-exclusive-or-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "|")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-exclusive-or-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-exclusive-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-and-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "^")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-and-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-and-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-equality-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "&")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-equality-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-equality-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-relational-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "==")  or std-c-can-take(tokens, "!=")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-relational-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-relational-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-shift-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "<")  or std-c-can-take(tokens, ">") or
      std-c-can-take(tokens, "<=") or std-c-can-take(tokens, ">=")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-shift-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-shift-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-additive-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "<<") or std-c-can-take(tokens, ">>")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-additive-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-additive-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-multiplicative-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "+") or std-c-can-take(tokens, "-")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-multiplicative-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);

let std-c-parse-multiplicative-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-cast-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "*") or std-c-can-take(tokens, "/") or std-c-can-take(tokens, "%")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-cast-expression(tokens); tokens = re.second;
      let e = CBinaryOp( op, close-owned(expression.first.get-or-panic), close-owned(re.first.get-or-panic) );
      expression = Tuple( Some(e), tokens );
   };
   expression
);


let std-c-parse-cast-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   if std-c-can-take(tokens, "(") {
      let scan-tokens = std-c-take-expect(tokens, "(");
      (let tt, scan-tokens) = std-c-parse-type-name(scan-tokens);
      scan-tokens = std-c-take-expect(scan-tokens, ")");
      (let ca, scan-tokens) = std-c-parse-cast-expression(scan-tokens);
      if tt.is-some and ca.is-some
      then Tuple( Some(CBinaryOp("cast", close-owned(tt.get-or-panic), close-owned(ca.get-or-panic))), scan-tokens )
      else std-c-parse-unary-expression(tokens);
   } else std-c-parse-unary-expression(tokens);
);


let std-c-parse-unary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   if std-c-can-take(tokens, "++") or std-c-can-take(tokens, "--") or std-c-can-take(tokens,"+") or std-c-can-take(tokens,"-")
   or std-c-can-take(tokens, "&") or std-c-can-take(tokens, "*") or std-c-can-take(tokens,"!") or std-c-can-take(tokens, "~") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let inner = std-c-parse-cast-expression(tokens);
      if inner.first.is-some then Tuple( Some(CUnaryPrefix(op, close-owned(inner.first.get-or-panic))), inner.second )
      else inner;
   } else if std-c-can-take(tokens, "sizeof") {
      let op = head(tokens).skey; tokens = tail(tokens);
      if std-c-can-take(tokens, "(") {
         tokens = std-c-take-expect(tokens, "(");
         (let tt, tokens) = std-c-parse-type-name(tokens);
         tokens = std-c-take-expect(tokens, ")");
         if tt.is-some then Tuple( Some(CUnaryPrefix(op, close-owned(tt.get-or-panic))), tokens )
         else Tuple( tt, tokens );
      } else {
         let inner = std-c-parse-unary-expression(tokens);
         if inner.first.is-some then Tuple( Some(CUnaryPrefix(op, close-owned(inner.first.get-or-panic))), inner.second )
         else inner;
      };
   } else if std-c-can-take(tokens, "alignof") or std-c-can-take(tokens, "_Alignof") {
      tokens = tail(tokens);
      if std-c-can-take(tokens, "(") {
         tokens = std-c-take-expect(tokens, "(");
         (let tt, tokens) = std-c-parse-type-name(tokens);
         tokens = std-c-take-expect(tokens, ")");
         if tt.is-some then Tuple( Some(CUnaryPrefix("alignof", close-owned(tt.get-or-panic))), tokens )
         else Tuple( tt, tokens );
      } else {
         let inner = std-c-parse-unary-expression(tokens);
         if inner.first.is-some then Tuple( Some(CUnaryPrefix("alignof", close-owned(inner.first.get-or-panic))), inner.second )
         else inner;
      };
   } else std-c-parse-postfix-expression(tokens)
);


let std-c-parse-postfix-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-primary-expression(tokens); tokens = expression.second;
   while expression.first.is-some and (
      std-c-can-take(tokens, "[") or std-c-can-take(tokens, "(") or
      std-c-can-take(tokens, ".") or std-c-can-take(tokens, "->") or
      std-c-can-take(tokens, "++") or std-c-can-take(tokens, "--")
   ) {
      if std-c-can-take(tokens, "++") or std-c-can-take(tokens, "--") {
         let e = CUnaryPostfix( head(tokens).skey, close-owned(expression.first.get-or-panic) );
         tokens = tail(tokens);
         expression = Tuple( Some(e), tokens );
      } else if std-c-can-take(tokens, ".") or std-c-can-take(tokens, "->") {
         let accessor = head(tokens).skey; tokens = tail(tokens);
         if non-zero(tokens) {
            let e = CAccessor( accessor, head(tokens).skey, close-owned(expression.first.get-or-panic) );
            tokens = std-c-take-expect(tokens, "identifier");
            expression = Tuple( Some(e), tokens );
         } else std-c-take-expect(tokens, "identifier");
      } else if std-c-can-take(tokens,"[") {
         let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "[");
         (let inner, tokens) = std-c-parse-expression(tokens);
         tokens = std-c-take-expect(tokens, "]");
         if inner.is-some {
            expression = Tuple( Some(CBinaryOp("[]", close-owned(expression.first.get-or-panic), close-owned(inner.get-or-panic))), tokens );
         };
      } else {
         let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "(");
         (let inner, tokens) = std-c-parse-argument-expression-list(tokens);
         tokens = std-c-take-expect(tokens, ")");
         if inner.is-some {
            expression = Tuple( Some(CBinaryOp(op, close-owned(expression.first.get-or-panic), close-owned(inner.get-or-panic))), tokens );
         };
      };
   };
#postfix-expression = primary-expression
#                   | '(', type-name, ')', '{', initializer-list, [','], '}';
   expression
);

let std-c-parse-argument-expression-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let sq = std-c-parse-assignment-expression(tokens);
   if sq.first.is-some {
      let sql = [sq.first.get-or-panic];
      tokens = sq.second;
      while std-c-can-take(tokens,",") {
         tokens = std-c-take-expect(tokens,",");
         sq = std-c-parse-assignment-expression(tokens);
         if sq.first.is-some {
            sql = cons( sq.first.get-or-panic, sql );
            tokens = sq.second;
         };
      };
      Tuple( Some(CList(close-owned(sql.reverse))), tokens )
   } else Tuple ( no, tokens )
);

let std-c-parse-generic-selection(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "_Generic") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Generic");
      tokens = std-c-take-expect(tokens, "(");
      let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
      tokens = std-c-take-expect(tokens, ",");
      let ga = std-c-parse-generic-assoc-list(tokens); tokens = ga.second;
      tokens = std-c-take-expect(tokens, ")");
      if ae.first.is-some and ga.first.is-some
      then Tuple( Some(CBinaryOp(op, close-owned(ae.first.get-or-panic), close-owned(ga.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-generic-assoc-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   let ga = std-c-parse-generic-association(tokens);
   if ga.first.is-some then {
      tokens = ga.second;
      let gas = [ga.first.get-or-panic];
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         ga = std-c-parse-generic-association(tokens); tokens = ga.second;
         if ga.first.is-some then { gas = cons( ga.first.get-or-panic, gas ); };
      };
      Tuple( Some(CList(close-owned(gas.reverse))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-generic-association(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "default") {
      tokens = std-c-take-expect(tokens, "default");
      tokens = std-c-take-expect(tokens, ":");
      let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
      if ae.first.is-some
      then Tuple( Some(CUnaryPrefix("GenericAssociation", close-owned(ae.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   } else {
      let tn = std-c-parse-type-name(tokens); tokens = tn.second;
      tokens = std-c-take-expect(tokens, ":");
      let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
      if tn.first.is-some and ae.first.is-some
      then Tuple( Some(CBinaryOp("GenericAssociation", close-owned(tn.first.get-or-panic), close-owned(ae.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   }
);

let std-c-parse-designator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "[") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "[");
      let ce = std-c-parse-constant-expression(tokens); tokens = ce.second;
      tokens = std-c-take-expect(tokens, "]");
      if ce.first.is-some
      then Tuple( Some(CUnaryPrefix(op,close-owned(ce.first.get-or-panic))), tokens )
      else Tuple( no, tokens )
   } else if std-c-can-take(tokens,".") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, ".");
      let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      Tuple( Some(CUnaryPrefix(op,close-owned(CIdentifier(id)))), tokens )
   } else Tuple( no, tokens )
);

let std-c-parse-designator-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = (None : Maybe<List<CTerm>>)();
   let des = std-c-parse-designator(tokens); tokens = des.second;
   if des.first.is-some {
      let dess = [des.first.get-or-panic];
      while des.first.is-some {
         des = std-c-parse-designator(tokens); tokens = des.second;
         if des.first.is-some { dess = cons(des.first.get-or-panic, dess); };
      };
      Tuple( Some(dess.reverse), tokens )
   } else Tuple( no, tokens );
);

let std-c-parse-designation(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = (None : Maybe<List<CTerm>>)();
   let dl = std-c-parse-designator-list(tokens); tokens = dl.second;
   if dl.first.is-some { tokens = std-c-take-expect(tokens, "="); };
   if dl.first.is-some then Tuple( Some(dl.first.get-or-panic), tokens )
   else Tuple( no, tokens )
);

let std-c-parse-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let attr = std-c-parse-attribute(tokens); tokens = attr.second;
   let e = std-c-parse-jump-statement(tokens);
   if e.first.is-none { e = std-c-parse-compound-statement(tokens); };
   if e.first.is-none { e = std-c-parse-iteration-statement(tokens); };
   if e.first.is-none { e = std-c-parse-selection-statement(tokens); };
   if e.first.is-none { e = std-c-parse-labeled-statement(tokens); };
   if e.first.is-none { e = std-c-parse-expression-statement(tokens); };
   if e.first.is-none and std-c-can-take(tokens,";") {
      tokens = std-c-take-expect(tokens,";");
      e = Tuple( Some(CZOp(";")), tokens );
   };
   e;
);

let std-c-parse-expression-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let e = std-c-parse-expression(tokens);
   if e.first.is-some { e.second = std-c-take-expect(e.second, ";"); };
   e;
);

let std-c-parse-labeled-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "identifier") and std-c-can-take(tail(tokens), ":") {
      let lname = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      let op = "c::label"; tokens = std-c-take-expect(tokens, ":");
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if stmt.first.is-some
      then Tuple( Some(CBinaryOp(op,close-owned(CIdentifier(lname)),close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else if std-c-can-take(tokens, "case") {
      let op = "c::case"; tokens = tail(tokens);
      let expr = std-c-parse-constant-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ":");
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some and stmt.first.is-some
      then Tuple( Some(CBinaryOp(op,close-owned(expr.first.get-or-panic),close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else if std-c-can-take(tokens, "default") {
      let op = "c::default"; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ":");
      let attr = std-c-parse-attribute(tokens); tokens = attr.second;
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if stmt.first.is-some
      then Tuple( Some(CUnaryPrefix(op,close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else Tuple( no, tokens );
);

let std-c-parse-selection-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "if") {
      let op = "c::if"; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt0 = std-c-parse-statement(tokens); tokens = stmt0.second;
      let stmt1 = if std-c-can-take(tokens, "else") {
         tokens = std-c-take-expect(tokens, "else");
         std-c-parse-statement(tokens);
      } else Tuple( Some(CZOp(";")), tokens ); tokens = stmt1.second;
      if expr.first.is-some and stmt0.first.is-some and stmt1.first.is-some
      then Tuple( Some(CTernaryOp(op,close-owned(expr.first.get-or-panic),close-owned(stmt0.first.get-or-panic),close-owned(stmt1.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else if std-c-can-take(tokens, "switch") {
      let op = "c::switch"; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some and stmt.first.is-some
      then Tuple( Some(CBinaryOp(op,close-owned(expr.first.get-or-panic),close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else Tuple( no, tokens );
);

let std-c-parse-iteration-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "while") {
      let op = "c::while"; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some and stmt.first.is-some
      then Tuple( Some(CBinaryOp(op,close-owned(expr.first.get-or-panic),close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else if std-c-can-take(tokens, "do") {
      let op = "c::do-while"; tokens = tail(tokens);
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      tokens = std-c-take-expect(tokens, "while");
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      tokens = std-c-take-expect(tokens, ";");
      if expr.first.is-some and stmt.first.is-some
      then Tuple( Some(CBinaryOp(op,close-owned(stmt.first.get-or-panic),close-owned(expr.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else if std-c-can-take(tokens, "for") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let decl = std-c-parse-declaration(tokens); if decl.first.is-some then tokens = decl.second;
      let expr1 = std-c-parse-expression(tokens); tokens = expr1.second;
      tokens = std-c-take-expect(tokens, ";");
      let expr2 = std-c-parse-expression(tokens); tokens = expr2.second;
      let expr3 = if std-c-can-take(tokens, ";") {
         tokens = std-c-take-expect(tokens, ";");
         std-c-parse-expression(tokens);
      } else Tuple( no, tokens ); tokens = expr3.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if decl.first.is-some and stmt.first.is-some
      then Tuple( Some(CFor(op,close-owned(decl.first),close-owned(expr1.first),close-owned(expr2.first),close-owned(stmt.first.get-or-panic))), tokens )
      else if stmt.first.is-some
      then Tuple( Some(CFor(op,close-owned(expr1.first),close-owned(expr2.first),close-owned(expr3.first),close-owned(stmt.first.get-or-panic))), tokens )
      else Tuple( no, tokens );
   } else Tuple( no, tokens );
);

let std-c-parse-jump-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = (None : Maybe<CTerm>)();
   if std-c-can-take(tokens, "goto") {
      let op = intern(c"c::goto"); tokens = tail(tokens);
      let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      tokens = std-c-take-expect(tokens, ";");
      Tuple( Some(CUnaryPrefix(op,close-owned(CIdentifier(id)))), tokens )
   } else if std-c-can-take(tokens, "continue") {
      let op = intern(c"continue"); tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ";");
      Tuple( Some(CZOp(op)), tokens )
   } else if std-c-can-take(tokens, "break") {
      let op = "break"; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ";");
      Tuple( Some(CZOp(op)), tokens )
   } else if std-c-can-take(tokens, "return") {
      let op = intern(c"return"); tokens = tail(tokens);
      let e = std-c-parse-expression(tokens); tokens = e.second;
      tokens = std-c-take-expect(tokens, ";");
      if e.first.is-some
      then Tuple( Some(CUnaryPrefix("c::"+op,close-owned(e.first.get-or-panic))), tokens )
      else Tuple( Some(CZOp(op)), tokens )
   } else Tuple( no, tokens );
);

