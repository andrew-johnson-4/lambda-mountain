
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-unwrap-identifier(ident: Token): Token = (
   match ident {
      Token { skey=skey, key=key, nonce=nonce, location=location } => Token { skey, lsts-unwrap-identifier(key), iuid(), location };
   };
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }; ();
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }; ();
);

let lsts-parse-identifier(tokens: List<Token>): Tuple<CString, List<Token>> = (
   let name = c"";
   if lsts-parse-head(tokens)==c"." { name = c"."; tokens = tail(tokens); };
   lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
   name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   while lsts-parse-head(tokens)==c":" && lsts-parse-head(tail(tokens))==c":" {
      name = name + c"::"; tokens = tail(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   };
   (name, tokens);
);

let lsts-parse-doc-wordf(tokens: List<Token>, begin: CString, end: CString): Tuple<CString, List<Token>> = (
   lsts-parse-expect(begin, tokens); tokens = tail(tokens);
   let text = mk-vector(type(U8), 16);
   while lsts-parse-head(tokens) != end {
      if lsts-parse-head(tokens) == c"\n" {
         lsts-parse-expect(end, 0, tokens);
      };
      if text.length > 0 {
         text = text.push(32_u8);
      };
      let h = lsts-parse-head(tokens);
      while non-zero(h) {
         text = text.push(head-string(h));
         h = tail-string(h);
      };
      tokens = tail(tokens);
   };
   Tuple { text.into(type(CString)), tokens }
);

let lsts-parse-doc-expr(tokens: List<Token>): Tuple<AST, List<(CString, AST)>, List<Token>> = (
   let tags = [] :: List<(CString, AST)>;
   let val = match lsts-parse-head(tokens) {
      c"__" => (
         (let s, tokens) = lsts-parse-doc-wordf(tokens, c"__", c"__");
         mk-app( mk-var("meta::style::underline"), mk-lit(s) )
      );

      c"**" => (
         (let s, tokens) = lsts-parse-doc-wordf(tokens, c"**", c"**");
         mk-app( mk-var("meta::style::bold"), mk-lit(s) )
      );

      c"[" => (
         tokens = tail(tokens);
         let v = if lsts-parse-head(tokens) == c"[" {
            tokens = tail(tokens);
            let key = lsts-parse-head(tokens); tokens = tail(tokens);
            let val = ASTNil;
            if lsts-parse-head(tokens) == c":" {
               tokens = tail(tokens);
               (val, tokens) = lsts-parse-expression(tokens);
            };
            lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
            tags = cons( (key,val), tags );
            ASTNil;
         } else {
            (let v, tokens) = lsts-parse-expression(tokens);
            v
         };
         lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
         v
      );

      word => (
         tokens = tail(tokens);
         mk-lit(word);
      );
   };
   Tuple { val, tags.reverse, tokens }
);

let lsts-parse-doc(tokens: List<Token>): Tuple<AST, List<Token>> = (
   let ast = ASTEOF;
   let para = ASTEOF;

   let tags = [] :: List<(CString, AST)>;

   while lsts-parse-head(tokens) == c"##" {
      tokens = tail(tokens);

      let line = ASTEOF;
      # special token inserted by the lexer only in doc strings
      while lsts-parse-head(tokens) != c"\n" {
         (let ax, let new-tags, tokens) = lsts-parse-doc-expr(tokens);
         tags = tags + new-tags;
         if non-zero(ax) {
            if non-zero(line) {
               line = mk-seq(line, ax);
            } else {
               line = ax;
            };
         };
      };
      tokens = tail(tokens);

      if non-zero(line) {
         if non-zero(para) {
            para = mk-seq(para, line);
         } else {
            para = line;
         };
      } else {
         # empty line => new paragraph
         if non-zero(para) {
            if non-zero(ast) {
               ast = mk-seq(ast, para);
            } else {
               ast = para;
            };
            para = ASTEOF;
         };
      };
   };

   for Tuple{key=first, val=second} in tags {
      ast = mk-app( mk-var("Meta::with-tag"), mk-cons( mk-lit(key), val ) );
   };

   Tuple { ast, tokens }
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] :: List<Token>;} else {tokens = rest;});
      [Token{key:c"if"} .. rest] => (if depth == 0_i64 {tokens = [] :: List<Token>;} else {tokens = rest;});
      [Token{key:c"then"} .. rest] => (if depth == 0_i64 {tokens = [] :: List<Token>;} else {tokens = rest;});
      [Token{key:c"else"} .. rest] => (if depth == 0_i64 {tokens = [] :: List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] :: List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s.has-suffix(c"_ss") then untern(intern(s)[:-3_i64]) else
   if s == c"String" then c"SmartString" else
   if s == c"CString" then c"String" else
   s.remove-suffix(c"_u64")
    .remove-suffix(c"_u32")
    .remove-suffix(c"_u16")
    .remove-suffix(c"_u8")
    .remove-suffix(c"_i64")
    .remove-suffix(c"_i32")
    .remove-suffix(c"_i16")
    .remove-suffix(c"_i8")
);

let lsts-is-type-tag(s: CString): U64 = (
      s.has-suffix(c"_ss")
   || s.has-suffix(c"_u64")
   || s.has-suffix(c"_u32")
   || s.has-suffix(c"_u16")
   || s.has-suffix(c"_u8")
   || s.has-suffix(c"_i64")
   || s.has-suffix(c"_i32")
   || s.has-suffix(c"_i16")
   || s.has-suffix(c"_i8")
   || lsts-is-lit-head(s) 
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      (let docx, tokens) = lsts-parse-doc(tokens);
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"type"}.. _] => tokens = lsts-parse-typedef(tokens);
         [ Token{key:c"typed"}.. Token{key:c"macro"}.. _] => (
            (let bind, tokens) = lsts-parse-typed-macro(tokens);
            ast-parsed-program = mk-seq(ast-parsed-program, bind);
         );
         [ Token{key:c"interface"}.. _] => tokens = lsts-parse-interface(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         [ Token{key:c"zero"}.. rest] => (
            let loc = head(tokens).location;
            tokens = rest;
            let base-type-rest = lsts-parse-type(tokens); tokens = base-type-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            if not(non-zero(tokens)) || not(lsts-is-lit-head(lsts-parse-head(tokens))) { 
               lsts-parse-expect(c"[Type Constructor]", tokens);
            };
            let constructor = head(tokens); tokens = tail(tokens);
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            ast-parsed-program = mk-seq(ast-parsed-program, mk-app(
               Var{ c"macro::define-zero", with-key(constructor, c"macro::define-zero") },
               mk-cons(
                  AType{ base-type-rest.first },
                  Lit{ constructor.key, constructor }
               )
            ));
         );
         [ Token{key:c"atom"}.. Token{key:c"suffix"}.. rest] => (
            tokens = rest;
            let base-rest = lsts-parse-type(tokens); tokens = base-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            if not(non-zero(tokens)) || not(lsts-is-ident-head(lsts-parse-head(tokens))) { 
               lsts-parse-expect(c"[Suffix]", tokens);
            };
            let suffix = head(tokens).key; tokens = tail(tokens);
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            parse-suffixes = cons(
               Tuple{ suffix, base-rest.first && t1(c"Constant") && t1(c"Literal") },
               parse-suffixes
            );
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = mk-seq(ast-parsed-program, term);
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
      if non-zero(docx) { 
         ast-parsed-program = mk-seq(ast-parsed-program, mk-meta(docx));
      };
   };
);

let lsts-parse-top-level(tokens: List<Token>): Tuple<AST,List<Token>> = (
   # TODO, accept all top-level expressions here
   lsts-parse-small-expression(tokens);
);

let lsts-parse-typed-macro(tokens: List<Token>): (AST, List<Token>) = (
   lsts-parse-expect(c"typed", tokens); tokens = tail(tokens);
   lsts-parse-expect(c"macro", tokens); tokens = tail(tokens);
   (let mname, tokens) = lsts-parse-identifier(tokens);
   let margs = ASTNil;
   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   while lsts-parse-head(tokens)!=c")" {
      if not(is(margs,ASTNil)) then { lsts-parse-expect(c",", tokens); tokens = tail(tokens); };
      (let mbind, tokens) = lsts-parse-atom-without-tail(tokens);
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      (let mbindt, tokens) = lsts-parse-type(tokens);
      let marg = mk-app(mk-lit(c":"), mk-cons(mbind, mk-atype(mbindt)));
      if is(margs,ASTNil) then margs = marg
                          else margs = mk-cons(margs, marg);
   };
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);
   lsts-parse-expect(c":", tokens); tokens = tail(tokens);
   (let mrett, tokens) = lsts-parse-type(tokens);
   lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   (let mbody, tokens) = lsts-parse-top-level(tokens);
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   (mk-glb(
      mk-token(mname),
      mk-abs(margs, mk-app(mk-lit(c":"), mk-cons(mbody,mk-atype(mrett))), t1(c"TypedMacro"))
   ), tokens)
);

let lsts-parse-type(tokens: List<Token>): Tuple<Type,List<Token>> = (
   (let base-type, tokens) = lsts-parse-type-conjugate(tokens);
   while lsts-parse-head(tokens)==c"-" && lsts-parse-head(tail(tokens))==c">" {
      lsts-parse-expect(c"-", tokens); tokens = tail(tokens);
      lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      (let tail-type, tokens) = lsts-parse-type-conjugate(tokens);
      base-type = t3(c"Arrow", base-type, tail-type);
   };
   (base-type, tokens)
);

let lsts-parse-type-conjugate(tokens: List<Token>): Tuple<Type,List<Token>> = (
   let tt = if lsts-parse-head(tokens) == c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let args-rest = lsts-parse-type(tokens);
      let args = [ args-rest.first ];
      tokens = args-rest.second;
      while lsts-parse-head(tokens) == c"," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         let tnext-rest = lsts-parse-type(tokens);
         args = cons( tnext-rest.first, args );
         tokens = tnext-rest.second;
      };
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      if args.length==1 then head(args) else TGround { c"Tuple", close(args) };
   } else if lsts-parse-head(tokens)==c"?" {
      lsts-parse-expect(c"?", tokens); tokens = tail(tokens);
      TAny {}
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) && not(lsts-is-type-tag(lsts-parse-head(tokens))) {
      let varname = lsts-parse-head(tokens); tokens = tail(tokens);
      TVar { varname }
   } else {
      if not(lsts-is-type-tag(lsts-parse-head(tokens))) {
         lsts-parse-expect(c"[Type Tag]", tokens);
      };
      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens)); tokens = tail(tokens);
      while non-zero(tokens) && lsts-parse-head(tokens)==c":" {
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"Type", non-zero(tokens), tokens);
         if not(lsts-is-type-tag(lsts-parse-head(tokens))) && not(lsts-is-ident-head(lsts-parse-head(tokens))) {
            lsts-parse-expect(c"[Type Tag or Variable]", tokens);
         };
         base = base + c"::" + lsts-substitute-type-aliases(lsts-parse-head(tokens));
         tokens = tail(tokens);
      };
      let args = [] :: List<Type>;
      if lsts-parse-head(tokens) == c"<" {
         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
         let targs-rest = lsts-parse-type(tokens);
         args = cons( targs-rest.first, args );
         tokens = targs-rest.second;
         while lsts-parse-head(tokens) == c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            let tnext-rest = lsts-parse-type(tokens);
            args = cons( tnext-rest.first, args );
            tokens = tnext-rest.second;
         };
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      };
      TGround { base, close(args) };
   };
   while lsts-parse-head(tokens) == c"[" || lsts-parse-head(tokens)==c"?" {
      if lsts-parse-head(tokens)==c"[" {
         lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
         let index = if lsts-parse-head(tokens) != c"]" {
            let tindex-rest = lsts-parse-type(tokens);
            tokens = tindex-rest.second;
            tindex-rest.first;
         } else { TAny {} };
         lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
         tt = t3(c"Array", tt, index);
      } else {
         lsts-parse-expect(c"?", tokens); tokens = tail(tokens);
         tt = t2(c"Maybe", tt);
      }
   };
   if lsts-parse-head(tokens)==c"+" {
      tokens = tail(tokens);
      let ntt-rest = lsts-parse-type-conjugate(tokens);
      tt = ntt-rest.first && tt;
      tokens = ntt-rest.second;
   };
   Tuple { tt, tokens };
);

let lsts-parse-expression-possibly-tuple(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if not(non-zero(tokens)) { lsts-parse-expect(c"ExpressionPossiblyTuple", tokens); };
   let loc = head(tokens).location;
   let base-rest = lsts-parse-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   let is-tuple = 0;
   while lsts-parse-head(tokens) == c"," {
      is-tuple = 1;
      tokens = tail(tokens);
      base-rest = lsts-parse-expression(tokens);
      base = mk-cons(base, base-rest.first);
      tokens = base-rest.second;
   };
   if is-tuple {
      base = mk-app(
         Lit{ c"Tuple", with-location(mk-token("Tuple"),loc) },
         base
      );
   };
   Tuple { base, tokens }
);

let lsts-parse-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-small-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   while lsts-parse-head(tokens) == c";" {
      tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c")" && lsts-parse-head(tokens)!=c"}" {
         base-rest = lsts-parse-small-expression(tokens);
         base = mk-cons(base, base-rest.first);
         tokens = base-rest.second;
      }
   };
   Tuple { base, tokens }
);

let lsts-parse-lhs-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF {};
   lsts-parse-expect(c"[", tokens);
   let loc = head(tokens).location;
   tokens = tail(tokens);
   if lsts-parse-head(tokens) == c"]" {
      base = Lit { c"LEOF", with-location(mk-token("LEOF"),loc) };
   } else {
      let base-rest = lsts-parse-lhs-one(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
      let bases = [base];
      while non-zero(tokens) && lsts-parse-head(tokens)==c"." {
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c"]" {
            bases = cons( Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) }, bases );
         } else {
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            bases = cons( next, bases );
         }
      };
      base = head(bases); bases = tail(bases);
      for b in bases {
         base = mk-app(
            Var{ c"macro::lhs-head", with-location(mk-token("macro::lhs-head"),loc) },
            mk-cons(b, base)
         );
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { base, tokens }
);

let lsts-parse-lhs(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = match tokens {
      [ Token{key:c"["}.. _ ] => (
         let base-rest = lsts-parse-lhs-list(tokens);
         tokens = base-rest.second;
         base-rest.first;
      );
      [ Token{key:c"("}.. _] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         let base-rest = lsts-parse-lhs-big(tokens);
         tokens = base-rest.second;
         lsts-parse-expect(c")", tokens); tokens = tail(tokens);
         base-rest.first;
      );
      _ => (
         let base-rest = lsts-parse-lhs-one(tokens);
         tokens = base-rest.second;
         base-rest.first;         
      );
   };
   while non-zero(tokens) && (lsts-parse-head(tokens)==c"." || lsts-parse-head(tokens)=="[") {
      match tokens {
         [Token{key:c"."}.. Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            base = mk-app(
               Var{ c"macro::lhs-prefix-or-suffix", with-location(mk-token("macro::lhs-prefix-or-suffix"),loc) },
               mk-cons(base, next)
            );
         );
         [Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            base = mk-app(
               Var{ c"macro::lhs-field", with-location(mk-token("macro::lhs-field"),loc) },
               mk-cons(base, next)
            );
         );
         [Token{key:c"["}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-expression(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
            base = mk-app(
               Var{ c"macro::lhs-index", with-location(mk-token("macro::lhs-index"),loc) },
               mk-cons(base, next)
            );
         );
      }
   };
   Tuple { base, tokens }
);

let lsts-make-maybe-var(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      lsts-parse-lit(tokens)
   } else {
      if not(non-zero(tokens)) { lsts-parse-expect(c"Identifier", tokens); };
      let t = head(tokens);
      let base = Var { lsts-unwrap-identifier(t.key), lsts-unwrap-identifier(t) };
      if lsts-is-lit(t.key) { base = lsts-make-lit(t); };
      tokens = tail(tokens);
      Tuple { base, tokens }
   }
);

let lsts-is-lit(s: CString): U64 = (
   let r = 0_u64;
   for Tuple { sfxs=first } in parse-suffixes {
      r = r || s.has-suffix(sfxs);
   }; r;
);

let lsts-parse-add(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-mul(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"+" || lsts-parse-head(tokens)==c"-" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-mul(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var{ op, op-t },
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple { term, tokens }
);

let lsts-parse-cmp(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-add(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"==" || lsts-parse-head(tokens)==c"!=" ||
         lsts-parse-head(tokens)==c"<" || lsts-parse-head(tokens)==c"<=" ||
         lsts-parse-head(tokens)==c">" || lsts-parse-head(tokens)==c">=" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      if (op==c"<" && lsts-parse-head(tokens)==c"<") ||
         (op==c">" && lsts-parse-head(tokens)==c">") {
         op = op + op; op-t = with-key(op-t, op); tokens = tail(tokens);
      };
      let term2-rest = lsts-parse-add(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var{ op, op-t },
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple { term, tokens }
);

let lsts-parse-andor(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-cmp(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"&&" || lsts-parse-head(tokens)==c"||" || lsts-parse-head(tokens)==c"^" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-cmp(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var{ op, op-t },
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple { term, tokens }
);

let lsts-parse-mul(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-atom(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"*" || lsts-parse-head(tokens)==c"/" || lsts-parse-head(tokens)==c"%" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-atom(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var{ op, op-t },
         mk-cons(term, term2-rest.first)
      );
   };
   lsts-parse-atom-tail( term, tokens )
);

let lsts-parse-map(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"{", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"HashtableEqEOF", with-location(mk-token("HashtableEqEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO map comprehension at \{loc}\n")
   } else {
      if lsts-parse-head(tokens) != c"}" {
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            let item-rest = lsts-parse-expression(tokens);
            let item = item-rest.first;
            tokens = item-rest.second;
            let mapped = if non-zero(tokens) && lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               let mapped-rest = lsts-parse-expression(tokens);
               tokens = mapped-rest.second;
               mapped-rest.first;
            } else {
               Lit{ c"1_u64", with-location(mk-token("1_u64"),loc) }
            };
            term = mk-app(
               Var{ c"map::cons", with-location(mk-token("map::cons"),loc) },
               mk-cons(mk-cons(item, mapped), term)
            );
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
      };
   };
   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);

let lsts-parse-lhs-big(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-lhs-one(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   if lsts-parse-head(tokens) == c"=" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      let val-rest = lsts-parse-lhs(tokens);
      tokens = val-rest.second;
      base = mk-app(
         Var{ c"macro::lhs-bind", with-location(mk-token("macro::lhs-bind"),loc) },
         mk-cons(base, val-rest.first)
      );
   };
   Tuple { base, tokens }
);

let lsts-parse-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO List Comprehension at \{loc}")
   } else {
      if lsts-parse-head(tokens)!=c"]" {
         let add-items = [] :: List<AST>;
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
            let item-rest = lsts-parse-expression(tokens);
            tokens = item-rest.second;
            add-items = cons( item-rest.first, add-items );
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
         for add-item in add-items {
            term = mk-app(
               Var{ c"list::cons", with-location(mk-token("list::cons"),loc) },
               mk-cons(add-item, term)
            );
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);

let lsts-parse-interface(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"interface", tokens); tokens = tail(tokens);

   let self-type = tv(c"self");
   (let interface-type, tokens) = lsts-parse-type(tokens);

   if lsts-parse-head(tokens)==c"implements" {
      lsts-parse-expect(c"implements", tokens); tokens = tail(tokens);
      self-type = interface-type;
      (interface-type, tokens) = lsts-parse-type(tokens);
   };
   interface-index = interface-index.bind(interface-type.ground-tag-and-arity, true);
   interface-self-index = interface-self-index.bind(interface-type.ground-tag-and-arity, (self-type, interface-type));

   lsts-parse-expect(c"{", tokens); tokens = tail(tokens);

   while lsts-parse-head(tokens) == c"let" {
      lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);

      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) || lsts-parse-head(tokens)==c".", tokens);
      let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      if name == c"." {
         lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
         name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      };

      let sig = lsts-parse-function-signature(tokens, loc);
      tokens = sig.second;
      let args-type = sig.first.args-type;
      let args-list = sig.first.args-list;
      let return-type = sig.first.return-type;

      let shapes = interface-shape-index.lookup(interface-type.ground-tag-and-arity,[] :: List<(CString,Type,Type)>);
      shapes = cons( (name, args-type, return-type), shapes );
      interface-shape-index = interface-shape-index.bind(interface-type.ground-tag-and-arity, shapes);

      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c";" {
      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   # ignored for now

   tokens
);

let lsts-parse-typedef(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"type", tokens); let blame = Var{head(tokens).key, head(tokens)}; tokens = tail(tokens);
   let mode = c"=";
   if lsts-parse-head(tokens)==c"opaque" {
      lsts-parse-expect(c"opaque", tokens); tokens = tail(tokens);
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"opaque";
   } else if lsts-parse-head(tokens)==c"alias" {
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"alias";
   };
   let base-rest = lsts-parse-type(tokens);
   tokens = base-rest.second;
   match tokens {
      [Token{key:c"="}.. Token{key:c">"}.. rest] => (
         tokens = rest;
         let rt-rest = lsts-parse-type(tokens);
         tokens = rt-rest.second;
         lsts-parse-expect(c";", tokens); tokens = tail(tokens);
         add-quick-prop(base-rest.first, base-rest.first, rt-rest.first);
         add-weaken-quick-prop(base-rest.first, base-rest.first, rt-rest.first);
      );
      [Token{key:c"implements"}.. rest] => (
         tokens = rest;
         (let rt, tokens) = lsts-parse-type(tokens);
         lsts-parse-expect(c";", tokens); tokens = tail(tokens);
         add-quick-prop(base-rest.first, base-rest.first, rt);
         add-weaken-quick-prop(base-rest.first, base-rest.first, rt);
         interface-implementors = cons((base-rest.first, rt, blame), interface-implementors);
      );
      _ => (
         if mode==c"=" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-typedef-case(tokens);
            let cases = case-rest.first;
            tokens = case-rest.second;
            while non-zero(tokens) && lsts-parse-head(tokens)!=c";" {
               lsts-parse-expect(c"|", tokens); let bar = head(tokens); tokens = tail(tokens);
               case-rest = lsts-parse-typedef-case(tokens);
               tokens = case-rest.second;
               cases = mk-cons(mk-cons(cases, Var{ bar.key, bar }), case-rest.first);
            };
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            ast-parsed-program = mk-seq(
               ast-parsed-program,
               mk-typedef(AType{ base-rest.first }, cases)
            );
         } else if mode==c"alias" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-type(tokens);
            tokens = case-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            add-type-alias(base-rest.first, case-rest.first);
         } else if mode==c"opaque" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-type(tokens);
            tokens = case-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            add-opaque-type-alias(base-rest.first, case-rest.first);
         };
      );
   };
   tokens
);

let lsts-parse-typedef-case(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[Type Case Tag]", lsts-is-lit-head(lsts-parse-head(tokens)), tokens);
   let tag = head(tokens); tokens = tail(tokens);
   let fields = ASTEOF {};
   if lsts-parse-head(tokens) == c"{" {
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
         lsts-parse-expect(c"[Field Name]", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
         let field-name = head(tokens); tokens = tail(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         let type-rest = lsts-parse-type(tokens);
         let field-type = type-rest.first;
         tokens = type-rest.second;
         if non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         };
         let fkv = mk-cons(Var{ field-name.key, field-name }, mk-atype(field-type));
         if non-zero(fields) {
            fields = mk-cons(fields, fkv);
         } else {
            fields = fkv;
         };
      };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   };
   let case = if non-zero(fields) {
      mk-cons(Lit{ tag.key, tag }, fields)
   } else {
      Lit{ tag.key, tag }
   };
   Tuple{ case, tokens }
);

type LstsFnSignature = LstsFnSignature { args-list: AST, args-type: Type, return-type: Type };

# parses:    (a: I32, b: I32): U64
let lsts-parse-function-signature(tokens: List<Token>, loc: SourceLocation): Tuple<LstsFnSignature, List<Token>> = (
   let out = LstsFnSignature { ASTNil, TAny, TAny };

   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   while non-zero(tokens) && lsts-parse-head(tokens)!=c")" {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      let arg-name = head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      let type-rest = lsts-parse-type(tokens);
      tokens = type-rest.second;
      if lsts-parse-head(tokens)==c"," { tokens = tail(tokens); } else { lsts-parse-expect(c")", tokens); };
      let arg-binding = mk-cons(
         Lit{ c":", with-location(mk-token(":"),loc) },
         mk-cons(Var{ arg-name.key, arg-name }, AType{ type-rest.first })
      );
      if is( out.args-list, ASTNil{} ) {
         out.args-list = arg-binding;
         out.args-type = type-rest.first;
      } else {
         out.args-list = mk-cons(out.args-list, arg-binding);
         out.args-type = t3(c"Cons", out.args-type, type-rest.first);
      };
   };
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c":" {
       lsts-parse-expect(c":", tokens); tokens = tail(tokens);
       let rtype-rest = lsts-parse-type(tokens);
       out.return-type = rtype-rest.first;
       tokens = rtype-rest.second;
   };

   Tuple { out, tokens }
);

let lsts-parse-let(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let prop = 0;
   if lsts-parse-head(tokens)==c"prop" {
      prop = 1;
      lsts-parse-expect(c"prop", tokens); tokens = tail(tokens);
   };
   let misc-tt = TAny;
   if lsts-parse-head(tokens)==c":" {
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      (misc-tt, tokens) = lsts-parse-type(tokens);
   };
   lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) || lsts-parse-head(tokens)==c".", tokens);
   let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   if name == c"." {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   };
   let args-list = ASTEOF {};
   let return-type = TAny {};
   if lsts-parse-head(tokens) == c"(" {
      let sig = lsts-parse-function-signature(tokens, loc);
      tokens = sig.second;
      args-list = sig.first.args-list;
      return-type = sig.first.return-type;
   };
   let return-term = Var{ c"__uninitialized", with-location(mk-token("__uninitialized"),loc) };
   if lsts-parse-head(tokens) == c"=" {
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      (return-term, tokens) = lsts-parse-small-expression(tokens);
   };
   if non-zero(args-list) {
      return-term = mk-cons(
         Lit{ c":", with-location(mk-token(":"),loc) },
         mk-cons(return-term, mk-atype(return-type))
      );
   };
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   if non-zero(args-list) {
      let attach-tt = if prop { t1(c"Prop") } else { TAny{} };
      if name==c"quick-prop" {
         match args-list {
            App{ left:Lit{key:c":"}, right:App{right:AType{ pre=tt }} } => (
               add-quick-prop(pre, TAny{}, return-type);
            );
            _ => (
               print("Malformed quick-prop Argument List at \{loc}\n");
               exit(1);
            );
         };
      } else {
         ast-parsed-program = mk-seq(
            ast-parsed-program,
            mk-glb( with-location(mk-token(name),loc), mk-abs(
               args-list, return-term, misc-tt && attach-tt
            ) )
         );
      };
   } else {
      ast-parsed-program = mk-seq(
         ast-parsed-program,
         mk-glb( with-location(mk-token(name),loc), return-term )
      );
   };
   tokens
);

type ASTOrIdent = ASTOrIdentAST { ast: AST }
                | ASTOrIdentId  { id: AST }
                | ASTOrIdentIgnore
                ;

let lsts-parse-small-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF {};
   match tokens {
      [Token{key:c"if"}.. Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens); tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let expr-rest = lsts-parse-small-expression(tokens); tokens = expr-rest.second;
         let matched-rest = if lsts-parse-head(tokens)==c"{" {
            lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
            let matched-rest = lsts-parse-expression(tokens); tokens = matched-rest.second;
            lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            Tuple{ matched-rest.first, tokens }
         } else {
            lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens)==c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let matched-rest = lsts-parse-expression(tokens); tokens = matched-rest.second;
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               Tuple{ matched-rest.first, tokens }
            } else {
               let matched-rest = lsts-parse-small-expression(tokens); tokens = matched-rest.second;
               matched-rest;
            }
         };
         let default-rest = if lsts-parse-head(tokens)==c"else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            let default-rest = lsts-parse-small-expression(tokens); tokens = default-rest.second;
            default-rest.first;
         } else ASTNil;
         let cases = mk-cons(ASTNil, mk-cons(lhs-rest.first, matched-rest.first));
         if non-zero(default-rest) {
            cases = mk-cons(cases, mk-cons(
               Var{ c"_", with-location(mk-token(c"_"),loc) },
               default-rest
            ));
         };
         base = mk-cons(
            mk-cons(
               Var{ c"match", with-location(mk-token("match"),loc) },
               expr-rest.first
            ),
            cases
         );
      );
      [Token{key:c"if"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let c-rest = lsts-parse-andor(tokens);
         let c = c-rest.first;
         tokens = c-rest.second;
         if lsts-parse-head(tokens) != c"{" {
            lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
         };
         let t = if lsts-parse-head(tokens) == c"{" {
            lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
            let true-expr = if lsts-parse-head(tokens) == c"}" then ASTNil else {
               let t-rest = lsts-parse-expression(tokens);
               tokens = t-rest.second;
               t-rest.first;
            };
            lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            true-expr;
         } else {
            let t-rest = lsts-parse-assign(tokens);
            tokens = t-rest.second;
            t-rest.first;
         };
         let f = ASTNil {};
         if lsts-parse-head(tokens) == "else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            f = if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let false-expr = if lsts-parse-head(tokens) == c"}" then ASTNil else {
                  let f-rest = lsts-parse-expression(tokens);
                  tokens = f-rest.second;
                  f-rest.first;
               };
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               false-expr;
            } else {
               let f-rest = lsts-parse-small-expression(tokens);
               tokens = f-rest.second;
               f-rest.first;
            };
         };
         base = mk-app(
            mk-app(
               mk-app(
                  Var{ c"if", with-location(mk-token("if"),loc) },
                  c
               ),
               mk-app(
                  Var{ c"scope", with-location(mk-token("scope"),loc) },
                  t
               )
            ),
            mk-app(
               Var{ c"scope", with-location(mk-token("scope"),loc) },
               f
            )
         );
      );
      [Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = mk-app(
            mk-app(
               Var{ c"let", with-location(mk-token("let"),loc) },
               lhs-rest.first
            ),
            rhs-rest.first
         );
      );
      [Token{key:c"while"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let c-rest = lsts-parse-small-expression(tokens);
         tokens = c-rest.second;
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-expression(tokens);
         tokens = rhs-rest.second;
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = mk-app(
            mk-app(
               Var{ c"while", with-location(mk-token("while"),loc) },
               c-rest.first
            ),
            mk-app(
               Var{ c"scope", with-location(mk-token("scope"),loc) },
               rhs-rest.first
            )
         );         
      );
      [Token{key:c"for"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let is-vector = if lsts-parse-head(tokens)==c"vector" {
            tokens = tail(tokens); true
         } else false;
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"in", tokens); tokens = tail(tokens);
         let iter-rest = lsts-parse-small-expression(tokens);
         tokens = iter-rest.second;
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         let rhs = ASTNil {};
         if lsts-parse-head(tokens) != c"}" {
            let rhs-rest = lsts-parse-expression(tokens);
            rhs = rhs-rest.first;
            tokens = rhs-rest.second;
         };
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = mk-app(
            mk-app(
               Var{ if is-vector then c"for-each-v" else c"for-each", with-location(mk-token("for-each"),loc) },
               mk-cons(
                  mk-cons(
                     lhs-rest.first,
                     Var{ c"in", with-location(mk-token("in"),loc) }
                  ),
                  iter-rest.first
               )
            ),
            mk-app(
               Var{ c"scope", with-location(mk-token("scope"),loc) },
               rhs
            )
         );         
      );
      [Token{key:c"match"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         
         let raw = if lsts-parse-head(tokens)==c"raw" {
            tokens = tail(tokens); true;
         } else false;
         let e-rest = lsts-parse-small-expression(tokens);
         tokens = e-rest.second;
         if raw {
            e-rest.first = mk-app(
               Var{ c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),loc) },
               e-rest.first
            );
         };
         let pats = ASTNil {};
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            let lhs-rest = lsts-parse-lhs(tokens);
            tokens = lhs-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            lsts-parse-expect(c">", tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"{" {
               fail("Please wrap map literals in match cases in parenthesis. At \{tokens.formatted-location}\n");
            };
            let rhs-rest = lsts-parse-small-expression(tokens);
            tokens = rhs-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            pats = mk-cons(pats, mk-cons(lhs-rest.first, rhs-rest.first));
         };
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = mk-app(
            mk-app(
               Var{ c"match", with-location(mk-token("match"),loc) },
               e-rest.first
            ),
            pats
         );
      );
      _ => (
         let assign-rest = lsts-parse-assign(tokens);
         base = assign-rest.first;
         tokens = assign-rest.second;
      );
   };
   Tuple { base, tokens }
);

let lsts-parse-assign(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF;
   if lsts-has-assign(tokens) {
      let loc = head(tokens).location;

      if lsts-parse-head(tokens) == c"(" {
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);

         let lefts = [] :: List<ASTOrIdent>;

         let loop = true;
         while loop {
            match lsts-parse-head(tokens) {
               c"_" => (
                  tokens = tail(tokens);
                  lefts = cons(ASTOrIdentIgnore {}, lefts);
               );

               c"let" => (
                  tokens = tail(tokens);
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentId { lhs.first }, lefts);
               );

               hd => (
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentAST { lhs.first }, lefts);
               );
            };

            if lsts-parse-head(tokens) == c"," {
               tokens = tail(tokens);
            } else {
               loop = false;
            };
         };

         lsts-parse-expect(c")", tokens); tokens = tail(tokens);

         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         let rhs-tmp-name = uuid();
         let rhs-tmp = Var{ rhs-tmp-name, with-location(mk-token(rhs-tmp-name),loc) };
         base = mk-app(
            mk-app(
               Var{ c"let", with-location(mk-token(c"let"),loc) },
               rhs-tmp
            ),
            rhs-rest.first
         );

         let i = 0_u64;
         for lhs in lefts {
            let fieldstr = c"." + to-string(i+1);
            let rexpr = mk-app(
               Var{ fieldstr, with-location(mk-token(fieldstr),loc) },
               rhs-tmp
            );

            match lhs {
               ASTOrIdentIgnore {} => ();

               ASTOrIdentAST { ast=ast } => (
                  let x = mk-cons(
                     mk-cons(
                        Var{ c"set", with-location(mk-token("set"),loc) },
                        ast
                     ),
                     rexpr
                  );
                  base = mk-cons(base, x);
               );

               ASTOrIdentId { id=id } => (
                  let x = mk-app(
                     mk-app(
                        Var{ c"let", with-location(mk-token("let"),loc) },
                        id
                     ),
                     rexpr
                  );
                  base = mk-cons(base, x);
               );
            };
            i = i + 1;
         };
      } else {
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = mk-cons(
            mk-cons(
               Var{ c"set", with-location(mk-token("set"),loc) },
               lhs-rest.first
            ),
            rhs-rest.first
         );
      };
   } else {
      let base-rest = lsts-parse-andor(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
   };
   Tuple { base, tokens }
);

let lsts-make-lit(t: Token): AST = (
   let loc = t.location;
   let base = Lit { t.key, t };
   if t.key.has-suffix(c"_ss") && t.key.contains(c"\\{") {
      let s = t.key;
      base = ASTEOF {};
      let buffer = SNil{};
      while non-zero(s) && s != c"_ss" {
         if s.has-prefix(c"\\{") {
            if non-zero(buffer) {
               buffer = buffer + SAtom{c"_ss"};
               let bs = clone-rope(buffer);
               let be = Lit { bs, with-location(mk-token(bs),loc) };
               if non-zero(base) {
                  base = mk-app(
                     Var{ c"+", with-location(mk-token("+"),loc) },
                     mk-cons(base, be)
                  );
               } else { base = be; };
               buffer = SNil {};
            };

            s = s.remove-prefix(c"\\{");
            let t-buffer = SNil {};
            while non-zero(s) && not(s.has-prefix(c"}")) {
               t-buffer = t-buffer + SAtom{clone-rope(head-string(s))};
               s = tail-string(s);
            };
            if non-zero(s) && s.has-prefix(c"}") {
               s = tail-string(s);
            };
            let sub-tokens = lsts-tokenize-string(c"[Format String]", clone-rope(t-buffer));
            let se-rest = lsts-parse-expression(sub-tokens);
            let se = mk-app(
               Var{ c"to-smart-string", with-location(mk-token("to-smart-string"),loc) },
               se-rest.first
            );
            if non-zero(base) {
               base = mk-app(
                  Var{ c"+", with-location(mk-token("+"),loc) },
                  mk-cons(base, se)
               );
            } else {
               base = se;
            };
            if non-zero(se-rest.second) {
               lsts-parse-expect(c"[EOF]", se-rest.second);
            }
         } else {
            buffer = buffer + SAtom {clone-rope(head-string(s))};
            s = tail-string(s);
         }
      };
      if non-zero(buffer) {
         buffer = buffer + SAtom{ c"_ss" };
         let bs = clone-rope(buffer);
         let be = Lit{ bs, with-location(mk-token(bs),loc) };
         if non-zero(base) {
            base = mk-app(
               Var{ c"+", with-location(mk-token("+"),loc) },
               mk-cons(base, be)
            );
         } else {
            base = be;
         };
      };
   };
   base
);

let lsts-parse-lhs-one(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let base-rest = lsts-make-maybe-var(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens); tokens = tail(tokens);
      let base-rest = lsts-parse-lhs-one(tokens);
      tokens = base-rest.second;
      mk-cons(
         Var{ amp.key, amp },
         base-rest.first
      );
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let base-rest = lsts-parse-lit(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if non-zero(tokens) && lsts-parse-head(tokens)==c"[" {
      let base-rest = lsts-parse-lhs-list(tokens);
      tokens = base-rest.second;
      base-rest.first; 
   } else if non-zero(tokens) && lsts-parse-head(tail(tokens))==c"{" {
      let loc = head(tokens).location;
      let tag = lsts-parse-head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      let des-args = ASTEOF {};
      while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
         let attr-loc = head(tokens).location;
         let binding = c"";
         let attr-key = c"";
         let raw = false;
         if lsts-parse-head(tokens) == c"raw" {
            raw = true; tokens = tail(tokens);
         };
         if lsts-is-ident-head(lsts-parse-head(tokens)) {
            attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
         };
         if lsts-parse-head(tokens)==c"=" {
            binding = attr-key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"raw" {
               raw = true; tokens = tail(tokens);
            };
            if lsts-is-ident-head(lsts-parse-head(tokens)) {
               attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
            } else { lsts-parse-expect(c"[Identifier]", tokens); };
         };
         let val = if lsts-parse-head(tokens)==c":" {
            tokens = tail(tokens);
            let val-rest = lsts-parse-lhs-one(tokens);
            tokens = val-rest.second;
            val-rest.first;
         } else { ASTEOF{} };
         if not(non-zero(val)) && not(non-zero(binding)) && not(non-zero(attr-key)) {
            lsts-parse-expect(c"[Struct LHS]", tokens); tokens = tail(tokens);
         };
         if not(non-zero(val)) {
            val = Var{ c"_", with-location(mk-token("_"),attr-loc) };
         };
         if non-zero(binding) {
            val = mk-app(
               Var{ c"@", with-location(mk-token("@"),attr-loc) },
               mk-cons(
                  Var{ binding, with-location(mk-token(binding),attr-loc) },
                  val
               )
            );
            if raw {
               val = mk-app(
                  Var{ c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),attr-loc) },
                  val
               );
            };
         };
         if non-zero(attr-key) {
            attr-key = c"." + attr-key;
            val = mk-app(
               Var{ c"macro::bind-field-by-key", with-location(mk-token("macro::bind-field-by-key"),attr-loc) },
               mk-cons(
                  Var{ attr-key, with-location(mk-token(attr-key),attr-loc) },
                  val
               )
            );
         };
         if non-zero(des-args) {
            des-args = mk-cons(des-args, val);
         } else { des-args = val; };
         if lsts-parse-head(tokens) != c"}" {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         };
      };
      if not(non-zero(des-args)) { des-args = ASTNil {}; };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      mk-app(
         Lit{ tag, with-location(mk-token(tag),loc) },
         des-args
      );
   } else {
      lsts-parse-expect(c"[Left Hand Side]", tokens);
      ASTEOF {}
   };
   Tuple { base, tokens }
);

let lsts-parse-lit(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let loc = head(tokens).location;
   let term = ASTEOF {};
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      while lsts-parse-head(tokens).has-suffix(c"_ss") {
         let cat = lsts-make-lit(head(tokens));
         tokens = tail(tokens);
         if non-zero(term) {
            term = mk-app(
               Var{ c"+", with-location(mk-token("+"),loc) },
               mk-cons(term, cat)
            );
         } else { term = cat; };
      }
   } else {
      term = lsts-make-lit(head(tokens));
      tokens = tail(tokens);
   };
   Tuple { term, tokens }
);

let lsts-parse-atom-without-tail(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term = ASTEOF {};
   if lsts-parse-head(tokens)==c"type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType{ t2(c"Type", term-rest.first) };
   } else if lsts-parse-head(tokens)==c"raw-type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType{ term-rest.first };
   } else if lsts-parse-head(tokens)==c"sizeof" {
      let loc = head(tokens).location;
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = mk-app(
         Var{ c"sizeof", with-location(mk-token(c"sizeof"),loc) },
         mk-atype(term-rest.first)
      );
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens);
      tokens = tail(tokens);
      let term-rest = lsts-parse-atom-without-tail(tokens);
      tokens = term-rest.second;
      term = mk-app(
         Var{ amp.key, amp },
         term-rest.first
      );
      term-rest = lsts-parse-atom-tail(term, tokens);
      term = term-rest.first;
      tokens = term-rest.second;
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let term-rest = lsts-make-maybe-var(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else if lsts-parse-head(tokens)==c"." && lsts-is-ident-head(lsts-parse-head(tail(tokens))) {
      let t = head(tokens).key + head(tail(tokens)).key;
      tokens = tail(tokens); tokens = tail(tokens);
      Tuple{ Var{ t, mk-token(t) }, tokens }
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let term-rest = lsts-parse-lit(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else match tokens {
      [Token{key:c"("}.. rest] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c")" {
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = ASTNil {};
         } else {
            let term-rest = lsts-parse-expression-possibly-tuple(tokens);
            tokens = term-rest.second;
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = term-rest.first;
         }
      );
      [Token{key:c"["}.. rest] => (
         let term-rest = lsts-parse-list(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      [Token{key:c"{"}.. rest] => (
         let term-rest = lsts-parse-map(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      _ => (
         if lsts-is-enum-head(lsts-parse-head(tokens)) {
            let tag = head(tokens); tokens = tail(tokens);
            term = Lit { tag.key, tag };
            let fields = ASTEOF {};
            if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
                  let field-rest = lsts-parse-small-expression(tokens);
                  tokens = field-rest.second;
                  if non-zero(fields) {
                     fields = mk-cons(fields, field-rest.first);
                  } else { fields = field-rest.first; };
                  if lsts-parse-head(tokens)==c"," {
                     tokens = tail(tokens);
                  } else {
                     lsts-parse-expect(c"}", tokens);
                  };
               };
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            };
            if non-zero(fields) {
               term = mk-app(term, fields);
            };
         } else {
            lsts-parse-expect(c"[Atom]", tokens);
         }
      );
   };
   Tuple { term, tokens };
);

let lsts-parse-atom(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let atom-rest = lsts-parse-atom-without-tail(tokens);
   lsts-parse-atom-tail(atom-rest.first,atom-rest.second);
);

let lsts-parse-atom-tail(base: AST, tokens: List<Token>): Tuple<AST,List<Token>> = (
   while lsts-parse-head(tokens) == c"[" ||
         lsts-parse-head(tokens) == c"(" ||
         lsts-parse-head(tokens) == c"." ||
         lsts-parse-head(tokens) == c"as" ||
         (lsts-parse-head(tokens) == c":" && non-zero(tokens) && lsts-parse-head(tail(tokens)) == c":") {
      let loc = head(tokens).location;
      match tokens {
         [Token{key:c":"}.. Token{key:c":"}.. rest] => (
            tokens = rest;
            let type-rest = lsts-parse-type(tokens);
            tokens = type-rest.second;
            base = mk-app(
               Lit{ c":", with-location(mk-token(":"),loc) },
               mk-cons(base, mk-atype(type-rest.first))
            );
         );
         [Token{key:"."}.. rest] => (
            tokens = rest;
            lsts-parse-expect( c"[Identifier]", lsts-is-ident-head(lsts-parse-head(tokens)), tokens );
            let method = c"." + head(tokens).key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"(" {
               lsts-parse-expect( c"(", tokens ); tokens = tail(tokens);
               while non-zero(tokens) && lsts-parse-head(tokens)!=c")" {
                  let next-rest = lsts-parse-expression(tokens);
                  tokens = next-rest.second;
                  if non-zero(tokens) && lsts-parse-head(tokens)==c"," {
                     tokens = tail(tokens);
                  } else {
                     lsts-parse-expect( c")", tokens );
                  };
                  base = mk-cons(base, next-rest.first);
               };
               lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
            };
            base = mk-app(
               Var{ method, with-location(mk-token(method),loc) },
               base
            );
         );
         [Token{key:"as"}.. rest] => (
            tokens = rest;
            let type-rest = lsts-parse-type(tokens); 
            tokens = type-rest.second;
            base = mk-app(
               Var{ c"as", with-location(mk-token("as"),loc) },
               mk-cons(base, mk-atype(type-rest.first))
            );
         );
         [Token{key:"["}.. rest] => (
            tokens = rest;
            let term1 = if lsts-parse-head(tokens)==c":" {
               Lit{ c"0_i64", with-location(mk-token("0_i64"),loc) }
            } else {
               let term1-rest = lsts-parse-small-expression(tokens);
               tokens = term1-rest.second;
               term1-rest.first;
            };
            let term2 = ASTEOF {};
            if lsts-parse-head(tokens)==c":" {
               lsts-parse-expect( c":", tokens ); tokens = tail(tokens);
               term2 = if lsts-parse-head(tokens)==c"]" {
                  Lit{ c"minimum-I64", with-location(mk-token("minimum-I64"),loc) }
               } else {
                  let term2-rest = lsts-parse-small-expression(tokens);
                  tokens = term2-rest.second;
                  term2-rest.first;
               };
            };
            if non-zero(term2) {
               base = mk-app(
                  Var{ c"[:]", with-location(mk-token("[:]"),loc) },
                  mk-cons(mk-cons(base, term1), term2)
               );
            } else {
               base = mk-app(
                  Var{ c"[]", with-location(mk-token("[:]"),loc) },
                  mk-cons(base, term1)
               );
            };
            lsts-parse-expect( c"]", tokens ); tokens = tail(tokens);
         );
         [Token{key:"("}.. rest] => (
            tokens = rest;
            if lsts-parse-head(tokens) == c")" {
               base = mk-app(base, ASTNil);
            } else {
               let term2-rest = lsts-parse-expression(tokens);
               let term2 = term2-rest.first;
               tokens = term2-rest.second;
               while lsts-parse-head(tokens)==c"," {
                  tokens = tail(tokens);
                  let term3-rest = lsts-parse-expression(tokens);
                  tokens = term3-rest.second;
                  term2 = mk-cons(term2, term3-rest.first);
               };
               base = mk-app(base, term2);
            };
            lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
         );
      }
   };
   Tuple { base, tokens }
);
