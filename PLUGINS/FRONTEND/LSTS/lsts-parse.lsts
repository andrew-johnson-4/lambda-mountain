
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").get-or(c"").remove-suffix(c"\"").get-or(c"")
   } else ident
);

let lsts-unwrap-identifier(ident: Token): Token = (
   match ident {
      Token { skey=skey, key=key, nonce=nonce, location=location } => Token ( lsts-unwrap-identifier(key), iuid(), location );
   };
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }; ();
);

let lsts-parse-expect(expect: CString, b: Bool, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }; ();
);

let lsts-parse-identifier(tokens: List<Token>): Tuple<CString, List<Token>> = (
   let name = c"";
   if lsts-parse-head(tokens)==c"." { name = c"."; tokens = tail(tokens); };
   lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
   name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   while lsts-parse-head(tokens)==c":" and lsts-parse-head(tail(tokens))==c":" and lsts-is-ident-head(lsts-parse-head(tail(tail(tokens)))) {
      name = name + c"::"; tokens = tail(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   };
   (name, tokens);
);

let lsts-parse-doc-wordf(tokens: List<Token>, begin: CString, end: CString): Tuple<CString, List<Token>> = (
   lsts-parse-expect(begin, tokens); tokens = tail(tokens);
   let text = mk-vector(type(U8), 16);
   while lsts-parse-head(tokens) != end {
      if lsts-parse-head(tokens) == c"\n" {
         lsts-parse-expect(end, 0, tokens);
      };
      if text.length > 0 {
         text = text.push(32_u8);
      };
      let h = lsts-parse-head(tokens);
      while non-zero(h) {
         text = text.push(head(h));
         h = tail(h);
      };
      tokens = tail(tokens);
   };
   Tuple ( text.into(type(CString)), tokens )
);

let lsts-parse-doc-expr(tokens: List<Token>): Tuple<AST, List<(CString, AST)>, List<Token>> = (
   let tags = [] : List<(CString, AST)>;
   let val = match lsts-parse-head(tokens) {
      c"__" => (
         (let s, tokens) = lsts-parse-doc-wordf(tokens, c"__", c"__");
         mk-app( mk-var("meta::style::underline"), mk-lit(s) )
      );

      c"**" => (
         (let s, tokens) = lsts-parse-doc-wordf(tokens, c"**", c"**");
         mk-app( mk-var("meta::style::bold"), mk-lit(s) )
      );

      c"[" => (
         tokens = tail(tokens);
         let v = if lsts-parse-head(tokens) == c"[" {
            tokens = tail(tokens);
            let key = lsts-parse-head(tokens); tokens = tail(tokens);
            let val = mk-nil();
            if lsts-parse-head(tokens) == c":" {
               tokens = tail(tokens);
               (val, tokens) = lsts-parse-expression(tokens);
            };
            lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
            tags = cons( (key,val), tags );
            mk-nil();
         } else {
            (let v, tokens) = lsts-parse-expression(tokens);
            v
         };
         lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
         v
      );

      word => (
         tokens = tail(tokens);
         mk-lit(word);
      );
   };
   Tuple ( val, tags.reverse, tokens )
);

let lsts-parse-doc(tokens: List<Token>): Tuple<AST, List<Token>> = (
   let ast = mk-eof();
   let para = mk-eof();

   let tags = [] : List<(CString, AST)>;

   while lsts-parse-head(tokens) == c"##" {
      tokens = tail(tokens);

      let line = mk-eof();
      # special token inserted by the lexer only in doc strings
      while lsts-parse-head(tokens) != c"\n" {
         (let ax, let new-tags, tokens) = lsts-parse-doc-expr(tokens);
         tags = tags + new-tags;
         if non-zero(ax) {
            line = line + ax;
         };
      };
      tokens = tail(tokens);

      if non-zero(line) {
         para = para + line;
      } else {
         # empty line => new paragraph
         if non-zero(para) {
            ast = ast + para;
            para = mk-eof();
         };
      };
   };

   for Tuple{key=first, val=second} in tags {
      ast = mk-app( mk-var("Meta::with-tag"), mk-cons( mk-lit(key), val ) );
   };

   Tuple ( ast, tokens )
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] : List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] : List<Token>} else {tokens = rest;});
      [Token{key:c"."}.. Token{key:c"."} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"="}.. Token{key:c">"} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"if"} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"then"} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"else"} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [Token{key:c"fn"} .. rest] => (if depth == 0_i64 {tokens = [] : List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] : List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s.has-suffix(c"_ss") then untern(intern(s)[:-3_i64]) else
   s.remove-suffix(c"_u64").get-or(c"")
    .remove-suffix(c"_u32").get-or(c"")
    .remove-suffix(c"_u16").get-or(c"")
    .remove-suffix(c"_u8").get-or(c"")
    .remove-suffix(c"_i64").get-or(c"")
    .remove-suffix(c"_i32").get-or(c"")
    .remove-suffix(c"_i16").get-or(c"")
    .remove-suffix(c"_i8").get-or(c"")
);

let lsts-is-type-tag(s: CString): Bool = (
      s.has-suffix(c"_ss")
   or s.has-suffix(c"_u64")
   or s.has-suffix(c"_u32")
   or s.has-suffix(c"_u16")
   or s.has-suffix(c"_u8")
   or s.has-suffix(c"_i64")
   or s.has-suffix(c"_i32")
   or s.has-suffix(c"_i16")
   or s.has-suffix(c"_i8")
   or lsts-is-lit-head(s) 
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      (let docx, tokens) = lsts-parse-doc(tokens);
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => (
            (let t, tokens) = lsts-parse-let(tokens);
            ast-parsed-program = ast-parsed-program + t;
         );
         [ Token{key:c"type"}.. _] => (
            (let td, tokens) = lsts-parse-typedef(tokens);
            ast-parsed-program = ast-parsed-program + td;
         );
         [ Token{key:c"typed"}.. Token{key:c"macro"}.. _] => (
            (let bind, tokens) = lsts-parse-typed-macro(tokens);
            ast-parsed-program = ast-parsed-program + bind;
         );
         [ Token{key:c"deprecated"}.. Token{key:c"macro"}.. rst] => (
            (let mlhs, tokens) = lsts-parse-atom-without-tail(rst);
            let mrhs = ASTNil;
            lsts-parse-expect(c"(",tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens)=="let" then (mrhs, tokens) = lsts-parse-let(tokens)
            else (mrhs, tokens) = lsts-parse-atom(tokens);
            lsts-parse-expect(c")",tokens); tokens = tail(tokens);
            preprocess-macros = MSeq( close(preprocess-macros), Macro(mlhs.without-location, mrhs.without-location) );
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
         [ Token{key:c"interface"}.. _] => tokens = lsts-parse-interface(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil();
            while non-zero(tokens) and lsts-parse-head(tokens) != c";" {
               path = path + SAtom ( lsts-unwrap-identifier(lsts-parse-head(tokens)) );
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = ast-parsed-program + term;
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
      if non-zero(docx) { 
         ast-parsed-program = ast-parsed-program + mk-meta(docx);
      };
   };
);

let lsts-parse-top-level(tokens: List<Token>): Tuple<AST,List<Token>> = (
   # TODO, accept all top-level expressions here
   lsts-parse-expression(tokens);
);

let lsts-parse-typed-macro(tokens: List<Token>): (AST, List<Token>) = (
   lsts-parse-expect(c"typed", tokens); tokens = tail(tokens);
   lsts-parse-expect(c"macro", tokens); tokens = tail(tokens);

   (let mname, tokens) = lsts-parse-identifier(tokens);
   let margs = mk-nil();
   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   while lsts-parse-head(tokens)!=c")" {
      if not(is(margs,mk-nil())) then { lsts-parse-expect(c",", tokens); tokens = tail(tokens); };
      (let binding, tokens) = lsts-parse-identifier(tokens);
      let mbind = mk-var(binding);
      while lsts-parse-head(tokens) != c":" {
         (binding, tokens) = lsts-parse-identifier(tokens);
         mbind = mk-cons(mbind, mk-var(binding));
      };
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      (let mbindt, tokens) = lsts-parse-type(tokens);
      let marg = mk-app(mk-lit(c":"), mk-cons(mbind, mk-atype(mbindt)));
      if is(margs,mk-nil()) then margs = marg
                          else margs = mk-cons(margs, marg);
   };
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);
   lsts-parse-expect(c":", tokens); tokens = tail(tokens);
   (let mrett, tokens) = lsts-parse-type(tokens);
   lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   (let mbody, tokens) = lsts-parse-top-level(tokens);
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   (mk-glb(
      mk-token(mname),
      mk-abs(margs, mk-app(mk-lit(c":"), mk-cons(mbody.without-location,mk-atype(mrett))), t0(c"TypedMacro"))
   ), tokens)
);

let lsts-parse-type(tokens: List<Token>): Tuple<Type,List<Token>> = (
   (let base-type, tokens) = lsts-parse-type-conjugate(tokens);
   while (lsts-parse-head(tokens)==c"-" and lsts-parse-head(tail(tokens))==c">") or
         (lsts-parse-head(tokens)==c"~" and lsts-parse-head(tail(tokens))==c">") {
      if lsts-parse-head(tokens)==c"-" and lsts-parse-head(tail(tokens))==c">" {
         lsts-parse-expect(c"-", tokens); tokens = tail(tokens);
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
         (let tail-type, tokens) = lsts-parse-type-conjugate(tokens);
         base-type = t2(c"Arrow", base-type, tail-type);
      } else {
         lsts-parse-expect(c"~", tokens); tokens = tail(tokens);
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
         (let tail-type, tokens) = lsts-parse-type-conjugate(tokens);
         base-type = t2(c"Phi::Transition", base-type, tail-type) && t0(c"MustNotFresh");
      }
   };
   (base-type, tokens)
);

let lsts-parse-type-conjugate(tokens: List<Token>): Tuple<Type,List<Token>> = (
   let tt = if lsts-parse-head(tokens) == c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let args-rest = lsts-parse-type(tokens);
      let args = [ args-rest.first ];
      tokens = args-rest.second;
      while lsts-parse-head(tokens) == c"," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         let tnext-rest = lsts-parse-type(tokens);
         args = cons( tnext-rest.first, args );
         tokens = tnext-rest.second;
      };
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      if args.length==1 then head(args) else TGround ( c"Tuple", close(args) );
   } else if lsts-parse-head(tokens)==c"?" {
      lsts-parse-expect(c"?", tokens); tokens = tail(tokens);
      ta
   } else if lsts-parse-head(tokens)==c"_" {
      lsts-parse-expect(c"_", tokens); tokens = tail(tokens);
      ta
   } else if lsts-parse-head(tokens).has-prefix(c"'") and not(lsts-parse-head(tokens).has-suffix(c"'")) {
      let new-tt = t1(c"Linear",t0(c"Phi::Live"));
      tokens = tail(tokens);
      new-tt
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) and not(lsts-is-type-tag(lsts-parse-head(tokens))) {
      (let varname, tokens) = lsts-parse-identifier(tokens);
      TVar ( varname )
   } else {
      if not(lsts-is-type-tag(lsts-parse-head(tokens))) {
         lsts-parse-expect(c"[Type Tag]", tokens);
      };
      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens)); tokens = tail(tokens);
      if not(config-v3) and base==c"Hashtable" then base = c"HashtableEq";
      while non-zero(tokens) and lsts-parse-head(tokens)==c":" and lsts-parse-head(tail(tokens))==c":" {
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"Type", non-zero(tokens), tokens);
         if not(lsts-is-type-tag(lsts-parse-head(tokens))) and not(lsts-is-ident-head(lsts-parse-head(tokens))) {
            lsts-parse-expect(c"[Type Tag or Variable]", tokens);
         };
         base = base + c"::" + lsts-substitute-type-aliases(lsts-parse-head(tokens));
         tokens = tail(tokens);
      };
      let args = [] : List<Type>;
      if lsts-parse-head(tokens) == c"<" {
         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
         let targs-rest = lsts-parse-type(tokens);
         args = cons( targs-rest.first, args );
         tokens = targs-rest.second;
         while lsts-parse-head(tokens) == c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            let tnext-rest = lsts-parse-type(tokens);
            args = cons( tnext-rest.first, args );
            tokens = tnext-rest.second;
         };
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      };
      if not(config-v3) and base==c"OwnedData" and args.length==1 {
         head(args);
      } else TGround ( base, close(args) );
   };
   while lsts-parse-head(tokens) == c"[" or lsts-parse-head(tokens)==c"?" {
      if lsts-parse-head(tokens)==c"[" {
         lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
         let index = if lsts-parse-head(tokens) != c"]" {
            let tindex-rest = lsts-parse-type(tokens);
            tokens = tindex-rest.second;
            tindex-rest.first;
         } else { ta };
         lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
         tt = t2(c"Array", tt, index);
      } else {
         lsts-parse-expect(c"?", tokens); tokens = tail(tokens);
         tt = t1(c"Maybe", tt);
      }
   };
   if lsts-parse-head(tokens)==c"+" {
      tokens = tail(tokens);
      let ntt-rest = lsts-parse-type-conjugate(tokens);
      tt = ntt-rest.first && tt;
      tokens = ntt-rest.second;
   };
   Tuple ( tt, tokens );
);

let lsts-parse-expression-possibly-tuple(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if not(non-zero(tokens)) { lsts-parse-expect(c"ExpressionPossiblyTuple", tokens); };
   let loc = head(tokens).location;
   let base-rest = lsts-parse-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   let is-tuple = 0;
   while lsts-parse-head(tokens) == c"," {
      is-tuple = 1;
      tokens = tail(tokens);
      base-rest = lsts-parse-expression(tokens);
      base = mk-cons(base, base-rest.first);
      tokens = base-rest.second;
   };
   if is-tuple {
      base = mk-app(
         Lit( c"Tuple", with-location(mk-token("Tuple"),loc) ),
         base
      );
   };
   Tuple ( base, tokens )
);

let lsts-parse-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-small-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   while lsts-parse-head(tokens) == c";" {
      tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c")" and lsts-parse-head(tokens)!=c"}" {
         base-rest = lsts-parse-small-expression(tokens);
         base = mk-cons(base, base-rest.first);
         tokens = base-rest.second;
      }
   };
   Tuple ( base, tokens )
);

let lsts-parse-lhs-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = mk-eof();
   lsts-parse-expect(c"[", tokens);
   let loc = head(tokens).location;
   tokens = tail(tokens);
   if lsts-parse-head(tokens) == c"]" {
      base = Lit ( c"LEOF", with-location(mk-token("LEOF"),loc) );
   } else {
      let base-rest = lsts-parse-lhs-one(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
      let bases = [base];
      while non-zero(tokens) and lsts-parse-head(tokens)==c"." {
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c"]" {
            bases = cons( Lit( c"LEOF", with-location(mk-token("LEOF"),loc) ), bases );
         } else {
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            bases = cons( next, bases );
         }
      };
      base = head(bases); bases = tail(bases);
      for b in bases {
         base = mk-app(
            Var( c"macro::lhs-head", with-location(mk-token("macro::lhs-head"),loc) ),
            mk-cons(b, base)
         );
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple ( base, tokens )
);

let lsts-parse-lhs(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = match tokens {
      [ Token{key:c"["}.. _ ] => (
         let base-rest = lsts-parse-lhs-list(tokens);
         tokens = base-rest.second;
         base-rest.first;
      );
      [ Token{key:c"("}.. _] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         let base-rest = lsts-parse-lhs-big(tokens);
         tokens = base-rest.second;
         lsts-parse-expect(c")", tokens); tokens = tail(tokens);
         base-rest.first;
      );
      _ => (
         let base-rest = lsts-parse-lhs-one(tokens);
         tokens = base-rest.second;
         base-rest.first;         
      );
   };
   while non-zero(tokens) and (lsts-parse-head(tokens)==c"." or lsts-parse-head(tokens)=="[") {
      match tokens {
         [Token{key:c"."}.. Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            base = mk-app(
               Var( c"macro::lhs-prefix-or-suffix", with-location(mk-token("macro::lhs-prefix-or-suffix"),loc) ),
               mk-cons(base, next)
            );
         );
         [Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            (let field-name, tokens) = lsts-parse-identifier(tokens);
            base = mk-app(
               Var( c"macro::lhs-field", with-location(mk-token("macro::lhs-field"),loc) ),
               mk-cons(base, mk-var(field-name))
            );
         );
         [Token{key:c"["}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-expression(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
            base = mk-app(
               Var( c"macro::lhs-index", with-location(mk-token("macro::lhs-index"),loc) ),
               mk-cons(base, next)
            );
         );
      }
   };
   Tuple ( base, tokens )
);

let lsts-make-maybe-var(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      lsts-parse-lit(tokens)
   } else {
      if not(non-zero(tokens)) { lsts-parse-expect(c"Identifier", tokens); };
      let loc = head(tokens).location;
      let base = mk-eof();
      if lsts-is-lit(head(tokens).key) {
         base = lsts-make-lit(head(tokens));
         tokens = tail(tokens);
      } else {
         (let var-name, tokens) = lsts-parse-identifier(tokens);
         base = mk-var(var-name).with-location(loc);
      };
      Tuple ( base, tokens )
   }
);

let lsts-is-lit(s: CString): Bool = (
   let r = false;
   for Tuple { sfxs=first } in parse-suffixes {
      r = r or s.has-suffix(sfxs);
   }; r;
);

let lsts-parse-add(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-mul(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"+" or lsts-parse-head(tokens)==c"-" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-mul(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var( op, op-t ),
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple ( term, tokens )
);

let lsts-parse-bitwise(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-add(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"&" or lsts-parse-head(tokens)==c"|" or lsts-parse-head(tokens)==c"^" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-add(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var( op, op-t ),
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple ( term, tokens )
);

let lsts-parse-cmp(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-bitwise(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"==" or lsts-parse-head(tokens)==c"!=" or
         lsts-parse-head(tokens)==c"<" or lsts-parse-head(tokens)==c"<=" or
         lsts-parse-head(tokens)==c">" or lsts-parse-head(tokens)==c">=" or
         lsts-parse-head(tokens)==c"<:" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      if (op==c"<" and lsts-parse-head(tokens)==c"<") or
         (op==c">" and lsts-parse-head(tokens)==c">") {
         op = op + op; op-t = with-key(op-t, op); tokens = tail(tokens);
      };
      let term2-rest = lsts-parse-bitwise(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var( op, op-t ),
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple ( term, tokens )
);

let lsts-parse-ascript(tokens: List<Token>): Tuple<AST,List<Token>> = (
   (let term, tokens) = lsts-parse-andor(tokens);
   while lsts-parse-head(tokens)==c":" and non-zero(tokens) and lsts-parse-head(tail(tokens)) != c":" {
      tokens = tail(tokens);
      (let tt, tokens) = lsts-parse-type(tokens);
      if tt.is-t(c"L",0) then tt = tt && t0(c"Literal");
      tt = phi-as-state(tt);
      match term {
         App{ constructor=left:Lit{}, right:ASTNil{} } => (
            term = mk-app(constructor.ascript(tt), mk-nil());
         );
         _ => term = term.ascript(tt);
      }
   };
   Tuple ( term, tokens )
);

let lsts-parse-andor(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-cmp(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"&&" or lsts-parse-head(tokens)==c"||"
      or lsts-parse-head(tokens)==c"and" or lsts-parse-head(tokens)==c"or" or lsts-parse-head(tokens)==c"xor" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-cmp(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var( op, op-t ),
         mk-cons(term, term2-rest.first)
      );
   };
   Tuple ( term, tokens )
);

let lsts-parse-mul(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-atom(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"*" or lsts-parse-head(tokens)==c"/" or lsts-parse-head(tokens)==c"%" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-atom(tokens);
      tokens = term2-rest.second;
      term = mk-app( 
         Var( op, op-t ),
         mk-cons(term, term2-rest.first)
      );
   };
   lsts-parse-atom-tail( term, tokens )
);

let lsts-parse-map(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"{", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = if config-v3
   then mk-app( Var( c"mk-hashtable", with-location(mk-token("mk-hashtable"),loc) ), mk-nil() )
   else Lit( c"HashtableEqEOF", with-location(mk-token("HashtableEqEOF"),loc) );
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO map comprehension at \{loc}\n")
   } else {
      if lsts-parse-head(tokens) != c"}" {
         while non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
            let item-rest = lsts-parse-andor(tokens);
            let item = item-rest.first;
            tokens = item-rest.second;
            let mapped = if non-zero(tokens) and lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               let mapped-rest = lsts-parse-expression(tokens);
               tokens = mapped-rest.second;
               mapped-rest.first;
            } else {
               Lit( c"1_u64", with-location(mk-token("1_u64"),loc) )
            };
            term = mk-app(
               Var( c"map::cons", with-location(mk-token("map::cons"),loc) ),
               mk-cons(mk-cons(item, mapped), term)
            );
            if non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
      };
   };
   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   Tuple ( term, tokens )
);

let lsts-parse-lhs-big(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-lhs-one(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   if lsts-parse-head(tokens) == c"=" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      let val-rest = lsts-parse-lhs(tokens);
      tokens = val-rest.second;
      base = mk-app(
         Var( c"macro::lhs-bind", with-location(mk-token("macro::lhs-bind"),loc) ),
         mk-cons(base, val-rest.first)
      );
   };
   Tuple ( base, tokens )
);

let lsts-parse-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit( c"LEOF", with-location(mk-token("LEOF"),loc) );
   term = mk-app( term, mk-nil() );
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO List Comprehension at \{loc}")
   } else {
      if lsts-parse-head(tokens)!=c"]" {
         let add-items = [] : List<AST>;
         while non-zero(tokens) and lsts-parse-head(tokens)!=c"]" {
            let item-rest = lsts-parse-expression(tokens);
            tokens = item-rest.second;
            add-items = cons( item-rest.first, add-items );
            if non-zero(tokens) and lsts-parse-head(tokens)!=c"]" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
         for add-item in add-items {
            term = mk-app(
               Var( c"list::cons", with-location(mk-token("list::cons"),loc) ),
               mk-cons(add-item, term)
            );
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple ( term, tokens )
);

let lsts-parse-interface(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"interface", tokens); tokens = tail(tokens);

   let self-type = tv(c"self");
   (let interface-type, tokens) = lsts-parse-type(tokens);

   if lsts-parse-head(tokens)==c"implements" {
      lsts-parse-expect(c"implements", tokens); tokens = tail(tokens);
      self-type = interface-type;
      (interface-type, tokens) = lsts-parse-type(tokens);
   };
   interface-index = interface-index.bind(interface-type.ground-tag-and-arity, true);
   interface-self-index = interface-self-index.bind(interface-type.ground-tag-and-arity, (self-type, interface-type));

   lsts-parse-expect(c"{", tokens); tokens = tail(tokens);

   while lsts-parse-head(tokens) == c"let" {
      lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);

      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) or lsts-parse-head(tokens)==c".", tokens);
      let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      if name == c"." {
         lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
         name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      };

      let sig = lsts-parse-function-signature(name, tokens, loc);
      tokens = sig.second;
      let args-type = sig.first.args-type;
      let args-list = sig.first.args-list;
      let return-type = sig.first.return-type;

      let shapes = interface-shape-index.lookup(interface-type.ground-tag-and-arity,[] : List<(CString,Type,Type)>);
      shapes = cons( (name, args-type, return-type), shapes );
      interface-shape-index = interface-shape-index.bind(interface-type.ground-tag-and-arity, shapes);

      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c";" {
      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   # ignored for now

   tokens
);

let lsts-parse-typedef(tokens: List<Token>): (AST, List<Token>) = (
   let loc = head(tokens).location;
   lsts-parse-expect(c"type", tokens); tokens = tail(tokens);
   let mode = c"=";
   let misc-type = ta;
   if lsts-parse-head(tokens)==c"opaque" {
      lsts-parse-expect(c"opaque", tokens); tokens = tail(tokens);
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"opaque";
      misc-type = misc-type && t0(c"OpaqueAlias");
   } else if lsts-parse-head(tokens)==c"alias" {
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"alias";
      misc-type = misc-type && t0(c"Alias");
   } else if lsts-parse-head(tokens)==c"phi" {
      lsts-parse-expect(c"phi", tokens); tokens = tail(tokens);
      misc-type = misc-type && t0(c"Phi");
   };
   lsts-parse-expect(c"[Typename]", lsts-is-enum-head(lsts-parse-head(tokens)) or lsts-parse-head(tokens).has-suffix(c"_ss"), tokens);
   let typename = lsts-parse-head(tokens); tokens = tail(tokens);
   if typename.has-suffix(c"_ss") then typename = typename.remove-suffix(c"_ss").get-or(c"");
   let lhs-type = if lsts-parse-head(tokens)==c"<" {
      let pars = [] : List<Type>;
      lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
      let pt = ta;
      if lsts-is-enum-head(lsts-parse-head(tokens)) or lsts-parse-head(tokens).has-suffix(c"_ss") {
         pt = tv(uuid());
         (let vt, tokens) = lsts-parse-type(tokens);
         pt = pt && vt;
      } else {
         (let v, tokens) = lsts-parse-identifier(tokens);
         pt = tv(v);
         if lsts-parse-head(tokens)==c":" {
            lsts-parse-expect(c":", tokens); tokens = tail(tokens);
            (let vt, tokens) = lsts-parse-type(tokens);
            pt = pt && vt;
         };
      };
      pars = cons(pt, pars);
      while lsts-parse-head(tokens)==c"," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         if lsts-is-enum-head(lsts-parse-head(tokens)) or lsts-parse-head(tokens).has-suffix(c"_ss") {
            pt = tv(uuid());
            (let vt, tokens) = lsts-parse-type(tokens);
            pt = pt && vt;
         } else {
            (let v, tokens) = lsts-parse-identifier(tokens);
            pt = tv(v);
            if lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               (let vt, tokens) = lsts-parse-type(tokens);
               pt = pt && vt;
            };
         };
         pars = cons(pt, pars);
      };
      lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      ts(typename, pars);
   } else t0(typename);
   let infers = mk-vector(type(Type));
   let impls = mk-vector(type(Type));
   let size = ta;
   let implied-phi = ta;
   while lsts-parse-head(tokens)==c":" or lsts-parse-head(tokens)==c"implies"
      or lsts-parse-head(tokens)==c"implements" or lsts-parse-head(tokens)==c"size"
      or lsts-parse-head(tokens)==c"suffix" or lsts-parse-head(tokens)==c"zero"
      or (lsts-parse-head(tokens)==c"implied" and lsts-parse-head(tail(tokens))==c"phi") {
      if (lsts-parse-head(tokens)==c"implied" and lsts-parse-head(tail(tokens))==c"phi") {
         lsts-parse-expect(c"implied", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"phi", tokens); tokens = tail(tokens);
         (let mt, tokens) = lsts-parse-type(tokens);
         implied-phi = implied-phi && mt;
         implied-phi-index = implied-phi-index.bind(lhs-type.ground-tag-and-arity, mt);
      };
      if lsts-parse-head(tokens)==c":" {
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         (let mt, tokens) = lsts-parse-type(tokens);
         misc-type = misc-type && mt;
      };
      if lsts-parse-head(tokens)==c"suffix" {
         lsts-parse-expect(c"suffix", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"[Suffix]", lsts-parse-head(tokens).has-prefix(c"_"), tokens);
         let sfx = lsts-parse-head(tokens); tokens = tail(tokens);
         parse-suffixes = cons( (sfx, lhs-type && t0(c"Constant") && t0(c"Literal")), parse-suffixes );
      };
      if lsts-parse-head(tokens)==c"zero" {
         lsts-parse-expect(c"zero", tokens); tokens = tail(tokens);
         if not(non-zero(tokens)) or not(lsts-is-lit-head(lsts-parse-head(tokens))) {
            lsts-parse-expect(c"[Type Constructor]", tokens);
         };
         let constructor = head(tokens); tokens = tail(tokens);
         ast-parsed-program = ast-parsed-program + mk-app(
            Var( c"macro::define-zero", with-key(constructor, c"macro::define-zero") ),
            mk-cons(
               mk-cons(
                  AType( lhs-type ),
                  Lit( constructor.key, constructor )
               ),
               Lit( c"Tag::"+constructor.key, with-key(constructor, c"Tag::"+constructor.key) )
            )
         );
      };
      if lsts-parse-head(tokens)==c"size" {
         lsts-parse-expect(c"size", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"[Size]", lsts-parse-head(tokens).has-suffix(c"_B")
                                   or lsts-parse-head(tokens).has-suffix(c"_b"), tokens);
         let sz = lsts-parse-head(tokens); tokens = tail(tokens);
         if sz.has-suffix(c"_B") then size = t1(c"Bytes", t0(sz.remove-suffix(c"_B").get-or(c"")))
                                 else size = t1(c"Bits", t0(sz.remove-suffix(c"_b").get-or(c"")));
      };
      if lsts-parse-head(tokens)==c"implements" {
         lsts-parse-expect(c"implements", tokens); tokens = tail(tokens);
         (let i, tokens) = lsts-parse-type(tokens);
         impls = impls.push(i);
         while lsts-parse-head(tokens)==c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            (i, tokens) = lsts-parse-type(tokens);
            impls = impls.push(i);
         }
      };
      if lsts-parse-head(tokens)==c"implies" {
         lsts-parse-expect(c"implies", tokens); tokens = tail(tokens);
         (let i, tokens) = lsts-parse-type(tokens);
         if not(config-v3) and (i.is-t(c"MustRetain",0) or i.is-t(c"MustRelease",0)) then ()
         else infers = infers.push(i);
         while lsts-parse-head(tokens)==c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            (i, tokens) = lsts-parse-type(tokens);
            if not(config-v3) and (i.is-t(c"MustRetain",0) or i.is-t(c"MustRelease",0)) then ()
            else infers = infers.push(i);
         }
      };
   };
   for i in infers {
      if i.is-t(c"MustRelease",0) and not(implied-phi.slot(c"MustRelease::ToRelease",1).l1.is-t(c"Linear",1))
      then {
         let mt = t1(c"MustRelease::ToRelease",t1(c"Linear",t0(c"Phi::Live")));
         implied-phi = implied-phi && mt;
         implied-phi-index = implied-phi-index.bind(lhs-type.ground-tag-and-arity, mt);
      };
   };
   let cases = mk-vector(type( (CString,Vector<(CString,Type)>) ));
   let alias = ta;
   let opaque-alias = ta;
   if lsts-parse-head(tokens)==c"=" {
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      if mode==c"opaque" {
         (opaque-alias, tokens) = lsts-parse-type(tokens);
      } else if mode==c"alias" {
         (alias, tokens) = lsts-parse-type(tokens);
      } else {
         if lsts-parse-head(tokens)==c"|" { tokens = tail(tokens); };
         if lsts-parse-head(tokens)==c"{" {
            (let row, tokens) = lsts-parse-typedef-case-body(tokens);
            cases = cases.push((c"", row));
            if lsts-parse-head(tokens)==c"|" { tokens = tail(tokens); };
         };
         if lsts-parse-head(tokens)!=c";" {
            lsts-parse-expect(c"[Tag]", lsts-is-enum-head(lsts-parse-head(tokens)), tokens);
            let row-tag = head(tokens).key; tokens = tail(tokens);
            (let row, tokens) = lsts-parse-typedef-case-body(tokens);
            cases = cases.push((row-tag, row));
            while lsts-parse-head(tokens)==c"|" {
               lsts-parse-expect(c"|", tokens); tokens = tail(tokens);
               lsts-parse-expect(c"[Tag]", lsts-is-enum-head(lsts-parse-head(tokens)), tokens);
               row-tag = head(tokens).key; tokens = tail(tokens);
               (row, tokens) = lsts-parse-typedef-case-body(tokens);
               cases = cases.push((row-tag, row));
            };
         };
      }
   };
   let td = mk-typedef(loc, lhs-type).with-implies(infers).with-implements(impls)
            .with-size(size).with-alias(alias).with-opaque-alias(opaque-alias)
            .with-cases(cases).with-misc(misc-type).with-implied-phi(implied-phi);
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   if misc-type.is-t(c"Phi",0) then infer-type-definition(td);
   (td, tokens);
);

let lsts-parse-typedef-case-body(tokens: List<Token>): (Vector<(CString, Type)>, List<Token>) = (
   let fields = mk-vector(type((CString, Type)));
   if lsts-parse-head(tokens)==c"{" {
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c"}" {
         (let field-name, tokens) = lsts-parse-identifier(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         (let field-type, tokens) = lsts-parse-type(tokens);
         fields = fields.push( (field-name, field-type) );
         while lsts-parse-head(tokens)==c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            (field-name, tokens) = lsts-parse-identifier(tokens);
            lsts-parse-expect(c":", tokens); tokens = tail(tokens);
            (field-type, tokens) = lsts-parse-type(tokens);
            fields = fields.push( (field-name, field-type) );
         };
      };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   };
   (fields, tokens)
);

type LstsFnSignature = { args-list: AST, args-type: Type, return-type: Type };

# parses:    (a: I32, b: I32): U64
let lsts-parse-function-signature(fname: CString, tokens: List<Token>, loc: SourceLocation): Tuple<LstsFnSignature, List<Token>> = (
   let out = LstsFnSignature ( mk-nil(), ta, ta );

   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   out.args-type = t0(c"Nil");
   while non-zero(tokens) and lsts-parse-head(tokens)!=c")" {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      let arg-name = head(tokens); tokens = tail(tokens);
      let had-type = false;
      let arg-type = ta;
      if lsts-parse-head(tokens)==c":" {
         had-type = true;
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         (arg-type, tokens) = lsts-parse-type(tokens);
         if fname!=c"phi" then arg-type = phi-as-state(arg-type);
      };
      if lsts-parse-head(tokens)==c"," { tokens = tail(tokens); } else { lsts-parse-expect(c")", tokens); };
      let arg-binding = if had-type then mk-cons(
         Lit( c":", with-location(mk-token(":"),loc) ),
         mk-cons(mk-var(arg-name), mk-atype(arg-type))
      ) else mk-var(arg-name);
      if is( out.args-list, mk-nil() ) {
         out.args-list = arg-binding;
         out.args-type = arg-type;
      } else {
         out.args-list = mk-cons(out.args-list, arg-binding);
         out.args-type = t2(c"Cons", out.args-type, arg-type);
      };
   };
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c":" {
       lsts-parse-expect(c":", tokens); tokens = tail(tokens);
       let rtype-rest = lsts-parse-type(tokens);
       out.return-type = rtype-rest.first;
       if fname!=c"phi" then out.return-type = phi-as-state(out.return-type);
       tokens = rtype-rest.second;
   } else if non-zero(out.args-type) {
       out.return-type = t0(c"Nil");
   };

   Tuple ( out, tokens )
);

let lsts-parse-let(tokens: List<Token>): (AST, List<Token>) = (
   lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let prop = 0;
   if lsts-parse-head(tokens)==c"prop" {
      prop = 1;
      lsts-parse-expect(c"prop", tokens); tokens = tail(tokens);
   };
   let misc-tt = ta;
   if lsts-parse-head(tokens)==c":" {
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      (misc-tt, tokens) = lsts-parse-type(tokens);
   };
   lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) or lsts-parse-head(tokens)==c".", tokens);
   let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   if name == c"." {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   };
   let args-list = mk-eof();
   let return-type = ta;
   if lsts-parse-head(tokens) == c"(" {
      let sig = lsts-parse-function-signature(name, tokens, loc);
      tokens = sig.second;
      args-list = sig.first.args-list;
      return-type = sig.first.return-type;
   };
   let return-term = mk-nil();
   if lsts-parse-head(tokens) == c"=" {
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      (return-term, tokens) = lsts-parse-small-expression(tokens);
   };
   if non-zero(args-list) {
      return-term = mk-cons(
         Lit( c":", with-location(mk-token(":"),loc) ),
         mk-cons(return-term, mk-atype(return-type))
      );
   };
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   let rvalue = if non-zero(args-list) {
      let attach-tt = if prop { t0(c"Prop") } else { ta };
      if name==c"quick-prop" {
         match args-list {
            App{ left:Lit{key:c":"}, right:App{right:AType{ pre=tt }} } => (
               add-quick-prop(pre, ta, return-type);
               ASTNil;
            );
            _ => (
               print("Malformed quick-prop Argument List at \{loc}\n");
               exit(1);
               ASTNil;
            );
         };
      } else {
         mk-glb( with-location(mk-token(name),loc), mk-abs(
            args-list, return-term, misc-tt && attach-tt
         ) );
      };
   } else {
      mk-glb( with-location(mk-token(name),loc), return-term );
   };
   if not(config-v3) and (name==c".retain" or name==c".release") then rvalue = mk-nil();
   (rvalue, tokens)
);

type ASTOrIdent = ASTOrIdentAST { ast: AST }
                 | ASTOrIdentId  { id: AST }
                 | ASTOrIdentIgnore
                 ;

let lsts-parse-small-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = mk-eof();
   match tokens {
      [Token{key:c"if"}.. Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens); tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let expr-rest = lsts-parse-small-expression(tokens); tokens = expr-rest.second;
         let matched-rest = if lsts-parse-head(tokens)==c"{" {
            lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
            let matched-rest = lsts-parse-expression(tokens); tokens = matched-rest.second;
            lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            Tuple( matched-rest.first, tokens )
         } else {
            lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens)==c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let matched-rest = lsts-parse-expression(tokens); tokens = matched-rest.second;
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               Tuple( matched-rest.first, tokens )
            } else {
               let matched-rest = lsts-parse-small-expression(tokens); tokens = matched-rest.second;
               matched-rest;
            }
         };
         if lsts-parse-head(tokens)==c";" and lsts-parse-head(tail(tokens))==c"else" then tokens = tail(tokens);
         let default-rest = if lsts-parse-head(tokens) == c"else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let false-expr = if lsts-parse-head(tokens) == c"}" then mk-nil() else {
                  let f-rest = lsts-parse-expression(tokens);
                  tokens = f-rest.second;
                  f-rest.first;
               };
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               false-expr;
            } else {
               let f-rest = lsts-parse-small-expression(tokens);
               tokens = f-rest.second;
               f-rest.first;
            };
         } else mk-nil();
         let cases = mk-cons(mk-nil(), mk-cons(lhs-rest.first, matched-rest.first));
         if non-zero(default-rest) {
            cases = mk-cons(cases, mk-cons(
               Var( c"_", with-location(mk-token(c"_"),loc) ),
               default-rest
            ));
         };
         base = mk-cons(
            mk-cons(
               Var( c"match", with-location(mk-token("match"),loc) ),
               expr-rest.first
            ),
            cases
         );
      );
      [Token{key:c"if"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let c-rest = lsts-parse-ascript(tokens);
         let c = c-rest.first;
         tokens = c-rest.second;
         if lsts-parse-head(tokens) != c"{" {
            lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
         };
         let t = if lsts-parse-head(tokens) == c"{" {
            lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
            let true-expr = if lsts-parse-head(tokens) == c"}" then mk-nil() else {
               let t-rest = lsts-parse-expression(tokens);
               tokens = t-rest.second;
               t-rest.first;
            };
            lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            true-expr;
         } else {
            let t-rest = lsts-parse-assign(tokens);
            tokens = t-rest.second;
            t-rest.first;
         };
         let f = mk-nil();
         if lsts-parse-head(tokens)==c";" and lsts-parse-head(tail(tokens))==c"else" then tokens = tail(tokens);
         if lsts-parse-head(tokens) == "else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            f = if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let false-expr = if lsts-parse-head(tokens) == c"}" then mk-nil() else {
                  let f-rest = lsts-parse-expression(tokens);
                  tokens = f-rest.second;
                  f-rest.first;
               };
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               false-expr;
            } else {
               let f-rest = lsts-parse-small-expression(tokens);
               tokens = f-rest.second;
               f-rest.first;
            };
         };
         base = mk-app(
            mk-app(
               mk-app(
                  Var( c"if", with-location(mk-token("if"),loc) ),
                  c
               ),
               mk-app(
                  Var( c"scope", with-location(mk-token("scope"),loc) ),
                  t
               )
            ),
            mk-app(
               Var( c"scope", with-location(mk-token("scope"),loc) ),
               f
            )
         );
      );
      [Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = mk-app(
            mk-var(with-location(mk-token("macro::let"),loc)),
            mk-cons(lhs-rest.first, rhs-rest.first)
         );
      );
      _ => (
         let assign-rest = lsts-parse-assign(tokens);
         base = assign-rest.first;
         tokens = assign-rest.second;
      );
   };
   Tuple ( base, tokens )
);

let lsts-parse-match2-lhs-one(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let expr = mk-eof();
   if lsts-parse-head(tokens)==c"[" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
      expr = mk-app(mk-var(c"macro::lhs-tail").with-location(loc), mk-nil());
      let seq = [] : List<AST>;
      while non-zero(tokens) and lsts-parse-head(tokens)!=c"]" {
         (let head, tokens) = lsts-parse-match2-lhs-one-bind(tokens);
         if lsts-parse-head(tokens)==c"." and lsts-parse-head(tail(tokens))==c"." {
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            seq = cons(head, seq);
         } else {
            lsts-parse-expect(c"]", tokens);
            expr = head;
         }
      };
      for s in seq {
         expr = mk-app( mk-var(c"macro::lhs-head"), mk-cons(s,expr) );
      };
      lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   } else if lsts-parse-head(tokens)==c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      (expr, tokens) = lsts-parse-match2-lhs-one-bind(tokens);
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
   } else if lsts-parse-head(tokens)==c"uuid" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"uuid", tokens); tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      (let name, tokens) = lsts-parse-identifier(tokens);
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      expr = mk-app( mk-var(c"uuid").with-location(loc), mk-var(name).with-location(loc) );
   } else if lsts-parse-head(tokens).is-lsts-constant {
      expr = lsts-make-lit(head(tokens)); tokens = tail(tokens);
   } else if lsts-is-enum-head(lsts-parse-head(tokens)) or (lsts-parse-head(tokens)==c"_" and lsts-parse-head(tail(tokens))==c"{") {
      let loc = head(tokens).location;
      let tag = lsts-parse-head(tokens); tokens = tail(tokens);
      let suffix-condition = mk-var(c"_").with-location(loc);
      if lsts-parse-head(tokens)==c"{" {
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         while non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
            let mode = c"macro::let-name";
            if lsts-parse-head(tokens)==c"set" { mode = c"macro::set-name"; tokens = tail(tokens) }
            else if lsts-parse-head(tokens)==c"let" { mode = c"macro::let-name"; tokens = tail(tokens) };
            let raw = false;
            if lsts-parse-head(tokens)==c"raw" { raw = true; tokens = tail(tokens) };
            let bind-name = c"_";
            (let field-name, tokens) = lsts-parse-identifier(tokens);
            if lsts-parse-head(tokens)==c"=" {
               lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
               bind-name = field-name;
               (field-name, tokens) = lsts-parse-identifier(tokens);
            };
            let val = if lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               (let val, tokens) = lsts-parse-match2-lhs-one(tokens);
               val
            } else {
               mk-var(c"_").with-location(loc)
            };
            let bind = if bind-name==c"_" then mk-var(bind-name).with-location(loc)
            else mk-app( mk-var(mode), mk-var(bind-name).with-location(loc) );
            let new-cond = if raw {
               mk-app( mk-var(c"macro::lhs-raw-struct-field"), mk-cons(
                  mk-cons(
                     bind,
                     mk-var(field-name)
                  ),
                  val
               ));
            } else {
               mk-app( mk-var(c"macro::lhs-struct-field"), mk-cons(
                  mk-cons(
                     bind,
                     mk-var(field-name)
                  ),
                  val
               ));
            };
            suffix-condition = mk-app( mk-var(c"macro::lhs-struct"), mk-cons(new-cond, suffix-condition) );
            if lsts-parse-head(tokens)!=c"}" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            };
         };
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      };
      if tag == c"_" {
         expr = suffix-condition;
      } else {
         expr = mk-app(mk-var(c"macro::lhs-struct"), mk-cons( mk-lit(tag).with-location(loc), suffix-condition ));
      };
   } else if lsts-parse-head(tokens)==c"_" {
      expr = mk-var(c"_").with-location(head(tokens).location);
      lsts-parse-expect(c"_", tokens); tokens = tail(tokens);
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      (let name, tokens) = lsts-parse-identifier(tokens);
      expr = mk-var(name).with-location(head(tokens).location);
   } else {
      lsts-parse-expect(c"[Left Hand Side]", tokens);
   };
   (expr, tokens)
);

let lsts-parse-match2-lhs-one-bind(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if lsts-has-assign(tokens) {
      let mode = c"macro::let-bind";
      if lsts-parse-head(tokens)==c"set" { mode = c"macro::set-bind"; tokens = tail(tokens) }
      else if lsts-parse-head(tokens)==c"let" { mode = c"macro::let-bind"; tokens = tail(tokens) };
      (let name, tokens) = lsts-parse-identifier(tokens);
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      (let rest, tokens) = lsts-parse-match2-lhs-one(tokens);
      let expr = mk-app(mk-var(mode), mk-cons(rest, mk-var(name)));
      (expr, tokens)
   } else {
      lsts-parse-match2-lhs-one(tokens);
   }
);

let .is-assign-lit(t: AST): Bool = (
   match t {
      App{ left:Var{key:c"macro::let-bind"} } => true;
      App{ left:Var{key:c"macro::set-bind"} } => true;
      _ => false;
   }
);

let .is-lsts-constant(key: CString): Bool = (
      key.has-suffix(c"_ss")
   or key.has-suffix(c"_s")
   or key.has-suffix(c"_rgx")
   or key.has-suffix(c"_u8")
   or key.has-suffix(c"_u16")
   or key.has-suffix(c"_u32")
   or key.has-suffix(c"_u64")
   or key.has-suffix(c"_i8")
   or key.has-suffix(c"_i16")
   or key.has-suffix(c"_i32")
   or key.has-suffix(c"_i64");
);

let .is-constant(t: AST): Bool = (
   match t {
      App{ left:Lit{key:c":"}, right:App{ left:Lit{}, right:AType{} } } => true;
      Lit{key=key} => key.is-lsts-constant;
      Var{key=key} => key.is-lsts-constant;
      _ => false;
   }
);

let lsts-parse-match2-lhs(tokens: List<Token>): Tuple<AST,List<Token>> = (
   # prefixes
   # suffixes
   # list-likes
   # tuples
   # objects
   let original-tokens = tokens;
   (let lhs, tokens) = lsts-parse-match2-lhs-one-bind(tokens);
   let presufs = mk-vector(type(AST)).push(lhs);
   while lsts-parse-head(tokens)==c"." and lsts-parse-head(tail(tokens))==c"." {
      lsts-parse-expect(c".", tokens); tokens = tail(tokens);
      lsts-parse-expect(c".", tokens); tokens = tail(tokens);
      (lhs, tokens) = lsts-parse-match2-lhs-one-bind(tokens);
      presufs = presufs.push(lhs);
   };
   let prefixes = mk-vector(type(AST));
   let suffixes = mk-vector(type(AST));
   let starti = 0_u64;
   let endi = presufs.length - 1;
   while starti < endi and presufs[starti].is-constant or presufs[starti].is-assign-lit {
      prefixes = prefixes.push(presufs[starti]);
      starti = starti + 1;
   };
   while starti < endi and  presufs[endi].is-constant or presufs[endi].is-assign-lit {
      suffixes = suffixes.push(presufs[endi]);
      endi = endi - 1;
   };
   if endi != starti then {
      fail("Invalid Prefix/Suffix Chain", original-tokens.formatted-location);
   };
   lhs = presufs[starti];
   for p in prefixes {
      lhs = mk-app(mk-var(c"macro::lhs-prefix"), mk-cons(p, lhs));
   };
   while suffixes.length > 0 {
      (let p, suffixes) = suffixes.pop();
      lhs = mk-app(mk-var(c"macro::lhs-suffix"), mk-cons(p, lhs));
   };
   if lsts-parse-head(tokens)==c"where" {
      lsts-parse-expect(c"where", tokens); tokens = tail(tokens);
      (let cond, tokens) = lsts-parse-ascript(tokens);
      lhs = mk-app( mk-var(c"macro::lhs-guard"), mk-cons(lhs,cond) );
   };
   (lhs, tokens)
);

let lsts-parse-match2(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let loc = head(tokens).location;
   lsts-parse-expect(c"match2", tokens); tokens = tail(tokens);
   let raw = lsts-parse-head(tokens)==c"raw"; if raw { tokens = tail(tokens); };
   (let expr, tokens) = lsts-parse-small-expression(tokens);
   if raw then expr = mk-app(mk-var(c"macro::bind-raw"), expr);
   let case-root = mk-app(mk-var(c"fail"),mk-cons(
      mk-lit(c"Pattern Match Failure").ascript(t0(c"String") && t0(c"Literal")),
      mk-app(mk-var(c"macro::location"),mk-var(c"here").with-location(loc))
   ));
   lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
   let cases = [] : List<(AST,AST)>;
   while non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
      (let lhs, tokens) = lsts-parse-match2-lhs(tokens);
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      if lsts-parse-head(tokens) == c"{" {
         fail("Please wrap map literals in match cases in parenthesis. At \{tokens.formatted-location}\n");
      };
      (let rhs, tokens) = lsts-parse-small-expression(tokens);
      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
      cases = cons( (lhs,rhs), cases );
   };
   for Tuple{lhs=first,rhs=second} in cases {
      case-root = mk-app(
         mk-var(c"macro::match-case"),
         mk-cons(mk-cons(lhs,rhs),case-root)
      );
   };
   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   let result-expr = mk-app(mk-var(c"macro::match"), mk-cons(expr, case-root));
   (result-expr, tokens);
);

let lsts-parse-assign(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = mk-eof();
   if lsts-has-assign(tokens) {
      let loc = head(tokens).location;

      if lsts-parse-head(tokens) == c"(" {
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);

         let lefts = [] : List<ASTOrIdent>;

         let loop = true;
         while loop {
            match lsts-parse-head(tokens) {
               c"_" => (
                  tokens = tail(tokens);
                  lefts = cons(ASTOrIdentIgnore(), lefts);
               );

               c"let" => (
                  tokens = tail(tokens);
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentId ( lhs.first ), lefts);
               );

               hd => (
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentAST ( lhs.first ), lefts);
               );
            };

            if lsts-parse-head(tokens) == c"," {
               tokens = tail(tokens);
            } else {
               loop = false;
            };
         };

         lsts-parse-expect(c")", tokens); tokens = tail(tokens);

         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         let rhs-tmp-name = uuid();
         let rhs-tmp = Var( rhs-tmp-name, with-location(mk-token(rhs-tmp-name),loc) );
         base = mk-app(
            Var( c"macro::let", with-location(mk-token(c"macro::let"),loc) ),
            mk-cons( rhs-tmp, rhs-rest.first )
         );

         let i = 0_u64;
         for lhs in lefts {
            let fieldstr = c"." + to-string(i+1);
            let rexpr = mk-app(
               Var( fieldstr, with-location(mk-token(fieldstr),loc) ),
               rhs-tmp
            );

            match lhs {
               ASTOrIdentIgnore {} => ();

               ASTOrIdentAST { ast=ast } => (
                  let x = mk-app(
                     Var( c"macro::set", with-location(mk-token("macro::set"),loc) ),
                     mk-cons(ast, rexpr)
                  );
                  base = mk-cons(base, x);
               );

               ASTOrIdentId { id=id } => (
                  let x = mk-app(
                     Var( c"macro::let", with-location(mk-token("macro::let"),loc) ),
                     mk-cons( id, rexpr )
                  );
                  base = mk-cons(base, x);
               );
            };
            i = i + 1;
         };
      } else {
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = mk-app(
            Var( c"macro::set", with-location(mk-token("macro::set"),loc) ),
            mk-cons(
               lhs-rest.first,
               rhs-rest.first
            )
         );
      };
   } else {
      let base-rest = lsts-parse-ascript(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
   };
   Tuple ( base, tokens )
);

let lsts-make-lit(t: Token): AST = (
   let loc = t.location;
   let base = Lit ( t.key, t );
   if t.key.has-suffix(c"_ss") and t.key.contains(c"\\{") {
      let s = t.key;
      base = mk-eof();
      let buffer = SNil();
      while non-zero(s) and s != c"_ss" {
         if s.has-prefix(c"\\{") {
            if non-zero(buffer) {
               let be = mk-lit(with-location(mk-token(clone-rope(buffer)),loc)).ascript(t0(c"String") && t0(c"Literal"));
               if non-zero(base) {
                  base = mk-app(
                     Var( c"+", with-location(mk-token("+"),loc) ),
                     mk-cons(base, be)
                  );
               } else { base = be; };
               buffer = SNil();
            };

            s = s.remove-prefix(c"\\{").get-or(c"");
            let t-buffer = SNil();
            while non-zero(s) and not(s.has-prefix(c"}")) {
               t-buffer = t-buffer + SAtom(clone-rope(head(s)));
               s = tail(s);
            };
            if non-zero(s) and s.has-prefix(c"}") {
               s = tail(s);
            };
            let sub-tokens = lsts-tokenize-string(c"[Format String]", clone-rope(t-buffer));
            let se-rest = lsts-parse-expression(sub-tokens);
            let se = mk-app(
               Var( c".into", with-location(mk-token(".into"),loc) ),
               mk-cons(
                  se-rest.first,
                  mk-atype(t1(c"Type",t0(c"String")))
               )
            );
            if non-zero(base) {
               base = mk-app(
                  Var( c"+", with-location(mk-token("+"),loc) ),
                  mk-cons(base, se)
               );
            } else {
               base = se;
            };
            if non-zero(se-rest.second) {
               lsts-parse-expect(c"[EOF]", se-rest.second);
            }
         } else {
            buffer = buffer + SAtom (clone-rope(head(s)));
            s = tail(s);
         }
      };
      if non-zero(buffer) {
         let be = mk-lit(with-location(mk-token(clone-rope(buffer)),loc)).ascript(t0(c"String") && t0(c"Literal"));
         if non-zero(base) {
            base = mk-app(
               Var( c"+", with-location(mk-token("+"),loc) ),
               mk-cons(base, be)
            );
         } else {
            base = be;
         };
      };
   } else if t.key.has-suffix(c"_ss") {
      base = mk-lit(t.key.remove-suffix(c"_ss").get-or(c"")).with-location(loc).ascript(t0(c"String") && t0(c"Literal"));
   };
   base
);

let lsts-parse-lhs-one(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = if lsts-parse-head(tokens)==c"uuid" {
      let u = head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let base-rest = lsts-parse-lhs-one(tokens);
      tokens = base-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      mk-cons( Var( u.key, u ), base-rest.first );
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let base-rest = lsts-make-maybe-var(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens); tokens = tail(tokens);
      let base-rest = lsts-parse-lhs-one(tokens);
      tokens = base-rest.second;
      mk-cons(
         Var( amp.key, amp ),
         base-rest.first
      );
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let base-rest = lsts-parse-lit(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if non-zero(tokens) and lsts-parse-head(tokens)==c"[" {
      let base-rest = lsts-parse-lhs-list(tokens);
      tokens = base-rest.second;
      base-rest.first; 
   } else if non-zero(tokens) and lsts-parse-head(tail(tokens))==c"{" {
      let loc = head(tokens).location;
      let tag = lsts-parse-head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      let des-args = mk-eof();
      while non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
         let attr-loc = head(tokens).location;
         let binding = c"";
         let attr-key = c"";
         let raw = false;
         if lsts-parse-head(tokens) == c"raw" {
            raw = true; tokens = tail(tokens);
         };
         if lsts-is-ident-head(lsts-parse-head(tokens)) {
            attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
         };
         if lsts-parse-head(tokens)==c"=" {
            binding = attr-key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"raw" {
               raw = true; tokens = tail(tokens);
            };
            if lsts-is-ident-head(lsts-parse-head(tokens)) {
               attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
            } else { lsts-parse-expect(c"[Identifier]", tokens); };
         };
         let val = if lsts-parse-head(tokens)==c":" {
            tokens = tail(tokens);
            let val-rest = lsts-parse-lhs-one(tokens);
            tokens = val-rest.second;
            val-rest.first;
         } else { mk-eof() };
         if not(non-zero(val)) and not(non-zero(binding)) and not(non-zero(attr-key)) {
            lsts-parse-expect(c"[Struct LHS]", tokens); tokens = tail(tokens);
         };
         if not(non-zero(val)) {
            val = Var( c"_", with-location(mk-token("_"),attr-loc) );
         };
         if non-zero(binding) {
            val = mk-app(
               Var( c"@", with-location(mk-token("@"),attr-loc) ),
               mk-cons(
                  Var( binding, with-location(mk-token(binding),attr-loc) ),
                  val
               )
            );
            if raw {
               val = mk-app(
                  Var( c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),attr-loc) ),
                  val
               );
            };
         };
         if non-zero(attr-key) {
            attr-key = c"." + attr-key;
            val = mk-app(
               Var( c"macro::bind-field-by-key", with-location(mk-token("macro::bind-field-by-key"),attr-loc) ),
               mk-cons(
                  Var( attr-key, with-location(mk-token(attr-key),attr-loc) ),
                  val
               )
            );
         };
         if non-zero(des-args) {
            des-args = mk-cons(des-args, val);
         } else { des-args = val; };
         if lsts-parse-head(tokens) != c"}" {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         };
      };
      if not(non-zero(des-args)) { des-args = mk-nil(); };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      mk-app(
         Lit( tag, with-location(mk-token(tag),loc) ),
         des-args
      );
   } else {
      lsts-parse-expect(c"[Left Hand Side]", tokens);
      mk-eof()
   };
   Tuple ( base, tokens )
);

let lsts-parse-lit(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let loc = head(tokens).location;
   let term = mk-eof();
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      while lsts-parse-head(tokens).has-suffix(c"_ss") {
         let cat = lsts-make-lit(head(tokens));
         tokens = tail(tokens);
         if non-zero(term) {
            term = mk-app(
               Var( c"+", with-location(mk-token("+"),loc) ),
               mk-cons(term, cat)
            );
         } else { term = cat; };
      }
   } else {
      term = lsts-make-lit(head(tokens));
      tokens = tail(tokens);
   };
   Tuple ( term, tokens )
);

let lsts-parse-atom-without-tail(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term = mk-eof();
   if lsts-parse-head(tokens)==c"type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType( t1(c"Type", phi-as-state(term-rest.first)) );
   } else if lsts-parse-head(tokens)==c"raw-type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType( term-rest.first );
   } else if lsts-parse-head(tokens)==c"for" {
      let loc = head(tokens).location; tokens = tail(tokens);
      let list = false;
      if lsts-parse-head(tokens)==c"list" then { tokens = tail(tokens); list = true; };
      if lsts-parse-head(tokens)==c"vector" then { tokens = tail(tokens); list = false; };
      let lhs-rest = lsts-parse-lhs(tokens);
      tokens = lhs-rest.second;
      lsts-parse-expect(c"in", tokens); tokens = tail(tokens);
      let iter-rest = lsts-parse-small-expression(tokens);
      tokens = iter-rest.second;
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      let rhs = mk-nil();
      if lsts-parse-head(tokens) != c"}" {
         let rhs-rest = lsts-parse-expression(tokens);
         rhs = rhs-rest.first;
         tokens = rhs-rest.second;
      };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      if list {
         term = mk-app(
            mk-app(
               Var( c"for-each-list", with-location(mk-token("for-each-list"),loc) ),
               mk-cons(
                  mk-cons(
                     lhs-rest.first,
                     Var( c"in", with-location(mk-token("in"),loc) )
                  ),
                  iter-rest.first
               )
            ),
            mk-app(
               Var( c"scope", with-location(mk-token("scope"),loc) ),
               rhs
            )
         );
      } else {
         term = mk-app(
            mk-app(
               Var( c"for-each", with-location(mk-token("for-each"),loc) ),
               mk-cons(
                  mk-cons(
                     lhs-rest.first,
                     Var( c"in", with-location(mk-token("in"),loc) )
                  ),
                  iter-rest.first
               )
            ),
            mk-app(
               Var( c"scope", with-location(mk-token("scope"),loc) ),
               rhs
            )
         );
      }         
   } else if lsts-parse-head(tokens)==c"while" {
      let loc = head(tokens).location; tokens = tail(tokens);
      let c-rest = lsts-parse-small-expression(tokens);
      tokens = c-rest.second;
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      let rhs-rest = lsts-parse-expression(tokens);
      tokens = rhs-rest.second;
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      term = mk-app(
         mk-app(
            Var( c"while", with-location(mk-token("while"),loc) ),
            c-rest.first
         ),
         mk-app(
            Var( c"scope", with-location(mk-token("scope"),loc) ),
            rhs-rest.first
         )
      );         
   } else if lsts-parse-head(tokens)==c"match2" {
      (term, tokens) = lsts-parse-match2(tokens);
   } else if lsts-parse-head(tokens)==c"match" {
      let loc = head(tokens).location; tokens = tail(tokens);
      let raw = if lsts-parse-head(tokens)==c"raw" {
         tokens = tail(tokens); true;
      } else false;
      let e-rest = lsts-parse-small-expression(tokens);
      tokens = e-rest.second;
      if raw {
         e-rest.first = mk-app(
            Var( c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),loc) ),
            e-rest.first
         );
      };
      let pats = mk-nil();
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      while non-zero(tokens) and lsts-parse-head(tokens)!=c"}" {
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens) == c"{" {
            fail("Please wrap map literals in match cases in parenthesis. At \{tokens.formatted-location}\n");
         };
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         lsts-parse-expect(c";", tokens); tokens = tail(tokens);
         pats = mk-cons(pats, mk-cons(lhs-rest.first, rhs-rest.first));
      };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      term = mk-app(
         mk-app(
            Var( c"match", with-location(mk-token("match"),loc) ),
            e-rest.first
         ),
         pats
      );
   } else if lsts-parse-head(tokens).has-suffix(c"_ss") {
      (term, tokens) = lsts-parse-lit(tokens);
   } else if lsts-parse-head(tokens).has-suffix(c"_rl") {
      term = mk-lit(lsts-parse-head(tokens).remove-suffix(c"_rl").get-or(c""));
      tokens = tail(tokens);
   } else if lsts-parse-head(tokens)==c"unsafe" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"unsafe", tokens); tokens = tail(tokens);
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      (term, tokens) = lsts-parse-expression(tokens);
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      term = mk-app(
         Var( c"unsafe", with-location(mk-token(c"unsafe"),loc) ),
         term
      );
   } else if lsts-parse-head(tokens)==c"sizeof" {
      let loc = head(tokens).location;
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = mk-app(
         Var( c"sizeof", with-location(mk-token(c"sizeof"),loc) ),
         mk-atype(term-rest.first)
      );
   } else if lsts-parse-head(tokens)==c"fn" {
      lsts-parse-expect(c"fn", tokens); let loc = head(tokens).location; tokens = tail(tokens);
      let misc-type = ta;
      if lsts-parse-head(tokens)==c":" {
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         (misc-type, tokens) = lsts-parse-type(tokens);
      };
      let rec-id = c"";
      if lsts-parse-head(tokens)!=c"(" then (rec-id, tokens) = lsts-parse-identifier(tokens);
      (let func-sig, tokens) = lsts-parse-function-signature(rec-id, tokens, loc);
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      (let rhs, tokens) = lsts-parse-small-expression(tokens);
      if non-zero(func-sig.return-type) then rhs = mk-app(mk-lit(c":"), mk-cons(rhs, mk-atype(func-sig.return-type)));
      term = mk-abs(func-sig.args-list, rhs, misc-type);
   } else if lsts-parse-head(tokens)==c"~" {
      let amp = head(tokens);
      tokens = tail(tokens);
      (let inner-term, tokens) = lsts-parse-atom-without-tail(tokens);
      term = mk-app(
         Var( amp.key, amp ),
         inner-term
      );
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens);
      tokens = tail(tokens);
      let term-rest = lsts-parse-atom-without-tail(tokens);
      tokens = term-rest.second;
      term = mk-app(
         Var( amp.key, amp ),
         term-rest.first
      );
      term-rest = lsts-parse-atom-tail(term, tokens);
      term = term-rest.first;
      tokens = term-rest.second;
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let term-rest = lsts-make-maybe-var(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else if lsts-parse-head(tokens)==c"." and lsts-is-ident-head(lsts-parse-head(tail(tokens))) {
      let t = head(tokens).key + head(tail(tokens)).key;
      tokens = tail(tokens); tokens = tail(tokens);
      Tuple( Var( t, mk-token(t) ), tokens )
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let term-rest = lsts-parse-lit(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else match tokens {
      [Token{key:c"("}.. rest] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c")" {
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = mk-nil();
         } else {
            let term-rest = lsts-parse-expression-possibly-tuple(tokens);
            tokens = term-rest.second;
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = term-rest.first;
         }
      );
      [Token{key:c"["}.. rest] => (
         let term-rest = lsts-parse-list(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      [Token{key:c"{"}.. rest] => (
         let term-rest = lsts-parse-map(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      _ => (
         if lsts-is-enum-head(lsts-parse-head(tokens)) {
            let tag = head(tokens); tokens = tail(tokens);
            term = Lit ( tag.key, tag );
            if not(tag.key.contains(c"_")) and tag.key!=c"LEOF" and tag.key!=c"HashtableEqEOF" {
               term = mk-app(term, mk-nil());
            };
         } else {
            lsts-parse-expect(c"[Atom]", tokens);
         }
      );
   };
   Tuple ( term, tokens );
);

let lsts-parse-atom(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let atom-rest = lsts-parse-atom-without-tail(tokens);
   lsts-parse-atom-tail(atom-rest.first,atom-rest.second);
);

let lsts-parse-atom-tail(base: AST, tokens: List<Token>): Tuple<AST,List<Token>> = (
   while lsts-parse-head(tokens) == c"[" or
         lsts-parse-head(tokens) == c"(" or
         lsts-parse-head(tokens) == c"." or
         lsts-parse-head(tokens) == c"as" {
      let loc = head(tokens).location;
      match tokens {
         [Token{key:"."}.. rest] => (
            tokens = rest;
            lsts-parse-expect( c"[Identifier]", lsts-is-ident-head(lsts-parse-head(tokens)), tokens );
            let method = c"." + head(tokens).key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"(" {
               lsts-parse-expect( c"(", tokens ); tokens = tail(tokens);
               while non-zero(tokens) and lsts-parse-head(tokens)!=c")" {
                  let next-rest = lsts-parse-expression(tokens);
                  tokens = next-rest.second;
                  if non-zero(tokens) and lsts-parse-head(tokens)==c"," {
                     tokens = tail(tokens);
                  } else {
                     lsts-parse-expect( c")", tokens );
                  };
                  base = mk-cons(base, next-rest.first);
               };
               lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
            };
            base = mk-app(
               Var( method, with-location(mk-token(method),loc) ),
               base
            );
         );
         [Token{key:"as"}.. rest] => (
            tokens = rest;
            let type-rest = lsts-parse-type(tokens); 
            tokens = type-rest.second;
            base = mk-app(
               Var( c"as", with-location(mk-token("as"),loc) ),
               mk-cons(base, mk-atype(phi-as-state(type-rest.first)))
            );
         );
         [Token{key:"["}.. rest] => (
            tokens = rest;
            let term1 = if lsts-parse-head(tokens)==c":" {
               Lit( c"0_i64", with-location(mk-token("0_i64"),loc) )
            } else {
               let term1-rest = lsts-parse-andor(tokens);
               tokens = term1-rest.second;
               term1-rest.first;
            };
            let term2 = mk-eof();
            if lsts-parse-head(tokens)==c":" {
               lsts-parse-expect( c":", tokens ); tokens = tail(tokens);
               term2 = if lsts-parse-head(tokens)==c"]" {
                  Var( c"minimum-I64", with-location(mk-token("minimum-I64"),loc) )
               } else {
                  let term2-rest = lsts-parse-andor(tokens);
                  tokens = term2-rest.second;
                  term2-rest.first;
               };
            };
            if non-zero(term2) {
               base = mk-app(
                  Var( c"[:]", with-location(mk-token("[:]"),loc) ),
                  mk-cons(mk-cons(base, term1), term2)
               );
            } else {
               base = mk-app(
                  Var( c"[]", with-location(mk-token("[:]"),loc) ),
                  mk-cons(base, term1)
               );
            };
            lsts-parse-expect( c"]", tokens ); tokens = tail(tokens);
         );
         [Token{key:"("}.. rest] => (
            tokens = rest;
            let args = if lsts-parse-head(tokens) == c")" {
               mk-nil();
            } else {
               let term2-rest = lsts-parse-expression(tokens);
               let term2 = term2-rest.first;
               tokens = term2-rest.second;
               while lsts-parse-head(tokens)==c"," {
                  tokens = tail(tokens);
                  let term3-rest = lsts-parse-expression(tokens);
                  tokens = term3-rest.second;
                  term2 = mk-cons(term2, term3-rest.first);
               };
               term2
            };
            base = match base {
               App{ constructor=left:Lit{}, right:ASTNil{} } => mk-app(constructor,args);
               App{ constructor=left:App{ left:Lit{key:c":"}, right:App{ left:Lit{}, right:AType{} } }, right:ASTNil{} } => mk-app(constructor,args);
                _ => mk-app(base,args);
            };
            lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
         );
      }
   };
   Tuple ( base, tokens )
);
