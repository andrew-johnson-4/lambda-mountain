
.text := (
   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   _strlen:                     \n
   \t xor %rbx, %rbx            \n
   _strlen_loop:                \n
   \t cmpb $0, 0\(%rax\)          \n
   \t jz _strlen_exit           \n
   \t inc %rax                  \n
   \t inc %rbx                  \n
   \t jmp _strlen_loop         \n
   _strlen_exit:                \n
   \t ret                       \n
   # result is stored in %rcx

   # print-i: print value of integer
   print_i:                     \n
   \t mov %r12, %r8             \n
   ::put64
   \t ret                       \n

   # print-p: print value from pointer
   print_p:                     \n
   \t mov 0\(%r12\), %r8        \n
   ::put64
   \t ret                       \n

   # print-s
   print_s:                     \n
   __print_this:                \n
   ::callee-save-registers
 
   # if .atom != NULL
   __print_this_atom:           \n
   \t cmp $0, %r12              \n
   \t je __print_this_cons      \n
   \t mov %r12, %rax            \n
   \t call _strlen              \n   # %rbx is length of string
   \t mov %r12, %rsi            \n   # address of string to output
   \t mov %rbx, %rdx            \n   # length is %rcx
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t syscall                   \n   # invoke operating system to do the write
   ::callee-restore-registers
   \t ret                       \n

   # if .head != NULL && .tail != NULL
   __print_this_cons:           \n
   \t cmp $0, %r13              \n
   \t je __print_this_nil       \n
   \t cmp $0, %r14              \n
   \t je __print_this_nil       \n
   ::push-this
   ::show-lparen
   \t mov %r13, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::pop-this
   ::show-space
   \t mov %r14, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::show-rparen
   ::callee-restore-registers
   \t ret                       \n

   __print_this_nil:            \n
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t mov $__nil_literal, %rsi  \n   # address of string to output
   \t mov $2, %rdx              \n   # nil is 2 bytes
   \t syscall                   \n   # invoke operating system to do the write
   ::callee-restore-registers
   \t ret                       \n

   head:                        \n
   \t cmp $0, %r13              \n
   \t je __head_is_nil          \n
   ::head
   \t ret                       \n
   __head_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   tail:                        \n
   \t cmp $0, %r14              \n
   \t je __tail_is_nil          \n
   ::tail
   \t ret                       \n
   __tail_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   not:                         \n
   ::callee-save-registers
   \t cmp $0, %r12              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r13              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r14              \n
   \t jne __not_is_some         \n
   ::callee-restore-registers
   (::yield-atom __true)
   \t ret                       \n
   __not_is_some:               \n
   ::callee-restore-registers
   ::yield-nil
   \t ret                       \n

   equal:                       \n
   \t cmp $0, %r13              \n
   \t je __equal_nil            \n
   \t cmp $0, %r14              \n
   \t je __equal_nil            \n
   \t mov 0\(%r13\), %rax         \n # mov x.atom into %rax
   \t mov 0\(%r14\), %rbx         \n # mov y.atom into %rbx
   \t cmp $0, %rax              \n
   \t je __equal_nil            \n
   \t cmp $0, %rbx              \n
   \t je __equal_nil            \n
   \t call _streq               \n
   \t ret                       \n
   __equal_nil:                 \n
   ::yield-nil
   \t ret                       \n

   inequal:                     \n
   \t call equal                \n
   \t call not                  \n
   \t ret                       \n

   # _streq (%rax: *char, %rbx: *char) -> 
   # internal, not a call-convention function
   _streq:                      \n
   __streq_loop:                \n
   \t cmp $0, %rax              \n
   \t je __streq_false          \n
   \t cmp $0, %rbx              \n
   \t je __streq_false          \n
   \t mov 0\(%rax\), %cl        \n
   \t mov 0\(%rbx\), %dl        \n

   \t cmp %cl, %dl              \n
   \t jne __streq_false         \n
   \t cmp $0, %cl               \n
   \t je __streq_true           \n
   \t inc %rax                  \n
   \t inc %rbx                  \n
   \t jmp __streq_loop          \n
   __streq_true:                \n
   ::yield-true
   \t ret                       \n
   __streq_false:               \n
   ::yield-nil
   \t ret                       \n


   clone_rope:                  \n
   \t mov $__a_section, %r8     \n
   \t mov $__a_counter, %r10    \n
   \t mov 0\(%r10\), %r11       \n
   \t add %r11, %r8             \n
   \t mov %r8, %r9              \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   \t call __clone_rope         \n
   \t movb $0, 0\(%r9\)         \n
   \t inc %r9                   \n
   \t sub %r8, %r9              \n
   \t mov $__a_counter, %r10    \n
   \t mov %r9, 0\(%r10\)        \n
   \t mov %r8, %r12             \n
   \t mov $0, %r13              \n
   \t mov $0, %r14              \n
   \t mov $0, %r15              \n
   \t ret                       \n

   __clone_rope:                \n
   #if this is a cons, recurse
   \t cmp $0, %r13              \n
   \t je clone_rope_notcons     \n
   \t cmp $0, %r14              \n
   \t je clone_rope_notcons     \n
   ::push-this
   ::head
   \t call __clone_rope         \n
   ::pop-this
   ::tail
   \t call __clone_rope         \n
   \t jmp clone_rope_end        \n

   #if not cons, concat
   clone_rope_notcons:          \n

   #if nil, return
   \t cmp $0, %r12              \n
   \t je clone_rope_end         \n

   #if atom, break into characters and concat
   clone_rope_small:            \n
   \t cmpb $0, 0\(%r12\)        \n
   \t je clone_rope_end         \n
   \t movb 0\(%r12\), %bl       \n
   \t movb %bl, 0\(%r9\)        \n
   \t inc %r12                  \n
   \t inc %r9                   \n
   \t jmp clone_rope_small      \n

   clone_rope_end:              \n
   \t ret                       \n

   load_file:                   \n

   # open file
   \t mov $2, %rax              \n # syscall open
   \t mov %r12, %rdi            \n # file name
   \t mov $0, %rsi              \n # flags
   \t mov $0, %rdx              \n # read-only mode
   \t syscall                   \n
   # file descriptor is in %rax

   \t cmp $0, %rax              \n
   # if return value is positive then open was a success
   \t jge load_file_contents    \n

   \t mov %rax, %r12            \n
   \t call print_i              \n
   \t mov $__err_fopen, %r12    \n
   \t mov $0, %r13              \n
   \t mov $0, %r14              \n
   \t mov $0, %r15              \n
   \t ret                       \n

   load_file_contents:          \n
   \t mov %rax, %r12            \n
   \t call print_i              \n
   \t mov $0, %r12              \n
   \t mov $0, %r13              \n
   \t mov $0, %r14              \n
   \t mov $0, %r15              \n
   \t ret                       \n

   # read the file
   \t mov %rax, %rbx            \n # file descriptor
   \t mov $3, %rax              \n # read
   \t mov $load_file_buf, %rcx  \n # buffer
   \t mov $load_file_bsz, %rdx  \n # buffer size
   \t syscall                   \n

   # close the file
   
   \t mov $load_file_buf, %r12  \n
   \t ret                       \n
   
);

.data := (
                                \n
  load_file_bsz:                \n
  \t .quad 1024                 \n
  load_file_buf:                \n
  \t .zero 1024                 \n
  __nil:                        \n
  \t .zero 32                   \n
  __argv:                       \n
  \t .zero 32                   \n
  __s_counter:                  \n
  \t .zero 8                    \n
  __s_section:                  \n
  \t .zero 131072               \n
  __a_counter:                  \n
  \t .zero 8                    \n
  __a_section:                  \n
  \t .zero 131072               \n
  __nil_literal:                \n
  \t .ascii "\nil"              \n
  \t .zero 1                    \n
  __hex_buffer:                 \n
  \t .ascii "0123456789abcdef"  \n 
  __put64_buffer:               \n
  \t .ascii "0x"                \n
  __put64_write_buffer:         \n
  \t .ascii "0000000000000000 " \n
  \t .zero 1                    \n
  __newline:                    \n
  \t .ascii "\n"                \n
  __lparen:                     \n
  \t .ascii "\lparen"           \n
  __rparen:                     \n
  \t .ascii "\rparen"           \n
  __space:                      \n
  \t .ascii "\space"            \n
  __true:                       \n
  \t .ascii "True"              \n
  \t .zero 1                    \n
  __err_fopen:                  \n
  \t .ascii "Could not open file." \n
  \t .zero 1                    \n
);

concat := λl r. match (l r) (
   ()
   ( (x ()) x )
   ( (x (ys y)) ((concat(x ys)) y) )
);

kv-lookup := λctx key default. match ctx (
   ()
   ((ctxs (k v)) (
      if (==(k key)) v (kv-lookup(ctxs key default))
   ))
   (_ default)
);

eval-soft := λt. (
   ctx-eval-soft ( CTX t )
);

ctx-eval-soft := λctx t. (
   (match t (
      ()
      ((Lambda fl fr) (Lambda fl fr))
      ((l r) (tail(
         (local le)
         (= le (ctx-eval-soft(ctx l)))
         (local re)
         (= re (ctx-eval-soft(ctx r)))
         (match le (
            ()
            ( (Lambda fl fr) (tail(
               (local inner_ctx)
               (= inner_ctx (destructure (ctx fl re)))
               (ctx-eval-soft (inner_ctx fr))
            )))
            (_ (le re))
         ))
      )))
      (v (
         (kv-lookup(ctx v v))
      ))
   ))
);

destructure := λctx pat val. if ctx (match (pat val) (
   ()
   ( ((Var x) y) (
      (ctx (x y))
   ))
   ( ((xs x) (ys y)) (tail(
      (local inner_ctx)
      (= inner_ctx (destructure (ctx xs ys)))
      (= inner_ctx (destructure (inner_ctx x y)))
      inner_ctx
   )))
   ( (x y) (
      if (== (x y)) ctx ()
   ))
)) ();
