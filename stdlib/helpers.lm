
# LM provides a concept of open vs closed structures
# a closed structure may always be referred to by a single pointer
# a closed structure may exist on the stack or the heap or even a file or mapped network resource
# an open structure by comparison is thought to exist in the registers
# multiple structures may be open at the same time as long as they don't conflict
# fields of open structures are referred to by their ordered position $0, $1, $2
# a mapping of registers is then applied to these field positions
# x.$0 = %rdi
# y.$3 = %r10
# etc.

# S-Expressions are a common datastructure used heavily in the bootstrap compiler
# Not all structures need to be S-Expressions, but they will always be available
# Aside from the usual Cons,Atom,Nil information there is also a reference counter and some flags
#
# struct S {
#   $0 ref_counter : u64
#   $1 atom        : *char
#   $2 head        : *S
#   $3 tail        : *S
#   $4 flags       : bool[64]
# }

# BOOTSTRAP REGISTER ALLOCATION
# r12 , r13 , r14 , r15                : open this
# rsi , rdi                            : closed reference 1, 2
# r8, r9, r10, r11, rax, rbx, rcx, rdx : volatile internal registers

# BOOTSTRAP TYPES
# the bootstrap compiler uses S-Expressions for everything
# even the little types like bool or int
# specialization to use more efficient representations is available in the optimizing compiler
# which is what we are bootstrapping

# BOOTSTRAP FUNCTIONS
# the bootstrap compiler does not internally use closures
# the bootstrap compiler only refers to functions through labels, never pointers
# bootstrap functions have a simple calling convention that expects nonvolatile registers to be preserved

# bootstrap is inefficient with calling conventions
::callee-save-registers := (
   \t 'push \s %rax \n
   \t 'push \s %rbx \n
   \t 'push \s %rcx \n
   \t 'push \s %rdx \n
   \t 'push \s %r12 \n
   \t 'push \s %r13 \n
   \t 'push \s %r14 \n
   \t 'push \s %r15 \n
   \t 'push \s %rsi \n
   \t 'push \s %rdi \n
);
::callee-restore-registers := (
   \t 'pop \s %rdi \n
   \t 'pop \s %rsi \n
   \t 'pop \s %r15 \n
   \t 'pop \s %r14 \n
   \t 'pop \s %r13 \n
   \t 'pop \s %r12 \n
   \t 'pop \s %rdx \n
   \t 'pop \s %rcx \n
   \t 'pop \s %rbx \n
   \t 'pop \s %rax \n
);

::enter-function := (
   \t 'push \s %rbp \n
   \t 'mov \s %rsp, \s %rbp \n
);
::leave-function := (
   \t 'mov \s %rbp, \s %rsp \n
   \t 'pop \s %rbp \n
   \t 'ret \n
);

::show-newline := (
   \t 'push \s %rsi                 \n
   \t 'push \s %rdi                 \n

   \t 'mov \s '$1, \s %rax              \n
   \t 'mov \s '$1, \s %rdi              \n
   \t 'mov \s '$__newline, \s %rsi      \n
   \t 'mov \s '$1, \s %rdx              \n
   \t 'syscall                   \n

   \t 'pop \s %rdi                  \n
   \t 'pop \s %rsi                  \n
);

::show-lparen := (
   \t 'push \s %rsi                 \n
   \t 'push \s %rdi                 \n

   \t 'mov \s '$1, \s %rax              \n
   \t 'mov \s '$1, \s %rdi              \n
   \t 'mov \s '$__lparen, \s %rsi      \n
   \t 'mov \s '$1, \s %rdx              \n
   \t 'syscall                   \n

   \t 'pop \s %rdi                  \n
   \t 'pop \s %rsi                  \n
);

::show-rparen := (
   \t 'push \s %rsi                 \n
   \t 'push \s %rdi                 \n

   \t 'mov \s '$1, \s %rax              \n
   \t 'mov \s '$1, \s %rdi              \n
   \t 'mov \s '$__rparen, \s %rsi      \n
   \t 'mov \s '$1, \s %rdx              \n
   \t 'syscall                   \n

   \t 'pop \s %rdi                  \n
   \t 'pop \s %rsi                  \n
);

::show-space := (
   \t 'push \s %rsi                 \n
   \t 'push \s %rdi                 \n

   \t 'mov \s '$1, \s %rax              \n
   \t 'mov \s '$1, \s %rdi              \n
   \t 'mov \s '$__space, \s %rsi        \n
   \t 'mov \s '$1, \s %rdx              \n
   \t 'syscall                   \n

   \t 'pop \s %rdi                  \n
   \t 'pop \s %rsi                  \n
);

::yield-nil := (
                         # $_.$0 ref_counter is unnecessary when open
                         # open structures are completely "owned" by the current context
   # these registers are supposed to be "preserved"
   \t 'mov \s '$0, \s '%r12   \n # $_.$1 = 0, .atom
   \t 'mov \s '$0, \s '%r13   \n # $_.$2 = 0, .head
   \t 'mov \s '$0, \s '%r14   \n # $_.$3 = 0, .tail
   \t 'mov \s '$0, \s '%r15   \n # $_.$4 = 0, .flags
);

::yield-true := (
                         # $_.$0 ref_counter is unnecessary when open
                         # open structures are completely "owned" by the current context
   # these registers are supposed to be "preserved"
   \t 'mov \s '$__true, \s %r12   \n # $_.$1 = 0, .atom
   \t 'mov \s '$0, \s %r13   \n # $_.$2 = 0, .head
   \t 'mov \s '$0, \s %r14   \n # $_.$3 = 0, .tail
   \t 'mov \s '$0, \s %r15   \n # $_.$4 = 0, .flags
);

::yield-atom := λ::yield-atom-label. (
                               # $_.$0 ref_counter is unnecessary when open
                               # open structures must be completely "owned" by the current context
   \t 'mov \s '$ ::yield-atom-label , \s %r12     \n # $_.$1 = 0, .atom
   \t 'mov \s '$0, \s %r13           \n # $_.$2 = 0, .head
   \t 'mov \s '$0, \s %r14           \n # $_.$3 = 0, .tail
   \t 'mov \s '$0, \s %r15           \n # $_.$4 = 0, .flags
);

::yield-cons := λ::cons-head ::cons-tail. (
   ::cons-head
   ::push-this

   ::cons-tail
   ::close-this                # %rsi is tail

   \t 'mov \s %rsi, \s %rdi        \n # %rdi is tail
   ::pop-this
   ::close-this                # %rsi is head

   \t 'mov \s '$0, \s %r12          \n # this.atom is NULL
   \t 'mov \s %rsi, \s %r13        \n # this.head is head
   \t 'mov \s %rdi, \s %r14        \n # this.tail is tail
   \t 'mov \s '$0, \s %r15          \n # this.flags is 0
);

::show-this := (
   \t 'mov \s '$0xdeadbeef, \s %r8            \n
   ::put64

   \t 'mov \s '%r12, \s '%r8            \n
   ::put64

   \t 'mov \s '%r13, \s '%r8            \n
   ::put64

   \t 'mov \s '%r14, \s '%r8            \n
   ::put64

   \t 'mov \s '%r15, \s '%r8            \n
   ::put64

   ::show-newline
);

::show-close := (
   \t 'mov \s '$0xdeadcccc, \s %r8            \n
   ::put64

   \t 'mov \s '%rsi, \s '%r8             \n
   ::put64

   \t 'mov \s '0 \[ %rsi \] , \s '%r8            \n
   ::put64

   \t 'mov \s '8 \[ %rsi \] , \s '%r8            \n
   ::put64

   \t 'mov \s '16 \[ %rsi \] , \s '%r8            \n
   ::put64

   \t 'mov \s '24 \[ %rsi \] , \s '%r8            \n
   ::put64

   ::show-newline
);

::push-this := (
   \t 'push \s '%r12 \n
   \t 'push \s '%r13 \n
   \t 'push \s '%r14 \n
   \t 'push \s '%r15 \n
);

::push-zero := (
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
);

::unpush-this := (
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
);

::pop-this := (
   \t 'pop \s '%r15 \n
   \t 'pop \s '%r14 \n
   \t 'pop \s '%r13 \n
   \t 'pop \s '%r12 \n
);

::shadow-this := (
   \t 'mov \s '%r12, \s '%r8 \n
   \t 'mov \s '%r13, \s '%r9 \n
   \t 'mov \s '%r14, \s '%r10 \n
   \t 'mov \s '%r15, \s '%r11 \n
);

::unshadow-this := (
   \t 'mov \s '%r8, \s '%r12 \n
   \t 'mov \s '%r9, \s '%r13 \n
   \t 'mov \s '%r10, \s '%r14 \n
   \t 'mov \s '%r11, \s '%r15 \n
);

::close-this := (
   # move this S onto the heap
   # %rsi becomes pointer to new location
   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0 \[ %r8 \] , \s '%r10              \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ %r8 \]              \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ %rsi \]             \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ %rsi \]             \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ %rsi \]            \n # set top.tail 
   \t 'mov \s '%r15, \s '24 \[ %rsi \]            \n # set top.flags
);

::open-this := (
   \t 'mov \s '0 \[ %rsi \] , \s '%r12             \n
   \t 'mov \s '8 \[ %rsi \] , \s '%r13             \n
   \t 'mov \s '16 \[ %rsi \] , \s '%r14            \n
   \t 'mov \s '24 \[ %rsi \] , \s '%r15            \n
   # move S from heap into this
   # %rsi is pointer to current location
);

::head := (
   \t 'mov \s '0 \[ %r13 \] , \s '%r12             \n
   \t 'mov \s '16 \[ %r13 \] , \s '%r14            \n
   \t 'mov \s '24 \[ %r13 \] , \s '%r15            \n
   \t 'mov \s '8 \[ %r13 \] , \s '%r13             \n
);
::tail := (
   \t 'mov \s '0 \[ %r14 \] , \s '%r12             \n
   \t 'mov \s '24 \[ %r14 \] , \s '%r15            \n
   \t 'mov \s '8 \[ %r14 \] , \s '%r13             \n
   \t 'mov \s '16 \[ %r14 \] , \s '%r14            \n
);

::program-header := (
   '.global \s '_start        \n
   '.text                 \n
   '_start:               \n
   \t 'jmp \s 'main           \n
);

::data-header := (
                         \n
   '.data                 \n
);

::exit-cleanup := (
                         \n
   \t 'mov \s '$60, \s '%eax      \n # _exit system call
   \t 'mov \s '$0, \s '%edi       \n # error code 0
   \t 'syscall            \n
);

::get-global := λ::global-name. (
   \t 'mov \s '$ ::global-name ', \s %rax \n
   \t 'mov \s '0 \[ %rax \] , '%r12        \n
   \t 'mov \s '8 \[ %rax \] , '%r13        \n
   \t 'mov \s '16 \[ %rax \] , '%r14       \n
   \t 'mov \s '24 \[ %rax \] , '%r15       \n
);

::set-global := λ::global-name. (
   \t 'mov \s '$ ::global-name , \s '%rax \n
   \t 'mov \s '%r12, \s '0 \[ %rax \]        \n
   \t 'mov \s '%r13, \s '8 \[ %rax \]        \n
   \t 'mov \s '%r14, \s '16 \[ %rax \]       \n
   \t 'mov \s '%r15, \s '24 \[ %rax \]       \n
);

# $this is the Rope to iterate over
# ::foreach-call is a label to be called for each atom
::foreach-atom := λ::foreach-head ::foreach-notcons ::foreach-ignore ::foreach-apply.(
   #define label for this function
   ::foreach-head : \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13 \n
   \t 'je \s ::foreach-notcons \n
   \t 'cmp \s '$0, \s '%r14 \n
   \t 'je \s ::foreach-notcons \n
   ::push-this
   ::head
   \t 'call \s ::foreach-head \n
   ::pop-this
   ::push-this
   ::tail
   \t 'call \s ::foreach-head \n
   ::pop-this
   \t 'ret \n

   #if not cons, apply
   ::foreach-notcons : \n
   \t 'cmp \s '$0, \s '%r12 \n
   \t 'je \s ::foreach-ignore \n
   ::push-this
   ::foreach-apply
   ::pop-this
   \t 'ret \n

   ::foreach-ignore : \n
   \t 'ret \n
);

::eq := λ::l ::r.(
   ::l
   \t 'push \s '%r12                      \n
   ::r
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'pop \s '%rbx                       \n
   \t 'call \s '_streq                    \n
);

# $this is the Rope to iterate over
# ::foreach-call is a label to be called for each atom
::foreach-char := λ::foreach-data ::foreach-head ::foreach-small ::foreach-end ::foreach-notcons ::foreach-apply ::foreach-expr.(
   #define label for this function
   ::foreach-head : \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s %r13 \n
   \t 'je \s ::foreach-notcons \n
   \t 'cmp \s '$0, \s '%r14 \n
   \t 'je \s ::foreach-notcons \n
   ::push-this
   ::head
   \t 'call \s ::foreach-head \n
   ::pop-this
   ::push-this
   ::tail
   \t 'call \s ::foreach-head \n
   ::pop-this
   \t 'ret \n

   #if not cons, apply
   ::foreach-notcons : \n
   ::push-this

   #if nil, apply and return
   \t 'mov \s '%r12, \s '%r8 \n
   \t 'cmp \s '$0, \s '%r12 \n
   \t 'jne \s ::foreach-small \n
   \t 'call \s ::foreach-apply \n
   ::pop-this
   \t 'ret \n

   #if atom, break into characters and apply
   ::foreach-small : \n
   \t 'cmpb \s '$0, \s '0 \[ %r8 \] \n
   \t 'je \s ::foreach-end \n
   \t 'push \s '%r8 \n
   \t 'mov \s '$ ::foreach-data , \s '%r12 \n
   \t 'mov \s '$0, \s '%r13 \n
   \t 'mov \s '$0, \s '%r14 \n
   \t 'mov \s '$0, \s '%r15 \n
   \t 'movb \s '0 \[ %r8 \] , \s '%bl \n
   \t 'movb \s '%bl, \s '0 \[ %r12 \] \n
   \t 'movb \s '$0, \s '1 \[ %r12 \] \n
   \t 'call \s ::foreach-apply \n
   \t 'pop \s '%r8 \n
   \t 'inc \s '%r8 \n
   \t 'jmp \s ::foreach-small \n

   ::foreach-end : \n
   ::pop-this
   \t ret \n

   ::foreach-apply : \n
   ::foreach-expr
   \t 'ret \n
);

::foreach-char-data := λ::foreach-data.(
   ::foreach-data : \n
   \t '.zero \s '2 \n
);

::argv := (
   \t 'mov \s '$__argv, \s '%rax      \n
   \t 'mov \s '0 \[ %rax \] , \s '%r12    \n
   \t 'mov \s '8 \[ %rax \] , \s '%r13    \n
   \t 'mov \s '16 \[ %rax \] , \s '%r14   \n
   \t 'mov \s '24 \[ %rax \] , \s '%r15   \n
);

::before-main := (
   # let argv = close ()
   # let t = argv
   # for a in argv:
   #    t.tail = (a ())
   #    t = t.tail
   \t 'pop \s '%rax               \n #argc
   \t 'mov \s '$__argv, \s '%rbx      \n
   \t 'movq \s '$0, \s '0 \[ %rbx \]      \n
   \t 'movq \s '$0, \s '8 \[ %rbx \]      \n
   \t 'movq \s '$0, \s '16 \[ %rbx \]     \n
   \t 'movq \s '$0, \s '24 \[ %rbx \]     \n

   '__before_main_argv:       \n
   \t 'cmp \s '$0, \s '%rax           \n
   \t 'je \s '__before_main_end   \n
   \t 'pop \s '%r12               \n #argv[i]
   \t 'mov \s '$0, \s '%r13           \n
   \t 'mov \s '$0, \s '%r14           \n
   \t 'mov \s '$0, \s '%r15           \n
   ::close-this
   \t 'mov \s '%rsi, \s '%rdi         \n
   #rdi is a
   \t 'mov \s '$0, \s '%r12           \n
   \t 'mov \s '$0, \s '%r13           \n
   \t 'mov \s '$0, \s '%r14           \n
   \t 'mov \s '$0, \s '%r15           \n
   ::close-this
   #rsi is clean closed ()
   \t 'mov \s '%rdi, \s '8 \[ %rbx \]    \n
   \t 'mov \s '%rsi, \s '16 \[ %rbx \]   \n
   \t 'mov \s '%rsi, \s '%rbx         \n
   #rbx is tail of argv
   \t 'dec \s '%rax               \n
   \t 'jmp \s '__before_main_argv \n
   '__before_main_end:        \n
);

::a-counter := (
   \t 'mov \s '$__a_counter, \s %r12  \n
   \t 'mov \s '0 \[ %r12 \] , \s %r12 \n
   \t 'mov \s '$0, \s '%r13           \n
   \t 'mov \s '$0, \s '%r14           \n
   \t 'mov \s '$0, \s '%r15           \n
);

::s-counter := (
   \t 'mov \s '$__s_counter, \s %r12  \n
   \t 'mov \s '0 \[ %r12 \] , \s %r12 \n
   \t 'mov \s '$0, \s '%r13           \n
   \t 'mov \s '$0, \s '%r14           \n
   \t 'mov \s '$0, \s '%r15           \n
);
