
let mk-app(f: AST, a: AST): AST = (
   App( close(f), close(a) )
);

let mk-cons-or-app(is-cons: U64, f: AST, a: AST): AST = (
   App( is-cons, close(f), close(a) )
);

let mk-cons(f: AST, a: AST): AST = (
   App( true, close(f), close(a) )
);

let mk-glb(k: Token, v: AST): AST = (
   Glb( k, close(v) )
);

let mk-seq(): AST = (
   Seq( mk-vector(type(AST)) )
);

let mk-typedef(loc: SourceLocation, lhs-type: Type): AST = (
   Typedef( loc, lhs-type, mk-vector(type(Type)), mk-vector(type(Type)),
             ta, ta, ta, mk-vector(type((CString,Vector<(CString,Type)>))), ta, ta )
);

let .is-cons(t: AST): Bool = (
   match t {
      App{is-cons=is-cons} => is-cons;
      _ => false;
   }
);

let .is-var(t: AST): Bool = (
   match t {
      Var{} => true;
      _ => false;
   }
);

let .is-var-or-ascripted-var(t: AST): Bool = (
   match t {
      Var{} => true;
      App{ left:Var{key:c"as"}, right:App{ left:Var{}, right:AType{} } } => true;
      App{ left:Lit{key:c":"}, right:App{ left:Var{}, right:AType{} } } => true;
      _ => false;
   }
);

let .with-implies(term: AST, implies: Vector<Type>): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-implements(term: AST, implements: Vector<Type>): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-size(term: AST, size: Type): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-alias(term: AST, alias: Type): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-opaque-alias(term: AST, opaque-alias: Type): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-cases(term: AST, cases: Vector<(CString,Vector<(CString,Type)>)>): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let misc-type = (term as Tag::Typedef).misc-type;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-misc(term: AST, misc-type: Type): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let implied-phi = (term as Tag::Typedef).implied-phi;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);
let .with-implied-phi(term: AST, implied-phi: Type): AST = (
   match term {
      Typedef{} => (
         let location = (term as Tag::Typedef).location;
         let lhs-type = (term as Tag::Typedef).lhs-type;
         let implies = (term as Tag::Typedef).implies;
         let implements = (term as Tag::Typedef).implements;
         let size = (term as Tag::Typedef).size;
         let alias = (term as Tag::Typedef).alias;
         let opaque-alias = (term as Tag::Typedef).opaque-alias;
         let cases = (term as Tag::Typedef).cases;
         let misc-type = (term as Tag::Typedef).misc-type;
         Typedef( location, lhs-type, implies, implements, size, alias, opaque-alias, cases, misc-type, implied-phi );
      );
      _ => term;
   }
);

let mk-abs(l: AST, r: AST, t: Type): AST = (
   Abs( close(l), close(r), t )
);

let mk-meta(l: AST): AST = (
   Meta( close(l) )
);

let mk-nil(): AST = ASTNil();
let mk-eof(): AST = ASTEOF();

let .is-lit(t: AST): Bool = match t { Lit{} => true; _ => false; };
let .is-ascript(t: AST): Bool = (
   match t {
      App{ left:Lit{key:c":"}, right:App{ left:Lit{key=key}, right:AType{} } } => true;
      _ => false;
   }
);

let mk-var(val: CString): AST = (
   Var( val, mk-token(val) )
);

let mk-var(val: String): AST = (
   Var( untern(val), mk-token(val) )
);

let mk-var(val: Token): AST = (
   Var( val.key, val )
);

let mk-var(v: CString, vtk: Token): AST = Var(v,vtk);

let mk-lit(val: CString): AST = (
   Lit( val, mk-token(val) )
);

let mk-lit(val: String): AST = (
   Lit( untern(val), mk-token(val) )
);

let mk-lit(val: Token): AST = (
   Lit( val.key, val )
);

let mk-lit(v: CString, vtk: Token): AST = Lit(v,vtk);

let mk-atype(tt: Type): AST = (
   AType(tt)
);

let .ascript(t: AST, tt: Type): AST = (
   mk-app(
      mk-lit(c":"),
      mk-cons( t, mk-atype(tt) )
   )
);

let .is-nil(t: AST): Bool = (
   match t {
      ASTNil{} => true;
      _ => false;
   }
);
