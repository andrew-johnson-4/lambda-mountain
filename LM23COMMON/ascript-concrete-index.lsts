
# A concrete type is an instance of a type that has been realized on a term
# It is not an "in processing" or "theoretical" type anymore, but now an actual observed term

let concrete-type-instances-index = {} : Hashtable<(CString,U64),Vector<Type>>;

let add-concrete-type-instance(tt: Type, blame: AST): Nil = (
   match tt {
      TAnd{ conjugate=conjugate } => (
         for vector c in conjugate {
            add-concrete-type-instance(c, blame);
         }
      );
      TGround{ tag=tag, parameters=parameters } => (
         if tt.is-datatype then {
            tt = tt.rewrite-type-alias.without-any-phi;
            let gta = tt.ground-tag-and-arity;
            let row = concrete-type-instances-index.lookup(gta, mk-vector(type(Type)));
            if not(row.contains(tt)) then row = row.push(tt);
            concrete-type-instances-index = concrete-type-instances-index.bind(gta, row);
         };
         for list p in parameters {
            add-concrete-type-instance(p, blame);
         };
      );
      _ => ();
   }
);

let does-concrete-type-instance-exist(tt: Type): Bool = (
   let empty-type-vector = mk-vector(type(Type)); # this is a workaround for a phi bug that needs to be fixed 
   match tt {
      TGround{tag=tag, ts=parameters} => (
         let exists = false;
         let k = (tag, ts.length as U64);
         for vector vt in concrete-type-instances-index.lookup(k, empty-type-vector) {
            if vt==tt then exists = true;
         };
         exists
      );
      _ => false;
   }
);
