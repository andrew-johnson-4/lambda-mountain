
let try-destructure-macro(loc: SourceLocation, lhs: AST, term: AST): AContext? = (
   let r = None : AContext?;
   let yes = Some([] : AContext);
   match (lhs, term) {
      Tuple{first:ASTNil{}, second:ASTNil{}} => r = yes;
      Tuple{
         first:App{left:App{left:Var{}, right:Var{}}, right:Var{}},
         second:App{left:App{left:Lit{}}}
      } => ();
      Tuple{
         first:App{left:Lit{key:c":Literal:"},right:Var{pv=key}},
         second:App{left:Lit{key:c":",ctk=token}, right:App{left:Lit{},right:AType{}}}
      } => r = r.bind(pv,term.with-location(ctk.location));
      Tuple{
         first:App{left:Var{},right:Var{}},
         second:App{left:Lit{tag=key}}
      } => (
         if is-lone-tag(tag) or tag.is-suffixed {
            match (lhs,term) {
               Tuple{first:App{pl=left,pr=right}, second:App{el=left,er=right}} => (
                  let ll = try-destructure-macro(loc,pl,el);
                  if non-zero(ll) {
                     let rl = try-destructure-macro(loc,pr,er);
                     if non-zero(rl) then r = union(ll,rl);
                  }
               );
            }
         }
      );
      Tuple{ first:App{pl1=left,pr1=right}, second:App{el1=left,er1=right} } => (
         let ll1 = try-destructure-macro(loc,pl1,el1);
         if non-zero(ll1) {
            let rl1 = try-destructure-macro(loc,pr1,er1);
            if non-zero(rl1) then r = union(ll1,rl1);
         }
      );
      Tuple{ first:Abs{pl2=lhs,pr2=rhs,ptlt2=tt}, second:Abs{el2=lhs,er2=rhs,etlt2=tt} } => (
         let ll2 = try-destructure-macro(loc,pl2,el2);
         if non-zero(ll2) {
            let rl2 = try-destructure-macro(loc,pr2,er2);
            if non-zero(rl2) then r = union(ll2,rl2);
         }
      );
      Tuple{ first:Lit{key:c":Any:"}, second:Var{key:c"_"} } => r = yes;
      Tuple{ first:Lit{pl3=key}, second:Var{el3=key} } => if pl3==el3 then r = yes;
      Tuple{ first:Lit{pl4=key}, second:Lit{el4=key} } => if pl4==el4 then r = yes;
      Tuple{ first:App{left:Lit{key:c":Literal:"}, right:Var{pv5=key}}, second:Lit{el5=key,eltk5=token} } => (
         if index-of-tag(el5)==unknown-index-of-tag then r = r.bind(pv5,term.with-location(eltk5.location));
      );
      Tuple{ first:App{left:Lit{key:c":Field:"}, right:Var{pv6=key}}, second:Lit{el6=key,eltk6=token} } => (
         if el6.has-prefix(c".") then r = r.bind(pv6,term.with-location(eltk6.location));
      );
      Tuple{ first:App{left:Lit{key:c":Variable:"}, right:Var{pv7=key}}, second:Var{key:c"_"} } => (
      );
      Tuple{ first:App{left:Lit{key:c":Variable:"}, right:Var{pv8=key}}, second:Var{el8=key,eltk8=token} } => (
         r = r.bind(pv8,term.with-location(eltk8.location));
      );
      Tuple{ first:App{ left:App{ left:Lit{key:c":Tag:"}, right:Var{pv9=key} }, right:Var{pt9=key} }, second:Lit{el9=key,eltk9=token} } => (
         if index-of-tag(el9)!=unknown-index-of-tag {
            r = yes;
            let tag-i = index-of-tag(el9).into(type(CString));
            r = r.bind(pv9, mk-app( mk-lit(c":",with-key(eltk9,c":")), mk-app( mk-lit(tag-i,with-key(eltk9,tag-i)), mk-atype(t0(c"Constant") && t0(c"Literal") && t0(c"U64")) ) ));
            let tag-tt = c"Tag::" + el9;
            r = r.bind(pt9, mk-lit(tag-tt,with-key(eltk9,tag-tt)));
         }
      );
      Tuple{ first:Var{pv10=key}, t10=second } => r = r.bind(pv10,term.with-location(t10.location));
      _ => ();
   }; r
);
