
let $"<:"(pt: Type, fpt: Type): Bool = can-unify(fpt,pt);

let can-unify(fpt: List<Type>, pt: List<Type>): Bool = (
   if fpt.length == pt.length {
      let ok = true;
      while ok and non-zero(fpt) {
         if not(can-unify(head(fpt), head(pt))) then (ok = false);
         fpt = tail(fpt); pt = tail(pt);
      };
      ok
   } else false
);

let can-unify(fpt: Type, pt: Type): Bool = (
   match Tuple(fpt, pt) {
      Tuple{ first:TAny{} } => true;
      Tuple{ first:TGround{tag:c"Any"} } => true;
      Tuple{ first:TGround{tag:c"MustNotRetain"} } => true;
      Tuple{ first:TGround{tag:c"MustNotMove"} } => true;
      Tuple{ first:TGround{tag:c"MustReleaseAfterCall"} } => true;
      Tuple{ first:TGround{tag:c"MustNotRewrite"} } => true;
      Tuple{ first:TGround{tag:c"MustNotFresh"} } => true;
      Tuple{ first:TVar{}, second:TGround{tag:c"Cons"} } => false;
      Tuple{ first:TVar{} } => true;
      Tuple{ first:TAnd{ lconjugate=conjugate }, second:TAnd{ rconjugate=conjugate } } => (
         let result = true;
         let ri = 0_sz;
         let phi-state-in = ta;
         for vector lc in lconjugate {
            if result then (match lc {
               TGround{tag:c"Any"} => ();
               TGround{tag:c"MustNotRetain"} => ();
               TGround{tag:c"MustNotMove"} => ();
               TGround{tag:c"MustReleaseAfterCall"} => ();
               TGround{tag:c"MustNotRewrite"} => ();
               TGround{tag:c"MustNotFresh"} => ();
               TGround{tag:c"Phi::Transition", parameters:[phi-to..phi-from..]} => (
                  let skip-state-check = false;
                  for vector st in rconjugate { match st {
                     TGround{tag:c"Phi::State",parameters:[new-phi-state..]} => (
                        phi-state-in = phi-state-in.extend(new-phi-state);
                     );
                     TGround{tag:c"Phi::Transition",parameters:[new-phi-to..new-phi-from..]} => (
                        result = result and can-unify(phi-to, new-phi-to) and can-unify(phi-from, new-phi-from);
                        skip-state-check = true;
                     );
                     _ => ();
                  }};
                  if not(skip-state-check) then result = result and can-unify(phi-from, phi-state-in);
               );
               TGround{ltag=tag} => (
                  let this-result-ok = false;
                  let rc = rconjugate[ri];
                  let rtag = rc.simple-tag;
                  if not(non-zero(rtag)) then () else (
                     while ri<rconjugate.length and rtag < ltag {
                        ri = ri + 1;
                        if ri < rconjugate.length {
                           rc = rconjugate[ri];
                           rtag = rc.simple-tag;
                        }
                     };
                     let scan-ri = ri;
                     while scan-ri<rconjugate.length and rtag==ltag {
                        this-result-ok = this-result-ok or can-unify(lc,rc);
                        scan-ri = scan-ri + 1;
                        if scan-ri < rconjugate.length {
                           rc = rconjugate[scan-ri];
                           rtag = rc.simple-tag;
                        }
                     };
                  );
                  result = result and this-result-ok;
               );
               _ => result = result and can-unify(lc,pt);
            });
         };
         result;
      );
      Tuple{ first:TAnd{ lconjugate=conjugate }, rt=second } => (
         let result = true;
         for vector c in lconjugate { result = result and can-unify(c,rt) };
         result
      );
      Tuple{ lt=first, second:TAnd{ rconjugate=conjugate } } => (
         let result = false;
         for vector c in rconjugate { result = result or can-unify(lt,c) };
         result
      );

      # Ignore C Access Modifiers For Now
      Tuple{ first:TGround{tag:c"C", parameters:[TGround{tag:c"const"}..]} } => true;

      # Varargs
      Tuple{
          first:TGround{tag:c"Cons", parameters:[
             TGround{tag:c"...", parameters:[lp1..]}..
             lpr..
          ]},
          second:TGround{tag:c"Cons", parameters:[rp1..rpr..]}
      } => (
         if can-unify(lp1,rp1) then can-unify(fpt,rpr) else can-unify(lpr,pt)
      );
      Tuple{
          first:TGround{tag:c"Cons", parameters:[
             TGround{tag:c"...", parameters:[lp1..]}..
             lpr..
          ]},
          second:rp1
      } => (
         if can-unify(lp1,rp1) then can-unify(lpr,t0(c"Nil")) else can-unify(lpr,rp1)
      );
      Tuple{
          first:TGround{tag:c"...", parameters:[lp1..]},
          second:TGround{tag:c"Cons", parameters:[rp1..rpr..]}
      } => (
         can-unify(lp1,rp1) and can-unify(fpt,rpr)
      );
      Tuple{
          first:TGround{tag:c"...", parameters:[lp1..]},
          second:TGround{tag:c"Nil", parameters:[]}
      } => true;
      Tuple{
          first:TGround{tag:c"...", parameters:[lp1..]},
          second:rp1
      } => can-unify(lp1,rp1);

      Tuple{
          first:TGround{tag:c"Arrow", parameters:[lrng.. ldom..]},
          second:TGround{tag:c"Arrow", parameters:[rrng.. rdom..]}
      } => (
         if can-unify(rdom, ldom) {
            can-unify(lrng, rrng)
         } else false
      );

      Tuple{
          first:TGround{ltn=tag, lps=parameters},
          second:TGround{rtn=tag, rps=parameters}
      } => (ltn==rtn or (ltn.has-suffix(c"::") and rtn.has-prefix(ltn))) and can-unify(lps,rps);
      _ => false;
   };
);
