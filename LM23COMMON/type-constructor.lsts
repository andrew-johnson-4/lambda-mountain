
# new allocations = 0
let ta = TAny;

# new allocations = 1
#    1 from close
#    0 from 0 length list
# this is an upper bound, because the list implementation should be replaced with vector eventually
let t0(tag: CString): Type = TGround(tag, close([] : List<Type>));

# new allocations = 2
#    1 from close
#    1 from 1 length list
# this is an upper bound, because the list implementation should be replaced with vector eventually
let t1(tag: CString, p1: Type): Type = TGround(tag, close([p1]));

# new allocations = 3
#    1 from close
#    2 from 2 length list
# this is an upper bound, because the list implementation should be replaced with vector eventually
let t2(tag: CString, p1: Type, p2: Type): Type = TGround(tag, close([p2, p1]));

# new allocations = 0
let tv(name: CString): Type = TVar(name);

# new allocations = 0 if either argument is ?
#                 | 1
let $"&&"(lt: Type, rt: Type): Type = (
   match (lt, rt) {
      Tuple{first:TAny{}} => rt;
      Tuple{second:TAny{}} => lt;
      Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), lconjugate.length+rconjugate.length);
         for vector c in lconjugate { result = result.push(c) };
         for vector c in rconjugate { result = result.push(c) };
         result = result.sort;
         TAnd(result)
      );
      Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), 1+rconjugate.length);
         result = result.push(first);
         for vector c in rconjugate { result = result.push(c) };
         result = result.sort;
         TAnd(result)
      );
      Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
         let result = mk-vector(type(Type), lconjugate.length+1);
         for vector c in lconjugate { result = result.push(c) };
         result = result.push(second);
         result = result.sort;
         TAnd(result)
      );
      Tuple{first=first,second=second} => (
         let result = mk-vector(type(Type), 2);
         result = result.push(first);
         result = result.push(second);
         result = result.sort;
         TAnd(result)
      );
   };
);

# new allocations = 0 if either argument is ?
#                 | 1
let .extend(lt: Type, rt: Type): Type = (
   match (lt, rt) {
      Tuple{first:TAny{}} => rt;
      Tuple{second:TAny{}} => lt;
      Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
         for vector c in rconjugate { lconjugate = lconjugate.push(c) };
         lconjugate = lconjugate.sort;
         TAnd(lconjugate)
      );
      Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), 1+rconjugate.length);
         result = result.push(first);
         for vector c in rconjugate { result = result.push(c) };
         result = result.sort;
         TAnd(result)
      );
      Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
         lconjugate = lconjugate.push(second);
         lconjugate = lconjugate.sort;
         TAnd(lconjugate)
      );
      Tuple{first=first,second=second} => (
         let result = mk-vector(type(Type), 2);
         result = result.push(first);
         result = result.push(second);
         result = result.sort;
         TAnd(result)
      );
   };
);

# new allocations = 1
# this is an upper bound, because the list implementation should be replaced with vector eventually
let ts(tag: CString, ps: List<Type>): Type = TGround( tag, close(ps) );

# new allocations = 0
let tand(t: Vector<Type>): Type = TAnd(t.sort);

# new allocations = 1
let tand(tt: Type): Type = TAnd(mk-vector(type(Type)).push(tt));

# new allocations = 0
let $"||"(lt: Type, rt: Type): Type = if non-zero(lt) then lt else rt;
