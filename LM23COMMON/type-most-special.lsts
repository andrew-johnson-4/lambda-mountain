
# specialization does not always choose the lowest on the subsumption hierarchy
# for example: x -> x <: A -> A
# but for specialization we choose: A -> A
# This is because specialization chooses the most specific domain, irrespective of range
# This is different than the traditional contravariant domain for arrows
# Theoretically this is justified by flow-of-information during disambiguation
#    f(x) is interpreted as "f informed by x"
#    rather than as simply "f of x"
# This check also includes return-type specialization
# None : Nil -> x?
# None : Nil -> U64?  (most special)

let most-special(t0: Type, t1: Type): Type = (
   if t0.is-arrow && t1.is-arrow {
      if t0.domain <: t1.domain && t1.domain <: t0.domain {
         if t0.range <: t1.range then t0
         else if t1.range <: t0.range then t1
         else ta
      }
      else if t1.domain <: t0.domain then t1
      else if t0.domain <: t1.domain then t0
      else ta
   } else if t0 <: t1 then t0
     else if t1 <: t0 then t1
     else ta
);
