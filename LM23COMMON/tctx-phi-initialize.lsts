
let .phi-initialize(tctx: TypeContext?, tt: Type, blame: AST): (TypeContext?, Type) = (
   if not(tt.is-t(c"Phi::Id",1)) {
      (tctx, tt) = tctx.phi-initialize-inner(tt, blame);
      tt = tctx.with-phi(tt);
   } else if tt.is-t(c"Phi::State",1) {
      let phi-id = tt.slot(c"Phi::Id",1).l1.simple-tag;
      let phi-state = tt.slot(c"Phi::Id",1).l1;
      tctx = tctx.bind-phi(phi-id, phi-state, blame);
   };
   (tctx, tt)
);

let .phi-initialize-inner(tctx: TypeContext?, tt: Type, blame: AST): (TypeContext?, Type) = (
   match tt {
      TAnd{conjugate=conjugate} => (
         let new-conjugate = mk-vector(type(Type), conjugate.length);
         for c in conjugate {
            (tctx, c) = tctx.phi-initialize-inner(c, blame);
            if non-zero(c) then new-conjugate = new-conjugate.push(c);
         };
         (tctx, tand(new-conjugate))
      );
      TGround{tag:c"Phi::State",parameters:[init-tt..]} => (
         let phi-id = uuid();
         tctx = tctx.bind-phi(phi-id, init-tt, blame);
         (tctx, t1(c"Phi::Id",t0(phi-id)))
      );
      TGround{tag=tag, parameters=parameters} => (
         let new-parameters = [] : List<Type>;
         for p in parameters.reverse {
            (tctx, p) = tctx.phi-initialize-inner(p, blame);
            new-parameters = cons(p, new-parameters);
         };
         (tctx, ts(tag,new-parameters))
      );
      _ => (tctx, tt);
   };
);
