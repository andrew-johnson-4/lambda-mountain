
# TGround needs an ordered enum or else unification may not work right
# TGround = 0
# TAny = 1
# TVar = 2
# TAnd = 3
type Type zero TAny implies MustRetain, MustRelease
        = TGround { tag:CString, parameters:OwnedData<List<Type>>[] }
        | TAny
        | TVar { name:CString }
        | TAnd { conjugate:Vector<Type> };

let .release(t: Type): Nil = (
   print(c"Release Type\n");
   if t.discriminator-case-tag==(t as Tag::Ground).discriminator-case-tag {
      print("Release parameters: ref-count=\{(t as Tag::TGround).parameters.reference-count}\n");
      (t as Tag::TGround).parameters.release;
      print(c"Released parameters\n");
   };
   if t.discriminator-case-tag==(t as Tag::And).discriminator-case-tag {
      print(c"Release and conjugate\n");
      (t as Tag::TAnd).conjugate.release;
      print(c"Released conjugate\n");
   };
   print(c"Released Type\n");
   mark-as-released(t);
);

let .retain(t: Type): Type = (
   print(c"Retain Type\n");
   if t.discriminator-case-tag==(t as Tag::Ground).discriminator-case-tag {
      (t as Tag::TGround).parameters.retain;
   };
   if t.discriminator-case-tag==(t as Tag::And).discriminator-case-tag {
      mark-as-released((t as Tag::TAnd).conjugate.retain);
   };
   t
);
