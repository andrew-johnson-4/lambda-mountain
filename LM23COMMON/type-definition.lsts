
# TGround needs an ordered enum or else unification may not work right
# TGround = 0
# TAny = 1
# TVar = 2
# TAnd = 3
# TODO: replace TGround List implementation with Vector which is much more efficient
# for this reason allocation counts only have an upper bound rather than exact bound
type Type zero TAny implies MustRetain, MustRelease
        = TGround { tag:CString, parameters:OwnedData<List<Type>>[] }
        | TAny
        | TVar { name:CString }
        | TAnd { conjugate:Vector<Type> };

let .release(t: Type): Nil = (
   if t.discriminator-case-tag==(t as Tag::TGround).discriminator-case-tag {
      (t as Tag::TGround).parameters.release;
   };
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      (t as Tag::TAnd).conjugate.release;
   };
   mark-as-released(t);
);

let .retain(t: Type): Type = (
   if t.discriminator-case-tag==(t as Tag::TGround).discriminator-case-tag {
      (t as Tag::TGround).parameters.retain;
   };
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      mark-as-released((t as Tag::TAnd).conjugate.retain);
   };
   t
);

# TODO: remove
let .release(tt: x[]): Nil = ();
let .retain(tt: x[]): x[] = tt;
