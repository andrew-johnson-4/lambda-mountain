
let global-tctx = {} : Hashtable<CString,List<TypeContextRow>>;
let global-pctx = [] : List<PhiContextRow>;

type TypeContextRow zero NullTypeContextRow implies MustRetain, MustRelease = NullTypeContextRow | TypeContextRow { key: CString, nt: Type, dt: Type, blame: AST };
let .retain(t: TypeContextRow): TypeContextRow = (
   if t.discriminator-case-tag==(t as Tag::TypeContextRow).discriminator-case-tag {
      mark-as-released((t as Tag::TypeContextRow).nt.retain);
      mark-as-released((t as Tag::TypeContextRow).dt.retain);
      mark-as-released((t as Tag::TypeContextRow).blame.retain);
   };
   t
);
let .release(t: TypeContextRow): Nil = (
   if t.discriminator-case-tag==(t as Tag::TypeContextRow).discriminator-case-tag {
      (t as Tag::TypeContextRow).nt.release;
      (t as Tag::TypeContextRow).dt.release;
      (t as Tag::TypeContextRow).blame.release;
   };
   mark-as-released(t);
);

type PhiContextRow zero NullPhiContextRow implies MustRetain, MustRelease = NullPhiContextRow | PhiContextRow { phi-id: CString, phi-tt: Type, blame: AST, dead-on-arrival: Bool };
let .retain(t: PhiContextRow): PhiContextRow = (
   if t.discriminator-case-tag==(t as Tag::PhiContextRow).discriminator-case-tag {
      mark-as-released((t as Tag::PhiContextRow).phi-tt.retain);
      mark-as-released((t as Tag::PhiContextRow).blame.retain);
   };
   t
);
let .release(t: PhiContextRow): Nil = (
   if t.discriminator-case-tag==(t as Tag::PhiContextRow).discriminator-case-tag {
      (t as Tag::PhiContextRow).phi-tt.release;
      (t as Tag::PhiContextRow).blame.release;
   };
   mark-as-released(t);
);

type TypeContext implies MustRetain, MustRelease = { tctx:List<TypeContextRow>, pctx: List<PhiContextRow>, is-unsafe: Bool, is-blob: Bool, function-name:CString };
let .retain(t: TypeContext): TypeContext = (
   if t.discriminator-case-tag==(t as Tag::TypeContext).discriminator-case-tag {
       mark-as-released((t as Tag::TypeContext).tctx.retain);
       mark-as-released((t as Tag::TypeContext).pctx.retain);
   };
   t
);
let .release(t: TypeContext): Nil = (
   if t.discriminator-case-tag==(t as Tag::TypeContext).discriminator-case-tag {
      (t as Tag::TypeContext).tctx.release;
      (t as Tag::TypeContext).pctx.release;
   };
   mark-as-released(t);
);

let mk-tctx(): TypeContext = TypeContext( [] : List<TypeContextRow>, [] : List<PhiContextRow>, false, false, c"" );

let .key(tr: TypeContextRow): CString = (
   match tr {
      TypeContextRow{ key=key } => key;
      _ => c"";
   }
);
let .nt(tr: TypeContextRow): Type = (
   match tr {
      TypeContextRow{ nt=nt } => nt;
      _ => ta;
   }
);
let .dt(tr: TypeContextRow): Type = (
   match tr {
      TypeContextRow{ dt=dt } => dt;
      _ => ta;
   }
);
let .direct-type(tr: TypeContextRow): Type = (
   match tr {
      TypeContextRow{ nt=nt, dt=dt } => if non-zero(nt) then nt else dt;
      _ => ta;
   }
);
let .blame(tr: TypeContextRow): AST = (
   match tr {
      TypeContextRow{ blame=blame } => blame;
      _ => ASTEOF;
   }
);

let .phi-id(tr: PhiContextRow): CString = (
   match tr {
      PhiContextRow{ phi-id=phi-id } => phi-id;
      _ => c"";
   }
);
let .phi-tt(tr: PhiContextRow): Type = (
   match tr {
      PhiContextRow{ phi-tt=phi-tt } => phi-tt;
      _ => ta;
   }
);
let .blame(tr: PhiContextRow): AST = (
   match tr {
      PhiContextRow{ blame=blame } => blame;
      _ => ASTEOF;
   }
);
let .dead-on-arrival(tr: PhiContextRow): Bool = (
   match tr {
      PhiContextRow{ dead-on-arrival=dead-on-arrival } => dead-on-arrival;
      _ => false;
   }
);
