
# .find-callable is the central hub for all function and constructor calls
let .find-callable(tctx: TypeContext?, fname: CString, arg-types: Type, blame: AST): TypeContextRow = (
   tctx.find-callable(fname, arg-types, blame, ta);
);

let .find-callable(tctx: TypeContext?, fname: CString, arg-types: Type, blame: AST, return-type-hint: Type): TypeContextRow = (
   arg-types = denormalize-strong(arg-types);
   return-type-hint = denormalize-strong(return-type-hint);
   let match-set = mk-vector(type(TypeContextRow));
   for tr in tctx.lookups(fname) {
      # can-receive is an additional refinement on top of argument satisfaction
      # it is necessary for nullary or partial constructors that need a full type
      # like, None : TypeContext?
      if can-apply(tr.dt, arg-types) && (not(non-zero(return-type-hint)) || can-receive(tr.dt, return-type-hint)) {
         match-set = match-set.push(tr);
      }
   };
   let result = None : TypeContextRow?;
   for tr1 in match-set { if not(non-zero(result)) {
      let all-accept = true;
      for tr2 in match-set {
         if is(tr1,tr2) then ()
         else if most-special(tr1.dt,tr2.dt)!=tr1.dt then all-accept = false;
      };
      if all-accept { result = Some(tr1) };
   }};
   if not(non-zero(result)) && match-set.length > 0 {
      eprint("Unable to find unambiguous callable: \{fname} \{arg-types}\nAt: \{blame.location}\n");
      for tr in match-set {
         eprint("\{tr.dt}\n");
      };
      exit(1);
   };
   if not(non-zero(result)) then {
      print("Unable to find appropriate callable: \{fname} \{arg-types}\nAt: \{blame.location}\n");
      for tr in tctx.lookups(fname) {
         print("Candidate: \{tr.dt}\n");
      };
      exit(1);
   };
   result.get-or-panic
);
