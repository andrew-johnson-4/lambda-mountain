
let std-bind-term(tctx: Maybe<TypeContext>, key: CString, rhs: AST, def: AST, blame: AST, hint: Type): (TypeContext?, Type) = (
   let rhs-tt = tctx.with-phi(typeof-term(rhs), rhs);
   let tt = rhs-tt && t0(c"LocalVariable");
   tctx = tctx.bind(key, ta, tt, def);
   (tctx, tt)
);

let std-infer-expr(tctx: Maybe<TypeContext>, term: AST, is-scoped: Bool, used: IsUsed, hint: Type): (TypeContext?, AST) = (
   profile-visit-ast-unique(term);
   profile-visit-ast-equal(term);
   if not(term.is-free-and-seen) { match term {
      App{ left:Abs{def=lhs:Var{lname=key}, rhs:ASTNil{}, misc-tt=tt}, rhs=right } => (
         (tctx, let check-tt) = typeof-var-raw(term, tctx, lname, true);
         if check-tt.is-t(c"LocalVariable",0)
         then exit-error("Variable Name Is Already Bound In Outer Scope \{lname}", term);
         (tctx, let new-rhs) = std-infer-expr(tctx, rhs, false, Tail(), ta);
         if not(is(rhs,new-rhs)) then { rhs = new-rhs; term = mk-app(mk-abs(def,mk-nil(),misc-tt),rhs); };
         (tctx, let tt) = std-bind-term(tctx, lname, rhs, def, term, hint);
         tctx = tctx.ascript(def, tt);
         tctx = tctx.ascript(term, t0(c"Nil"));
      );
      App{o-t=left:Var{key:c"typeof"}, r=right} => (
         (tctx, let new-r) = std-infer-expr(tctx, r, is-scoped, Used, ta);
         if not(is(r,new-r)) then { r = new-r; term = mk-app(o-t, r); };
         tctx = tctx.ascript(o-t, t2(c"Arrow",typeof-term(r),t1(c"Type",typeof-term(r))));
         tctx = tctx.ascript(term, t1(c"Type",typeof-term(r)));
         tctx = tctx.phi-move(typeof-term(r), term);
      );
      App{o-t=left:Var{key:c"open"}, r=right} => (
         (tctx, let new-r) = std-infer-expr(tctx, r, false, Used(), ta);
         if not(is(r,new-r)) then { r = new-r; term = mk-app(o-t, r); };
         let deref-type = typeof-term(r);
         match deref-type.slot(c"Array",2) {
            TGround{tag:c"Array", parameters:[_.. TAny{}..]} => ();
            _ => (
               mark-var-to-def-todo(tctx, c"open", deref-type, o-t);
               (tctx, deref-type) = tctx.apply-callable(c"open", deref-type, term);
            );
         };
         tctx = tctx.ascript(term, deref-type);
      );
      App{szof=left:Var{key:c"sizeof"}, right:AType{}} => (
         let tt = t0(c"U64");
         tctx = tctx.ascript(term, tt);
         tctx = tctx.ascript(szof, tt);
      );
      App{szof=left:Var{key:c"scope"}, r=right} => (
         (let inner-tctx, let new-r) = std-infer-expr(tctx, r, true, Tail(), ta);
         tctx = tctx.with-pctx(inner-tctx.get-or(mk-tctx()).pctx);
         (tctx, new-r) = release-locals(tctx, inner-tctx, new-r, hint, false);
         if not(is(r,new-r)) then { r = new-r; term = mk-app(szof, r); };
         tctx = tctx.ascript(term, typeof-term(r));
      );
      App{szof=left:Var{key:c"unsafe"}, r=right} => (
         let direct-tctx = tctx.get-or(mk-tctx());
         let is-unsafe = direct-tctx.is-unsafe;
         direct-tctx.is-unsafe = true;
         (tctx, term) = std-infer-expr(Some(direct-tctx), r, false, Tail, ta);
         direct-tctx.is-unsafe = is-unsafe;
         tctx = Some(direct-tctx);
      );
      App{asc=left:Lit{key:c":"}, right:App{inner=left:ASTNil{},right:AType{tt=tt}}} => (
         tt = tt.rewrite-type-alias;
         add-concrete-type-instance(tt, term);
         tctx = tctx.ascript(inner, t0(c"Nil"));
         tctx = tctx.ascript(term, tt);
      );
      App{asc=left:Lit{key:c":"}, right:App{t=left,right:AType{tt=tt}}} => (
         if tt.is-t(c"Hashtable",2) { match t {
            App{ left:Var{key:c"map::cons"} } => tt = tt && t0(c"ReturnHint");
            App{ left:Var{key:c"mk-hashtable"} } => tt = tt && t0(c"ReturnHint");
            _ => ();
         }};
         if tt.is-t(c"Vector",1) { match t {
            App{ left:Var{key:c"mk-vector"} } => tt = tt && t0(c"ReturnHint");
            _ => ();
         }};
         if tt.is-t(c"String",0) {
            term = t.ascript(t0(c"CString") && t0(c"Literal"));
            term = mk-app(mk-var(c"intern"),term);
            (tctx, term) = std-infer-expr(tctx, term, false, Tail, ta);
         } else {
            tt = tt.rewrite-type-alias;
            add-concrete-type-instance(tt, term);
            (tctx, let new-t) = std-infer-expr(tctx, t, false, Tail, tt);
            if not(is(t,new-t)) then { t = new-t; term = mk-app(asc, mk-app(t, mk-atype(tt))); };
            if typeof-term(t).is-arrow and not(tt.is-arrow) and non-zero(var-name-if-var-or-lit(t)) {
               let ftype = tctx.find-callable( var-name-if-var-or-lit(t), t0(c"Nil"), term, tt ).direct-type;
               tctx = tctx.ascript(term, ftype);
            } else {
               tctx = tctx.ascript(term, typeof-term(t));
            };
            let direct-tctx = tctx.get-or(mk-tctx());
            if not(direct-tctx.is-blob or typeof-term(t).is-arrow) {
               # TODO: remove the special exception for "Arrows" here, which is a workaround for raw constructors
               # frontend is producing ((None : TContext?)()) instead of (None() : TContext?)
               # the return hint stuff is working, so all the hard work is done. I think only the frontend needs to change
               tt = tt.without-slot(c"ReturnHint",0).rewrite-type-alias;
               if not(can-unify(tt, typeof-term(term)))
               then exit-error("Ascripted value does not match declared type:\nExpected \{tt}\nFound \{typeof-term(t)}\n", term);
            };
         };
      );
      App{asc=left:Var{key:c"as"}, right:App{t=left,right:AType{tt=tt}}} => (
         let original-tt = tt;
         tt = tt.rewrite-type-alias.expand-implied-phi;
         add-concrete-type-instance(tt, term);
         (tctx, let new-t) = std-infer-expr(tctx, t, false, used, tt && hint);
         if not(is(t,new-t)) then { t = new-t; term = mk-app(asc, mk-app(t, mk-atype(tt))); };
         let inner-tt = typeof-term(t).normalize;
         if tt.simple-tag.has-prefix(c"Tag::") then tt = tt && inner-tt
         else tt = tt && inner-tt.with-only-datatype;
         if original-tt.is-t(c"Phi::State",1) {
            (tctx, tt) = tctx.phi-initialize(tt, term);
            if typeof-term(t).is-linear-live
            then tctx = tctx.phi-move(typeof-term(t), term);
         };
         tctx = tctx.ascript(term, tt);
      );
      App{left:App{ left:App{ ifv=left:Var{key:c"if"}, cond=right }, t=right }, f=right} => (
         let short-circuit = ASTEOF;
         match cond {
            App{ left:Var{key:c"<:"}, right:App{left:AType{lt=tt},right:AType{rt=tt}} } => (
               lt = denormalize-strong(lt.slot(c"Type",1).l1);
               rt = denormalize-strong(rt.slot(c"Type",1).l1);
               if non-zero(lt) and non-zero(rt) {
                  if can-unify(rt, lt) {
                     (tctx, short-circuit) = std-infer-expr(tctx, t, false, Tail, ta);
                  } else {
                     (tctx, short-circuit) = std-infer-expr(tctx, f, false, Tail, ta);
                  }
               };
            );
            _ => ();
         };
         if non-zero(short-circuit) {
            term = short-circuit;
         } else {
            let tctx-t = tctx;
            let tctx-f = tctx;
            if is-scoped {
               (let tctx-cond, let new-cond) = std-infer-expr(tctx, cond, false, Tail(), ta);
               (tctx-t, let new-t) = std-infer-expr(tctx-cond, t, false, Tail(), ta);
               (tctx-f, let new-f) = std-infer-expr(tctx, f, false, Tail(), ta);
               if not(is(cond,new-cond)) or not(is(t,new-t)) or not(is(f,new-f))
               then { cond = new-cond; t = new-t; f = new-f; term = mk-app(mk-app(mk-app(ifv,new-cond),new-t),new-f) };
               tctx = tctx.with-pctx( phi-merge(tctx,tctx-t.get-or(mk-tctx()).pctx,tctx-f.get-or(mk-tctx()).pctx,term) );
            } else {
               (tctx, let new-cond) = std-infer-expr(tctx, cond, false, Tail(), ta);
               (tctx-t, let new-t) = std-infer-expr(tctx, t, false, Tail(), ta);
               (tctx-f, let new-f) = std-infer-expr(tctx, f, false, Tail(), ta);
               (tctx-f, new-f) = release-locals(tctx, tctx-f, new-f, hint, false);
               tctx = tctx-t;
               if not(is(cond,new-cond)) or not(is(t,new-t)) or not(is(f,new-f))
               then { cond = new-cond; t = new-t; f = new-f; term = mk-app(mk-app(mk-app(ifv,new-cond),new-t),new-f) };
               tctx = tctx.with-pctx( phi-merge(tctx,tctx-t.get-or(mk-tctx()).pctx,tctx-f.get-or(mk-tctx()).pctx,term) );
            };
            if not(typeof-term(cond).is-t(c"Bool",0) or typeof-term(cond).is-t(c"U64",0)) {
               tctx.apply-callable(c"into-branch-conditional", typeof-term(cond), cond);
            };
            let lub = if typeof-term(f).is-t(c"Never",0) then typeof-term(t)
            else if typeof-term(t).is-t(c"Never",0) then typeof-term(f)
            else if typeof-term(f).is-t(c"Nil",0) or typeof-term(t).is-t(c"Nil",0) then t0(c"Nil")
            else { (tctx, let lub) = tctx.least-upper-bound(typeof-term(t), typeof-term(f), term); lub };
            tctx = tctx.ascript(term, lub);
            let term-phi-id = typeof-term(term).slot(c"Phi::Id",1).l1.simple-tag;
            let t-phi-id = typeof-term(t).slot(c"Phi::Id",1).l1.simple-tag;
            let f-phi-id = typeof-term(f).slot(c"Phi::Id",1).l1.simple-tag;
            if is-scoped {
               (tctx, term) = release-locals(tctx, tctx-t, term, hint, false ); # tctx-t includes both tctx-cond and tctx-t
               (tctx, term) = release-locals(tctx, tctx-f, term, hint, false );
            };
            if non-zero(term-phi-id) and term-phi-id != t-phi-id then tctx = tctx.phi-move(typeof-term(t), t);
            if non-zero(term-phi-id) and term-phi-id != f-phi-id then tctx = tctx.phi-move(typeof-term(f), f);
         }
      );
      ASTEOF{} => tctx = tctx.ascript(term, t0(c"Nil"));
      ASTNil{} => tctx = tctx.ascript(term, t0(c"Nil"));
      Meta{} => tctx = tctx.ascript(term, t0(c"Nil"));
      Typedef{} => ();
      AType{tt:TGround{tag:c"Type",parameters:[p1..]}} => tctx = tctx.ascript(term, t1(c"Type",p1.sanitize-phi));
      AType{tt=tt} => tctx = tctx.ascript(term, tt.sanitize-phi);
      Seq{seq=seq} => (
         let def-i = 0_sz;
         while def-i < seq.length { match seq[def-i] {
            Glb{val:Abs{}} => (
               (_, let new-r) = std-infer-expr(tctx, seq[def-i], false, Used(), hint);
               seq[def-i] = new-r;
               def-i = def-i + 1;
            );
            _ => def-i = def-i + 1;
         }};
      );
      Glb{key1=key, val=val} => (
         let rough-tt = typeof-term(term);
         if rough-tt.is-arrow and not(rough-tt.is-open) and not(rough-tt.is-t(c"TypedMacro",0)) {
            let tctx-tctx = tctx.get-or(mk-tctx());
            tctx-tctx.function-name = key1.key;
            tctx = Some(tctx-tctx);
            (let inner-tctx, let new-val) = std-infer-expr(tctx, val, is-scoped, Used(), ta);
            match new-val {
               Abs{lhs=lhs, old-wrapped-rhs=rhs:App{ akey=left:Lit{key:c":"}, right:App{ rhs=left, right:AType{rhs-tt=tt} } }, tlt=tt} => (
                  if not(tlt.is-t(c"Blob",0) or tlt.is-t(c"C-FFI",0) or tlt.is-t(c"FFI",0) or tlt.is-t(c"Phi::Source",0) ) {
                     validate-pctx-release(inner-tctx);
                  };
               );
               _ => ();
            };
            if not(is(val,new-val))  then {
               let new-term = mk-glb(key1,new-val);
               mark-var-to-def(new-term, term);
               term = new-term;
            };
         };
      );
      Var{key2=key, token=token} => (
         (tctx, let vt) = typeof-var(term, tctx, key2, hint.is-t(c"MustNotFresh",0) or hint.is-t(c"TailPosition",0));
         vt = tctx.with-phi(vt, term);
         mark-var-to-def-todo(tctx, key2, ta, term);
         # TailPosition LocalVariables don't need to be retained because +1/-1 retain/release cancels itself out
         if not(hint.is-t(c"TailPosition",0) and vt.is-t(c"LocalVariable",0))
         and not(hint.is-t(c"MustNotRetain",0))
         and not(tctx.get-or(mk-tctx()).is-blob) {
            tctx = tctx.ascript(term, vt);
            (tctx, term) = maybe-retain(tctx, term);
         } else {
            tctx = tctx.ascript(term, vt);
         };
      );
      Lit{key3=key, token=token} => (
         if hint.is-t(c"Literal",0) {
            tctx = tctx.ascript(term,hint);
         } else if not(non-zero(typeof-term(term))) {
            if hint.is-t(c"HashtableEq",2) and hint.is-datatype and key3==c"HashtableEqEOF"
            then {
               (tctx, let lit-tt) = tctx.apply-callable(key3, t0(c"Nil"), term, hint);
               tctx = tctx.ascript(term, lit-tt);
            } else {
               tctx = tctx.ascript(term, t2(c"Arrow",t0(c"Any"),t0(c"Any")));
            }
         }
      );
      Abs{lhs=lhs, rhs=rhs:App{asc=left:Lit{key:c":"},right:App{inner-rhs=left, right:AType{return-type=tt}}}, misc-tt=tt} => (
         let direct-tctx = tctx.get-or(mk-tctx());
         direct-tctx.is-blob = misc-tt.is-t(c"Blob",0);
         tctx = Some(direct-tctx);
         let before-tctx = tctx; # make sure to capture locals as "local" scope
         tctx = infer-ctx(tctx, lhs);
         if not(inner-rhs.is-nil) {
            return-type = return-type.rewrite-type-alias.expand-implied-phi;
            (tctx, let new-inner-rhs) = std-infer-expr(tctx, inner-rhs, false, Tail(), return-type && t0(c"TailPosition"));
            if not(direct-tctx.is-blob) {
               let return-type-after-alias = return-type.rewrite-type-alias;
               if not(can-unify(return-type-after-alias, typeof-term(new-inner-rhs)))
               then exit-error("Return value does not match declared type:\nExpected \{return-type-after-alias}\nFound \{typeof-term(new-inner-rhs)}\n", term);
            };
            tctx = tctx.phi-move(typeof-term(new-inner-rhs), term);
            if not(tctx.get-or(mk-tctx()).is-blob) {
               (tctx, new-inner-rhs) = release-locals(before-tctx, tctx, new-inner-rhs, misc-tt, true);
            };
            if not(is(inner-rhs,new-inner-rhs))
            then {
               inner-rhs = new-inner-rhs;
               rhs = mk-app(asc.unique,mk-app(inner-rhs,mk-atype(return-type)));
               term = mk-abs(lhs,rhs,misc-tt);
            };
            if not(misc-tt.is-t(c"Blob",0)) and not(misc-tt.is-t(c"C-FFI",0)) then tctx = tctx.ascript(inner-rhs, return-type);
         };
         tctx = tctx.ascript(rhs, return-type);
         let domain-tt = typeof-lhs(lhs);
         tctx = tctx.ascript(term, t2(c"Arrow", typeof-lhs(lhs), return-type.without-modifiers) && misc-tt);
      );
      App{ is-cons=is-cons, l=left, r=right } => (
         let is-macro = false;
         if is-cons {
            let lhint = hint.slot(c"Cons",2).l1 && hint.slot(c"MustNotRetain",0) && hint.slot(c"MustNotFresh",0);
            let rhint = hint.slot(c"Cons",2).l2 && hint.slot(c"MustNotRetain",0) && hint.slot(c"MustNotFresh",0) && hint.slot(c"TailPosition",0);
            (tctx, let new-l) = std-infer-expr(tctx, l, false, if used.is-call then used else Unused, lhint);
            let r-used = if used.is-tail then used else Used;
            if typeof-term(new-l).is-arrow then r-used = Call(var-name-if-var-or-lit(new-l)); # if l was a macro then it could be macro::concat
            (tctx, let new-r) = std-infer-expr(tctx, r, false, if used.is-tail then used else if used.is-unused then used else Used, rhint);
            if not(is(l,new-l)) or not(is(r,new-r)) then { l = new-l; r = new-r; term = mk-cons(new-l, new-r) };
            tctx = tctx.ascript(term, if used.is-tail then typeof-term(r) else t2(c"Cons", typeof-term(l), typeof-term(r)));
         } else {
            let rt = ta;
            if index-macro-table.has(var-name-if-var(l)) {
               (tctx, term) = std-apply-macro(tctx, term, used);
               is-macro = true;
            } else {
               (tctx, let new-l) = std-infer-expr(tctx, l, false, used, ta);
               if not(is(l,new-l)) then { l = new-l; term = mk-app(l,r); };
               if typeof-term(l).is-arrow {
                  let direct-hint = hint-if-hint(l);
                  if hint.is-t(c"ReturnHint",0) then direct-hint = direct-hint && hint;
                  let rr-args-hint = if var-name-if-var-or-lit(l)==c".retain" or var-name-if-var-or-lit(l)==c".release" or var-name-if-var-or-lit(l)==c"destroy"
                  then t0(c"MustNotRetain") else ta;
                  if var-name-if-var-or-lit(l)==c".release" then rr-args-hint = rr-args-hint && t0(c"MustNotFresh");
                  let pre-retain-tctx = tctx;
                  (tctx, let new-r) = std-infer-call-arg(tctx, r, var-name-if-var-or-lit(l), rr-args-hint);
                  let ftype = tctx.find-callable( var-name-if-var-or-lit(l), typeof-term(new-r), term, direct-hint ).direct-type;
                  if typeof-term(l) == t2(c"Arrow",t0(c"Any"),t0(c"Any")) {
                     tctx = tctx.ascript(l, ftype);
                  };
                  if ftype.domain.is-any-arg-t(c"MustNotRetain",0) {
                     pre-retain-tctx = pre-retain-tctx.phi-append-dead-on-arrival(tctx);
                     (tctx, new-r) = std-infer-call-arg(pre-retain-tctx, r, var-name-if-var-or-lit(l), ftype.domain && rr-args-hint);
                  };
                  if not(is(l,new-l)) or not(is(r,new-r)) then { l = new-l; r = new-r; term = mk-app(l,r); };
               } else {
                  (tctx, let new-r) = std-infer-expr(tctx, r, false, Used, ta);
                  if not(is(l,new-l)) or not(is(r,new-r)) then { l = new-l; r = new-r; term = mk-app(l,r); };
               };

               (tctx, let function-type, rt) = if typeof-term(l).is-arrow and non-zero(lit-name-if-lit(l)) {
                  let direct-hint = hint-if-hint(l);
                  if hint.is-t(c"ReturnHint",0) then direct-hint = direct-hint && hint;
                  let function-type = tctx.find-callable(var-name-if-var-or-lit(l), typeof-term(r), term, direct-hint).nt-or-zero;
                  (tctx, rt) = tctx.apply-callable(lit-name-if-lit(l), typeof-term(r), term, direct-hint);
                  (tctx, function-type, rt)
               } else if typeof-term(l).is-arrow and non-zero(var-name-if-var-or-lit(l)) {
                  let direct-hint = ta;
                  if hint.is-t(c"ReturnHint",0) then direct-hint = direct-hint && hint;
                  let function-type = tctx.find-callable(var-name-if-var-or-lit(l), typeof-term(r), term, direct-hint).nt-or-zero;
                  (tctx, rt) = tctx.apply-callable(var-name-if-var-or-lit(l), typeof-term(r), term, direct-hint);
                  (tctx, function-type, rt)
               } else {
                  (tctx, ta, t2(c"Cons", typeof-term(l), typeof-term(r)))
               };
               if not(used.is-call) { rt = rt.cons-tail-or-self; };
               if var-name-if-var-or-lit(l)==c"mov" and typeof-term(r).is-t(c"Cons",2) {
                  let from-tt = typeof-term(r).slot(c"Cons",2).l1;
                  let to-tt = typeof-term(r).slot(c"Cons",2).l2;
                  tctx = tctx.phi-override(to-tt, from-tt, term);
                  if from-tt.is-t(c"Phi::Id",1) and from-tt.slot(c"Phi::Id",1).l1.simple-tag != to-tt.slot(c"Phi::Id",1).l1.simple-tag {
                     tctx = tctx.phi-move(from-tt, term);
                  };
               };

               rt = tctx.with-phi(rt, term);
               tctx = tctx.ascript(term, rt);

               let is-released-after-call = false;
               if not(r.is-var-or-ascripted-var) {
                  # if a field access is not retained and is just a variable reference then it shouldn't be released after the call
                  # this is complicated to do in the type system atm, so we just hard code it for now
                  # TODO: revisit and generalize this
                  # Example:
                  #    x.data.release
                  (tctx, let prefix, let postfix, let new-args) = std-maybe-release-after-call(tctx, function-type, r);
                  if non-zero(postfix) {
                     is-released-after-call = true;
                     if not(is(r,new-args)) { term = mk-app(l,new-args); ascript-force(term,rt); };

                     let tmp-id = uuid();
                     let tmp-def = mk-var(tmp-id); ascript-force(tmp-def, typeof-term(term));
                     let tmp-var = mk-var(tmp-id); ascript-force(tmp-var, typeof-term(term));
                     tctx = tctx.bind(tmp-id, ta, typeof-term(term), tmp-def);
                     mark-var-to-def-todo(tctx, tmp-id, ta, tmp-var);
                     let tmp-nil = mk-nil(); ascript-force(tmp-nil, t0(c"Nil"));
                     let declare = mk-abs(tmp-def, tmp-nil, ta); ascript-force(declare, t0(c"Nil"));
                     if function-type.is-t(c"MustRetainOnCall",0) and not(hint.is-t(c"MustNotRetain",0)) and not(tctx.get-or(mk-tctx()).is-blob) {
                        (tctx, term) = maybe-retain(tctx, term);
                     };
                     let bind = mk-app(declare, term); ascript-force(bind, t0(c"Nil"));

                     let new-term = bind;
                     if non-zero(prefix) {
                        new-term = mk-cons(prefix, new-term); ascript-force(new-term, t0(c"Nil"));
                     };
                     new-term = mk-cons(new-term, postfix); ascript-force(new-term, typeof-term(postfix));
                     new-term = mk-cons(new-term, tmp-var); ascript-force(new-term, typeof-term(term));
                     term = new-term;
                  };
               };
               if not(is-released-after-call) and not(rt.is-t(c"Cons",2)) {
                  if function-type.is-t(c"MustRetainOnCall",0) and not(hint.is-t(c"MustNotRetain",0)) and not(tctx.get-or(mk-tctx()).is-blob) {
                     (tctx, term) = maybe-retain(tctx, term);
                  }
               };
            };
         };

         if not(is-macro) and not(is-cons) and typeof-term(l).is-arrow and non-zero(var-name-if-var(l)) {
            mark-var-to-def-todo(tctx, var-name-if-var(l), typeof-term(r), l);
         };
      );
      _ => fail("Unexpected Term in std-infer-expr at \{term.location}\n\{term}\n");
   };
   if used.is-unused and typeof-term(term).slot(c"Phi::State",1).is-linear-live {
      if typeof-term(term).slot(c"Phi::State",1).l1.is-t(c"MustRelease::ToRelease",1) {
         (tctx, term) = wrap-call(tctx, c".release", term);
      } else if typeof-term(term).is-t(c"MustRetain",0) {
         tctx = tctx.phi-move(typeof-term(term),term);
      }
   }};
   (tctx, term);
);

let wrap-call(tctx: TypeContext?, fname: CString, term: AST): (TypeContext?, AST) = (
   let args-type = typeof-term(term);
   let function-type = typeof-term(tctx.find-callable(fname, args-type, term).blame-or-zero);
   let function-term = mk-var(fname); tctx = tctx.ascript(function-term, function-type);
   let result = mk-app(function-term, term);
   (tctx, let result-type) = tctx.apply-callable(fname, args-type, term);
   tctx = tctx.ascript(result, result-type);
   (tctx, result)
);

let std-infer-call-arg(tctx: TypeContext?, term: AST, function-name: CString, hint: Type): (TypeContext?, AST) = (
   let feq = function-name==c"list::cons";
   if function-name==c"list::cons" { match term {
      App{k=left, m=right} => (
         (tctx, let new-k) = std-infer-expr(tctx, k, false, Call(function-name), ta);
         match m {
            App{ constructor=left:Lit{key:c"LEOF"}, arg=right:ASTNil{} } => (
               m = mk-app( constructor.ascript(t1(c"List",typeof-term(new-k).normalize)), arg );
               term = mk-cons(k, m);
            );
            _ => ();
         };
         (tctx, let new-m) = std-infer-expr(tctx, m, false, Used(), ta);
         if not(is(k,new-k)) or not(is(m,new-m)) then { k = new-k; m = new-m; term = mk-cons(k, m); };
         tctx = tctx.ascript(term, t2(c"Cons",typeof-term(k),typeof-term(m)));
         (tctx, term)
      );
      _ => (tctx, term);
   }} else if function-name==c"map::cons" { match term {
      App{k=left, m=right} => (
         (tctx, let new-k) = std-infer-expr(tctx, k, false, Call(function-name), ta);
         let direct-hint = if config-v3 or config-v23
         then t2(c"Hashtable",typeof-term(new-k).normalize.slot(c"Cons",2).l1,typeof-term(new-k).normalize.slot(c"Cons",2).l2) && t0(c"ReturnHint")
         else t2(c"HashtableEq",typeof-term(new-k).normalize.slot(c"Cons",2).l1,typeof-term(new-k).normalize.slot(c"Cons",2).l2);
         (tctx, let new-m) = std-infer-expr(tctx, m, false, Used(), direct-hint);
         if not(is(k,new-k)) or not(is(m,new-m)) then { k = new-k; m = new-m; term = mk-cons(k, m); };
         tctx = tctx.ascript(term, t2(c"Cons",typeof-term(k),typeof-term(m)));
         (tctx, term)
      );
      _ => (tctx, term);
   }} else std-infer-expr(tctx, term, false, Call(function-name), hint);
);
