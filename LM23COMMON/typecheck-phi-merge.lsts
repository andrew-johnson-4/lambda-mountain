
let phi-merge(tctx-globals: TypeContext?, tctx-primary: List<PhiContextRow>, tctx-secondary: List<PhiContextRow>, blame: AST): List<PhiContextRow> = (
   let seen = mk-vector(type(CString));
   for list Tuple{ sid=phi-id-or-zero, st=phi-tt-or-zero, pblame=blame-or-zero, sdead-on-arrival=dead-on-arrival-or-zero, sis-global=is-global-or-zero } in tctx-secondary {
      if not(seen.contains(sid)) {
         let pt = tctx-primary.lookup(sid);
         if not(non-zero(pt)) then tctx-primary = cons( PhiContextRow(sid,st,pblame,sdead-on-arrival,sis-global), tctx-primary )
         else if sdead-on-arrival or pt.dead-on-arrival-or-zero
         then {
            # This case happens if an ethereal variable gets copied and merged somehow, it doesn't really matter which one you pick but we prefer the moved one
            if not(pt.phi-tt-or-zero.is-linear-live) then ()
            else tctx-primary = cons( PhiContextRow(sid,st,blame,true,sis-global), tctx-primary );
         } else (
            let rt = tctx-globals.phi-merge(pt.phi-tt-or-zero, st, blame);
            if not(is(pt.phi-tt-or-zero,rt)) then tctx-primary = cons( PhiContextRow(sid,rt,blame,false,sis-global), tctx-primary );
         );
         seen = seen.push(sid);
      };
   };
   tctx-primary
);
