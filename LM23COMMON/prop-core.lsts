
let quick-prop = {} : HashtableEq<(CString,U64),List<(Type,Type)>>;

let add-quick-prop(pre: Type, pat: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = quick-prop.lookup(key, ([] : List<(Type,Type)>));
   val = cons( (pat,post), val );
   quick-prop = quick-prop.bind( key, val );
);

let enrich-quick-prop(base: Type): Type = (
   # call twice to infer second-degree props without risk of diverging
   let original-base = base;
   base = enrich-quick-prop(base, base);
   base = enrich-quick-prop(base, base);
   if original-base != base then print("Enriched \{original-base} => \{base}\n");
   base
);

let enrich-quick-prop(base: Type, pre: Type): Type = (
   match pre {
      TGround {} => (
         for Tuple { lt=first, rt=second } in quick-prop.lookup( pre.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
            if base <: lt then (
               let post = if rt.is-open then (
                  let tctx = unify(lt, base, ASTEOF);
                  tctx.substitute(rt);
               ) else rt;
               if not(base <: post) {
                  pre = pre && post;
               };
            );
         };
      );
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type));
         for c in conjugate {
            match enrich-quick-prop(base, c) {
               TAnd{rconjugate=conjugate} => for rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then (pre = ta)
         else if result.length==1 then (pre = result[0])
         else (pre = tand(result));
      );
      _ => ();
   };
   pre
);

let weaken-quick-prop-index = {} : HashtableEq<(CString,U64),List<(Type,Type)>>;

# core implicit weakening rules
add-weaken-quick-prop( t1(c"Constructor",ta), ta, t1(c"Constructor",ta) );
add-weaken-quick-prop( t1(c"CaseNumber",ta), ta, t1(c"CaseNumber",ta) );
add-weaken-quick-prop( t0(c"Constructor"), ta, t0(c"Constructor") );
add-weaken-quick-prop( t0(c"C-FFI"), ta, t0(c"C-FFI") );
add-weaken-quick-prop( t0(c"Raw"), ta, t0(c"Raw") );
add-weaken-quick-prop( t0(c"LMStruct"), ta, t0(c"LMStruct") );
add-weaken-quick-prop( t0(c"Constant"), ta, t0(c"Constant") );
add-weaken-quick-prop( t0(c"Literal"), ta, t0(c"Literal") );
add-weaken-quick-prop( t0(c"LocalVariable"), ta, t0(c"LocalVariable") );
add-weaken-quick-prop( t0(c"GlobalVariable"), ta, t0(c"GlobalVariable") );
add-weaken-quick-prop( t0(c"FlexibleArrayMember"), ta, t0(c"FlexibleArrayMember") );
add-weaken-quick-prop( t0(c"MustNotRetain"), ta, t0(c"MustNotRetain") );
add-weaken-quick-prop( t0(c"MustNotMove"), ta, t0(c"MustNotMove") );
add-weaken-quick-prop( t1(c"Phi::Transition",ta), ta, t1(c"Phi::Transition",ta) );
add-weaken-quick-prop( t1(c"Phi::Initialize",ta), ta, t1(c"Phi::Initialize",ta) );
add-weaken-quick-prop( t1(c"Phi::State",ta), ta, t1(c"Phi::State",ta) );

let add-weaken-quick-prop(pre: Type, pat: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = weaken-quick-prop-index.lookup(key, ([] : List<(Type,Type)>));
   val = cons( (pat,post), val );
   weaken-quick-prop-index = weaken-quick-prop-index.bind( key, val );
);

let weaken-quick-prop(base: Type): Type = (
   let rt = weaken-quick-prop(base, base);
   #print("Weaken \{base} => \{rt}\n");
   rt
);

let weaken-quick-prop(original-base: Type, base: Type): Type = (
   match base {
      TGround { tag=tag, parameters=parameters } => (
         for Tuple { lt=first, rt=second } in weaken-quick-prop-index.lookup( base.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
            if can-unify(lt, original-base) then (
               base = remove-info(base, rt);
            );
         };
         if non-zero(base)
         then {
            let new-parameters = [] : List<Type>;
            for p in parameters.reverse {
               new-parameters = cons( weaken-quick-prop(p) , new-parameters );
            };
            base = ts(tag,new-parameters);
         }
      );
      TAnd { conjugate=conjugate } => (
         let new-conjugate = mk-vector(type(Type));
         for c in conjugate {
            c = weaken-quick-prop(original-base, c);
            if non-zero(c) then new-conjugate = new-conjugate.push(c);
         };
         base = if new-conjugate.length==0 then ta
         else   if new-conjugate.length==1 then new-conjugate[0]
         else   tand(new-conjugate);
      );
      _ => ();
   };
   base
);
