
let quick-prop = {} : Hashtable<(CString,U64),List<(Type,Type)>>;

let add-quick-prop(pre: Type, pat: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = quick-prop.lookup(key, ([] : List<(Type,Type)>));
   val = cons( (pat,post), val );
   quick-prop = quick-prop.bind( key, val );
);

let .enrich(base: Type): Type = (
   # call twice to infer second-degree props without risk of diverging
   base = enrich-quick-prop(base, base);
   base = enrich-quick-prop(base, base);
   base
);

let .enrich-strong(base: Type): Type = (
   match base {
      TGround { tag:c"Cons", parameters:[p2..p1..] } => (
         base = t2(c"Cons", p1.enrich-strong, p2.enrich-strong);
      );
      TGround { tag:c"Arrow", parameters:[p2..p1..] } => (
         base = t2(c"Arrow", p1.enrich-strong, p2.enrich-strong);
      );
      TGround { tag:c"Array", parameters:[p2..p1..] } => (
         base = t2(c"Array", p1.enrich-strong, p2.enrich-strong);
      );
      #TGround { tag=tag, parameters=parameters } => ( if not(tag.has-prefix(c"Field::") and parameters.length==1) then {
      #   let new-parameters = [] : List<Type>;
      #   for list p in parameters.reverse {
      #      new-parameters = cons( p.enrich-strong, new-parameters );
      #   };
      #   base = ts(tag,new-parameters);
      #});
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type));
         for vector c in conjugate {
            match c.enrich-strong {
               TAnd{rconjugate=conjugate} => for vector rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then (base = ta)
         else if result.length==1 then (base = result[0])
         else (base = tand(result));
      );
      _ => ();
   };
   base.enrich
);

let enrich-quick-prop(base: Type, pre: Type): Type = (
   match pre {
      TGround { tag=tag, parameters=parameters } => (
         for list row in quick-prop.lookup( pre.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
            let lt = row.first;
            let rt = row.second;
            if base <: lt then (
               let post = if rt.is-open then (
                  let tctx = unify(lt, base, ASTEOF);
                  tctx.substitute(rt);
               ) else rt;
               if not(pre <: post) and not(base <: post) {
                  pre = pre && post;
               };
            );
         };
         if tag==c"Array" and parameters.length==2 {
            for list row in quick-prop.lookup( (c"Array",2_u64), ([] : List<(Type,Type)>) ) {
               let lt = row.first;
               let rt = row.second;
               if base <: lt then (
                  let post = if rt.is-open then (
                     let tctx = unify(lt, base, ASTEOF);
                     tctx.substitute(rt);
                  ) else rt;
                  if not(pre <: post) and not(base <: post) {
                     pre = pre && post;
                  };
               );
            };
         };
      );
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type));
         for vector c in conjugate {
            match enrich-quick-prop(base, c) {
               TAnd{rconjugate=conjugate} => for vector rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then (pre = ta)
         else if result.length==1 then (pre = result[0])
         else (pre = tand(result));
      );
      _ => ();
   };
   pre
);

let weaken-quick-prop-index = {} : Hashtable<(CString,U64),List<(Type,Type)>>;

# core implicit weakening rules
add-weaken-quick-prop( t1(c"Constructor",ta), t1(c"Constructor",ta), t1(c"Constructor",ta) );
add-weaken-quick-prop( t1(c"CaseNumber",ta), t1(c"CaseNumber",ta), t1(c"CaseNumber",ta) );
add-weaken-quick-prop( t0(c"Constructor"), ta, t0(c"Constructor") );
add-weaken-quick-prop( t0(c"C-FFI"), ta, t0(c"C-FFI") );
add-weaken-quick-prop( t0(c"Raw"), ta, t0(c"Raw") );
add-weaken-quick-prop( t0(c"LMStruct"), ta, t0(c"LMStruct") );
add-weaken-quick-prop( t0(c"Constant"), ta, t0(c"Constant") );
add-weaken-quick-prop( t0(c"Literal"), ta, t0(c"Literal") );
add-weaken-quick-prop( t0(c"LocalVariable"), ta, t0(c"LocalVariable") );
add-weaken-quick-prop( t0(c"GlobalVariable"), ta, t0(c"GlobalVariable") );
add-weaken-quick-prop( t0(c"FlexibleArrayMember"), ta, t0(c"FlexibleArrayMember") );
add-weaken-quick-prop( t0(c"MustNotRetain"), ta, t0(c"MustNotRetain") );
add-weaken-quick-prop( t0(c"MustNotMove"), ta, t0(c"MustNotMove") );
add-weaken-quick-prop( t0(c"MustNotFresh"), ta, t0(c"MustNotFresh") );
add-weaken-quick-prop( t2(c"Array",ta,ta), t0(c"Sized"), t0(c"Sized") );
add-weaken-quick-prop( t1(c"Field::",ta), ta, t1(c"Field::",ta) );
add-weaken-quick-prop( t0(c"Tag::"), ta, t0(c"Tag::") );

let add-weaken-quick-prop(pre: Type, pat: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = weaken-quick-prop-index.lookup(key, ([] : List<(Type,Type)>));
   val = cons( (pat,post), val );
   weaken-quick-prop-index = weaken-quick-prop-index.bind( key, val );
);

let .weaken(base: Type): Type = (
   weaken-quick-prop(base, base, base)
);

let weaken-quick-prop(original-base: Type, base: Type, pre: Type): Type = (
   let early-base = base;
   match pre {
      TGround { tag=tag, parameters=parameters } => (
         for list row in weaken-quick-prop-index.lookup( pre.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
            let lt = row.first;
            let rt = row.second;
            if can-unify(lt, original-base) then (
               base = remove-info(base, rt);
            );
         };
         if tag==c"Array" and parameters.length==2 {
            for list row in weaken-quick-prop-index.lookup( (c"Array",2_u64), ([] : List<(Type,Type)>) ) {
               let lt = row.first;
               let rt = row.second;
               if can-unify(lt, original-base) then (
                  base = remove-info(base, rt);
               );
            }
         };
         if tag.contains(c"::") {
            let tag-parts = tag.split(c"::").into(type(Vector<CString>));
            let tag-base = tag-parts[0] + c"::";
            let ti = 1_sz;
            while ti < tag-parts.length {
               let tag-part = tag-parts[ti];
               for list row in weaken-quick-prop-index.lookup( (tag-base, parameters.length as U64), ([] : List<(Type,Type)>) ) {
                  let lt = row.first;
                  let rt = row.second;
                  if can-unify(lt, original-base) then (
                     base = remove-info(base, rt);
                  );
               };
               tag-base = tag-base + tag-part + c"::";
               ti = ti + 1;
            };
         };
      );
      TAnd { conjugate=conjugate } => (
         for vector c in conjugate { base = weaken-quick-prop(original-base, base, c) };
      );
      _ => ();
   };
   match base {
      TGround { tag2=tag, parameters=parameters } => (
         let new-parameters = [] : List<Type>;
         for list p in parameters.reverse {
            new-parameters = cons( p.weaken , new-parameters );
         };
         base = ts(tag2,new-parameters);
      );
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type));
         for vector c in conjugate {
            match c {
               TGround { tag3=tag, parameters=parameters } => (
                  let new-parameters = [] : List<Type>;
                  for list p in parameters.reverse {
                     new-parameters = cons( p.weaken , new-parameters );
                  };
                  result = result.push(ts(tag3,new-parameters));
               );
               _ => result = result.push(c);
            }
         };
         base = if result.length==0 then ta
         else   if result.length==1 then result[0]
         else   tand(result);
      );
      _ => ();
   };
   base
);
