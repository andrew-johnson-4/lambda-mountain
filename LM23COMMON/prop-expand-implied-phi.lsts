
let implied-phi-index = {} : Hashtable<(CString,U64),Type>;

let .expand-implied-phi(tt: Type): Type = (
   let original-tt = tt;
   if not(tt.is-t(c"Phi::State",1)) then match tt {
      TAnd{conjugate=conjugate} => (
         tt = tand(conjugate);
         for vector c in conjugate {
            let ga = c.ground-tag-and-arity;
            let ip = implied-phi-index.lookup(ga,ta);
            let ps = t1(c"Phi::State",ip);
            if non-zero(ip) and not(can-unify(ps, tt)) {
               tt = tt.extend(ps)
            }
         }
      );
      TGround{tag:c"Cons",parameters:[t1..t0..]} => (
         tt = t2(c"Cons", t0.expand-implied-phi, t1.expand-implied-phi);
      );
      TGround{} => (
         let ga = tt.ground-tag-and-arity;
         let ip = implied-phi-index.lookup(ga,ta);
         let ps = t1(c"Phi::State",ip);
         if non-zero(ip) and not(can-unify(ps, tt)) {
            tt = tt.extend(ps)
         }
      );
      _ => ();
   };
   tt
);
