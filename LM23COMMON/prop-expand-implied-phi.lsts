
let implied-phi-index = {} : HashtableEq<(CString,U64),Type>;

let .expand-implied-phi(tt: Type): Type = (
   let original-tt = tt;
   match tt {
      TAnd{conjugate=conjugate} => (
         for c in conjugate {
            let ga = c.ground-tag-and-arity;
            let ip = implied-phi-index.lookup(ga,ta);
            let ps = t1(c"Phi::State",ip);
            if non-zero(ip) and not(can-unify(ps, tt)) {
               tt = tt && ps
            }
         }
      );
      TGround{tag:c"Cons",parameters:[t1..t0..]} => (
         tt = t2(c"Cons", t0.expand-implied-phi, t1.expand-implied-phi);
      );
      TGround{} => (
         let ga = tt.ground-tag-and-arity;
         let ip = implied-phi-index.lookup(ga,ta);
         let ps = t1(c"Phi::State",ip);
         if non-zero(ip) and not(can-unify(ps, tt)) {
            tt = tt && ps
         }
      );
      _ => ();
   };
   tt
);
