
let .ascript(tctx: TypeContext?, t: AST, tt: Type): TypeContext? = (
   tt = tctx.with-phi(tt, t);
   if non-zero(tt) {
      let prev-tt = typeof-term(t);
      if non-zero(prev-tt) {
         let norm-tt = tt.normalize.without-phi;
         if not(norm-tt.is-arrow) {
            if not(prev-tt <: norm-tt) {
               exit-error("Type Ascription Inequality\n\{typeof-term-normal(t)} does not imply \{norm-tt}", t);
            }
         };
         if tt.slot(c"Phi::Id",1).l1.simple-tag != prev-tt.slot(c"Phi::Id",1).l1.simple-tag {
            tctx = tctx.phi-move(prev-tt, t);
         }
      };
      ascript-force(t, tt);
   };
   tctx
);

let ascript-force(t: AST, tt: Type): Nil = (
   add-concrete-type-instance(tt, t);
   ascript-natural(t, tt);

   # these initializations are necessary to prevent stale phi types
   # I don't remember why that is, but just try removing them and debug from there
   type-index-normal = type-index-normal.bind(t, ta);
   type-index-denormal = type-index-denormal.bind(t, ta);

   types-have-changed = true;
);
