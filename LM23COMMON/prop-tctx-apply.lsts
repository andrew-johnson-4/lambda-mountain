
let .apply(tctx: TypeContext?, fname: CString, ft: Type, at: Type, blame: AST): (TypeContext?, TypeContext?, Type, Type) = (
   tctx.apply(fname, ft, at, blame, ta);
);

let .apply(tctx: TypeContext?, fname: CString, ft: Type, at: Type, blame: AST, return-type-hint: Type): (TypeContext?, TypeContext?, Type, Type) = (
   # Fail if arguments are not accepted by function (<:)
   if not(can-apply(ft, at)) then exit-error("Unable to apply function \{fname}\nFunction: \{ft}\nArguments: \{at}", blame);

   # Apply function, then normalize the unification context
   let apply-tctx = if non-zero(return-type-hint)
   then unify(ft.range, return-type-hint, blame).normalize.without-phi-keep-state
   else unify(ft.domain, at, blame).normalize.without-phi-keep-state;

   # Fail if arguments are not accepted by function (unify)
   if apply-tctx.is-none then exit-error("Unable to apply (unify) function \{fname}\nFunction: \{ft}\nArguments: \{at}", blame);

   # Assert that all equal type variables also have equal datatype
   let apply-type-variables = {} : Hashtable<CString,Type>;
   for list tr in apply-tctx.get-or-panic.tctx {
      if apply-type-variables.has(tr.key-or-zero) {
         let previous-seen-tt = apply-type-variables.lookup(tr.key-or-zero, ta).datatype;
         let current-seen-tt = tr.direct-type.datatype;
         if previous-seen-tt != current-seen-tt {
            if previous-seen-tt.is-t(c"Sized",1) and tr.direct-type.datatype <: previous-seen-tt.slot(c"Sized",1).l1 {
               # no change necessary, type in context is already the erased type
            } else if current-seen-tt.is-t(c"Sized",1) and apply-type-variables.lookup(tr.key-or-zero, ta) <: current-seen-tt.slot(c"Sized",1).l1 {
               # type in context must be updated to the erased type
               apply-type-variables = apply-type-variables.bind(tr.key-or-zero, current-seen-tt);
            } else {
               print("First type variable \{tr.key-or-zero} occurence: \{previous-seen-tt}\n");
               print("Second type variable \{tr.key-or-zero} occurence: \{current-seen-tt}\n");
               exit-error("Type variables \{tr.key-or-zero} not equal in call to \{fname}\nFunction: \{ft}\nArguments: \{at}\nReturn Hint: \{return-type-hint}\n", blame);
            }
         }
      } else {
         apply-type-variables = apply-type-variables.bind(tr.key-or-zero, tr.direct-type)
      }
   };

   # Phi: fail if any used arguments have already been moved
   # TODO: remove the fname!=c"destroy" hard coded workaround: if the function accepts MustRelease::Released then this error does not apply
   if not(tctx.get-or(mk-tctx()).is-blob) and at.is-moved and fname!=c"destroy"
   then exit-error("Linear value used after move in call to \{fname}\nFunction: \{ft}\nArguments: \{at}", blame);

   # Phi: apply transitions, like (A ~> B)
   for list pr in apply-tctx.get-or(mk-tctx()).pctx {
      tctx = tctx.bind-phi(pr.phi-id-or-zero, pr.phi-tt-or-zero, pr.blame-or-zero);
   };

   # Phi: move linear values, like (Linear<A> ~> Linear<Phi::Moved>)
   tctx = tctx.phi-move-args(ft.domain, at, blame);

   # Specialize the function type
   let closed-type = apply-tctx.substitute(ft).without-phi-keep-state;

   # Fail if specialized function is still open
   if closed-type.is-open
   then exit-error("Unification did not close all open type variables in call to \{fname}\nFunction: \{ft}\nArguments: \{at}\nReturn Hint: \{return-type-hint}\nClosed: \{closed-type}", blame);

   # Specialize the return type
   let return-type = apply-tctx.substitute(ft.range).without-phi-keep-state.expand-implied-phi;
   (tctx, return-type) = tctx.with-phi-id-if-phi-state(return-type, blame);

   # Propagate cons root type for Prop functions
   # like, t0.prop0(t1,t2) : T0 && Prop0
   if ft.is-t(c"Prop",0) then return-type = return-type.extend( at.cons-root );  

   (tctx, apply-tctx, closed-type, return-type)
);
