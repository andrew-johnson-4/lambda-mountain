
let type-ast-inserts = mk-vector(type(AST));
let complex-type-index = {} : Hashtable<(CString,U64),U64>;

let visit-field-template(field-name: CString, base-type: Type, field-type: Type, blame: AST, field-ordinal: U64, case-number: U64): Nil = (
   let mangled-field-name = case-number.into(type(CString)) + c"_" + field-name;
   let ctx = (None : Maybe<TypeContext>)();
   ctx = ctx.bind( c"base-type", base-type, denormalize(base-type), mk-eof() );
   ctx = ctx.bind( c"field-type", field-type, denormalize(field-type), mk-eof() );
   ctx = ctx.bind( c"field-name", ta, ta, mk-lit(mangled-field-name) );
   ctx = ctx.bind( c"primitive::field-get", ta, ta, mk-var(c"."+field-name) );
   ctx = ctx.bind( c"primitive::field-set", ta, ta, mk-var(c"set."+field-name) );
   ctx = ctx.bind( c"primitive::field-get-indirect", ta, ta, mk-var(c"."+field-name) );
   ctx = ctx.bind( c"primitive::field-set-indirect", ta, ta, mk-var(c"set."+field-name) );
   let global-tctx = Some(mk-tctx());
   let field-get = substitute(ctx, global-tctx.find-callable(c"primitive::field-get", base-type, blame).blame-or-zero);
   let field-set = substitute(ctx, global-tctx.find-callable(c"primitive::field-set", t2(c"Cons", base-type, field-type), blame).blame-or-zero);
   let field-get-indirect = substitute(ctx, global-tctx.find-callable(c"primitive::field-get-indirect", t2(c"Array",base-type,ta), blame).blame-or-zero);
   let field-set-indirect = substitute(ctx, global-tctx.find-callable(c"primitive::field-set-indirect", t2(c"Cons", t2(c"Array",base-type,ta), field-type), blame).blame-or-zero);

   ctx = (None : Maybe<TypeContext>)();
   ctx = ctx.bind( c"base-type", base-type, denormalize(base-type), mk-eof() );
   ctx = ctx.bind( c"field-type", field-type, denormalize(field-type), mk-eof() );
   ctx = ctx.bind( c"field-name", ta, ta, mk-lit(mangled-field-name) );
   ctx = ctx.bind( c"primitive::field-get", ta, ta, mk-var(c"." + field-ordinal.into(type(CString))) );
   let field-ordinal-get = substitute(ctx, global-tctx.find-callable(c"primitive::field-get", base-type, blame).blame-or-zero);

   type-ast-inserts = type-ast-inserts.push(field-get);
   type-ast-inserts = type-ast-inserts.push(field-set);
   type-ast-inserts = type-ast-inserts.push(field-get-indirect);
   type-ast-inserts = type-ast-inserts.push(field-set-indirect);
   type-ast-inserts = type-ast-inserts.push(field-ordinal-get);
   ()
);

let phi-parameters-index = {} : Hashtable<(CString,U64),Type>;

let phi-parameters(tag: CString, ps: U64): Type = phi-parameters-index.lookup((tag,ps),ta);

let infer-type-definition(term: AST): Nil = (
   match term { Typedef{} => (); };
   let lhs-type = (term as Tag::Typedef).lhs-type;
   let implies = (term as Tag::Typedef).implies;
   let implements = (term as Tag::Typedef).implements;
   let size = (term as Tag::Typedef).size;
   let alias = (term as Tag::Typedef).alias;
   let opaque-alias = (term as Tag::Typedef).opaque-alias;
   let cases = (term as Tag::Typedef).cases;
   let misc-type = (term as Tag::Typedef).misc-type;
   for vector rhs-type in implies {
      add-quick-prop(lhs-type, lhs-type, rhs-type);
      add-weaken-quick-prop(lhs-type, lhs-type, rhs-type);
   };
   if non-zero(alias) then add-type-alias(lhs-type, alias);
   if non-zero(opaque-alias) then add-opaque-type-alias(lhs-type, opaque-alias);
   for vector rhs-type in implements {
      add-quick-prop(lhs-type, lhs-type, rhs-type);
      add-weaken-quick-prop(lhs-type, lhs-type, rhs-type);
      interface-implementors = cons( (lhs-type, rhs-type, term), interface-implementors );
   };
   if misc-type.is-t(c"Phi",0) {
      let common-tags-length = 0_u64;
      let common-parameters = [] : List<Type>;
      for vector Tuple{ case-tag1=first, case-fields=second } in cases {
         if case-tag1==c"" {
            common-tags-length = case-fields.length;
            for vector Tuple{field-name1=first, field-type=second} in case-fields {
               common-parameters = cons(field-type, common-parameters);
            };
         } else {
            let case-parameters = common-parameters;
            for vector Tuple{field-name2=first, field-type=second} in case-fields {
               case-parameters = cons(field-type, case-parameters);
            };
            let case-name = lhs-type.simple-tag+c"::"+case-tag1;
            phi-type-index = phi-type-index.bind((case-name, common-tags-length + case-fields.length), true);
            phi-parameters-index = phi-parameters-index.bind((case-name, common-tags-length + case-fields.length), ts(case-name,case-parameters));
         }
      }
   } else {
      add-quick-prop(lhs-type, lhs-type, t1(c"Sized",lhs-type));
      add-weaken-quick-prop(lhs-type, t1(c"Sized",ta), t1(c"Sized",lhs-type));

      let case-number = 0_u64;
      for vector Tuple{ case-tag2=first, case-fields=second } in cases {
         complex-type-index = complex-type-index.bind( lhs-type.ground-tag-and-arity, 1_u64 );
         datatype-index = datatype-index.bind( lhs-type.ground-tag-and-arity, true );
         let field-ordinal = 0_u64;
         for vector Tuple{ field-name3=first, field-type=second } in case-fields {
            let guard = lhs-type && (if non-zero(case-tag2) then t0(c"Tag::"+case-tag2) else ta);
            let field-wrapped-type = t1(c"Field::"+field-name3, field-type);
            add-quick-prop(lhs-type, guard, field-wrapped-type);
            add-weaken-quick-prop(lhs-type, guard, field-wrapped-type);
            visit-field-template(field-name3, guard, field-type, term, case-fields.length - field-ordinal, case-number);
            field-ordinal = field-ordinal + 1;
         };
         case-number = case-number + 1;
      };
      let common-fields = [] : List<(CString,Type)>;
      let has-tag-case = false;
      let has-any-case = false;
      for vector Tuple{ case-tag3=first, case-fields=second } in cases {
         if case-tag3==c"" {
            for vector Tuple{ field-name4=first, field-type=second } in case-fields {
               common-fields = cons((field-name4, field-type), common-fields);
            };
         } else has-tag-case = true;
         has-any-case = true;
      };
      if not(has-tag-case) and has-any-case then infer-type-yield-constructor(lhs-type, lhs-type.simple-tag, 0, common-fields, [] : List<(CString,Type)>, term, has-tag-case);
      if has-any-case {
         add-quick-prop(lhs-type, lhs-type, t0(c"LMStruct"));
         add-weaken-quick-prop(lhs-type, lhs-type, t0(c"LMStruct"));
      };
      if not(has-tag-case) and has-any-case then {
         let tag-case-number = t1(c"CaseNumber", t0(c"0"));
         add-quick-prop(lhs-type, lhs-type, tag-case-number);
         add-weaken-quick-prop(lhs-type, lhs-type, tag-case-number);
      };
      let case-index = 0_u64;
      for vector Tuple{ case-tag4=first, case-fields=second } in cases {
         if case-tag4!=c"" {
            let o-case-fields = [] : List<(CString,Type)>;
            for vector Tuple{ field-name5=first, field-type=second } in case-fields {
               o-case-fields = cons((field-name5, field-type), o-case-fields);
            };
            let tag-guard = lhs-type && t0(c"Tag::"+case-tag4);
            let tag-case-number = t1(c"CaseNumber", t0(case-index.into(type(CString))));
            add-quick-prop(tag-guard, tag-guard, tag-case-number);
            add-weaken-quick-prop(tag-guard, tag-guard, tag-case-number);
            infer-type-yield-constructor(lhs-type, case-tag4, case-index, common-fields, o-case-fields, term, has-tag-case);
         };
         case-index = case-index + 1;
      };
   };
);

let type-constructor-tag-ordinal-index = {} : Hashtable<(CString,U64,CString),U64>;

let infer-type-yield-constructor(base-type: Type, case-tag: CString, case-number: U64, common-fields: List<(CString,Type)>, case-fields: List<(CString,Type)>, blame: AST, has-tag-case: Bool): Nil = (
   (let base-tag, let base-arity) = base-type.ground-tag-and-arity;
   type-constructor-tag-ordinal-index = type-constructor-tag-ordinal-index.bind( (base-tag,base-arity,case-tag), case-number );

   # The constructor is hard-coded for now
   # This only works for C-backend...

   let args = mk-eof();
   for list Tuple{field-name6=first, field-type=second} in common-fields.reverse {
      let mangled-field-name1 = c"0_" + field-name6;
      let par = mk-var(mangled-field-name1).ascript(field-type);
      if non-zero(args)
      then args = mk-cons(args, par)
      else args = par
   };
   for list Tuple{field-name7=first, field-type=second} in case-fields.reverse {
      let mangled-field-name2 = case-number.into(type(CString)) + c"_" + field-name7;
      let par = mk-var(mangled-field-name2).ascript(field-type);
      if non-zero(args)
      then args = mk-cons(args, par)
      else args = par
   };
   if not(non-zero(args)) then args = mk-nil();

   let return-id = uuid();
 
   let body = mk-lit(c"({").ascript(t0(c"L") && t0(c"Literal"));
   body = mk-cons(body, mk-app(mk-var(c"mangle-pre"),mk-atype(t1(c"Type",base-type))) );
   body = mk-cons(body, mk-lit(c" ").ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-app(mk-var(c"mangle-post"),mk-atype(t1(c"Type",base-type))) );
   body = mk-cons(body, mk-lit(c";").ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(c"memset(&").ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(c",0,sizeof ").ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(c");").ascript(t0(c"L") && t0(c"Literal")));

   if has-tag-case {
      body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")) );
      body = mk-cons(body, mk-lit(c".discriminator_case_tag=").ascript(t0(c"L") && t0(c"Literal")));
      body = mk-cons(body, mk-lit(case-number.into(type(CString))).ascript(t0(c"L") && t0(c"Literal")) );
      body = mk-cons(body, mk-lit(c";").ascript(t0(c"L") && t0(c"Literal")));
   };

   for list Tuple{field-name8=first, field-type=second} in common-fields.reverse {
      let mangled-field-name3 = c"0_" + field-name8;
      body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")) );
      body = mk-cons(body, mk-lit(c".").ascript(t0(c"L") && t0(c"Literal")));
      body = mk-cons(body, mk-app(mk-var(c"mangle"),mk-lit(mangled-field-name3).ascript(t0(c"L") && t0(c"Literal"))) );
      body = mk-cons(body, mk-lit(c"=").ascript(t0(c"L") && t0(c"Literal")));
      body = mk-cons(body, mk-var(mangled-field-name3) );
      body = mk-cons(body, mk-lit(c";").ascript(t0(c"L") && t0(c"Literal")));
   };

   for list Tuple{field-name9=first, field-type=second} in case-fields.reverse {
      let mangled-field-name4 = case-number.into(type(CString)) + c"_" + field-name9;
      body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")) );
      body = mk-cons(body, mk-lit(c".").ascript(t0(c"L") && t0(c"Literal")));
      body = mk-cons(body, mk-app(mk-var(c"mangle"),mk-lit(mangled-field-name4).ascript(t0(c"L") && t0(c"Literal"))) );
      body = mk-cons(body, mk-lit(c"=").ascript(t0(c"L") && t0(c"Literal")));
      body = mk-cons(body, mk-var(mangled-field-name4) );
      body = mk-cons(body, mk-lit(c";").ascript(t0(c"L") && t0(c"Literal")));
   };

   body = mk-cons(body, mk-lit(return-id).ascript(t0(c"L") && t0(c"Literal")));
   body = mk-cons(body, mk-lit(c";})").ascript(t0(c"L") && t0(c"Literal")));

   let constructor = mk-glb( mk-token(case-tag).with-location(blame.location), mk-abs(args, body.ascript(base-type.expand-implied-phi), t0(c"Blob") ) );

   type-ast-inserts = type-ast-inserts.push(constructor); ()
);

