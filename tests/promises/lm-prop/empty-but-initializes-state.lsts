
import LM23COMMON/unit-tctx-core.lsts;
import LM23COMMON/prop-core.lsts; # required
import LM23COMMON/prop-alias.lsts; # required
import LM23COMMON/prop-normalize.lsts; #required
import LM23COMMON/prop-tctx-normalize.lsts; # required
import LM23COMMON/prop-expand-implied-phi.lsts; # required

let .apply(tctx: TypeContext?, fname: CString, ft: Type, at: Type, blame: AST, return-type-hint: Type): (TypeContext?, TypeContext?, Type, Type) = (
   # Apply function, then normalize the unification context
   let apply-tctx = if non-zero(return-type-hint)
   then unify(ft.range, return-type-hint, blame).normalize.without-phi-keep-state
   else unify(ft.domain, at, blame).normalize.without-phi-keep-state;

   # Fail if arguments are not accepted by function (unify)
   if apply-tctx.is-none then exit-error("Unable to apply (unify) function \{fname}\nFunction: \{ft}\nArguments: \{at}", blame);

   # Phi: fail if any used arguments have already been moved
   if not(tctx.get-or(mk-tctx()).is-blob) and at.is-moved
   then exit-error("Linear value used after move in call to \{fname}\nFunction: \{ft}\nArguments: \{at}", blame);

   # Phi: apply transitions, like (A ~> B)
   for list pr in apply-tctx.get-or(mk-tctx()).pctx {
      tctx = tctx.bind-phi(pr.phi-id-or-zero, pr.phi-tt-or-zero, pr.blame-or-zero);
   };

#   # Phi: move linear values, like (Linear<A> ~> Linear<Phi::Moved>)
   tctx = tctx.phi-move-args(ft.domain, at, blame);

   # OK

#   # Specialize the function type
   let closed-type = apply-tctx.substitute(ft).without-phi-keep-state;

   # Specialize the return type
   let return-type = ta;

   (tctx, apply-tctx, closed-type, return-type)
);

assert( Some(mk-tctx()).apply(c"f", t2(c"Arrow",t0(c"A"),t0(c"B")), t0(c"A"), mk-eof(), ta ).third == t2(c"Arrow",t0(c"A"),t0(c"B")) );

# TODO: find what combination of libraries imported and "apply" calling reproduces this crash
