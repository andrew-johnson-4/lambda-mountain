
import LM23COMMON/unit-tctx-core.lsts;

let quick-prop = {} : Hashtable<(CString,U64),List<(Type,Type)>>;

let add-quick-prop(pre: Type, pat: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = quick-prop.lookup(key, ([] : List<(Type,Type)>));
   val = cons( (pat,post), val );
   quick-prop = quick-prop.bind( key, val );
);

let .enrich(base: Type): Type = (
   base = enrich-quick-prop(base, base);
   base
);

let enrich-quick-prop(base: Type, pre: Type): Type = (
   match pre {
      TGround { tag=tag, parameters=parameters } => (
         for list row in quick-prop.lookup( pre.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
            let lt = row.first;
            let rt = row.second;
            if base <: lt then (
               let post = rt;
               if not(pre <: post) and not(base <: post) {
                  pre = pre && post;
               };
            );
         };
      );
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type));
         for vector c in conjugate {
            match enrich-quick-prop(base, c) {
               TAnd{rconjugate=conjugate} => for vector rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
      );
      _ => ();
   };
   pre
);

add-quick-prop( t0(c"B.1"), t0(c"B.2"), t0(c"B.3") );

assert( (t0(c"B.1") && t0(c"B.2")).enrich == (t0(c"B.1") && t0(c"B.2") && t0(c"B.3")) );
