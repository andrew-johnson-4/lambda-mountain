
import lib/std/minimal.lsts;

type Type zero TAny implies MustRetain, MustRelease
        = TGround { tag:CString }
        | TAnd { conjugate:Vector<Type> };

let .release(t: Type): Nil = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      (t as Tag::TAnd).conjugate.release;
   };
   mark-as-released(t);
);

let .retain(t: Type): Type = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      mark-as-released((t as Tag::TAnd).conjugate.retain);
   };
   t
);

let .into(tt: Type, tgt: Type<String>): String = (
   match tt {
      TGround{tag=tag} => (
         let r = if tag[0] >= 97 and tag[0] <= 122 then intern("\"\{tag}\"") else intern(tag);
         r
      );
      TAnd{conjugate=conjugate} => (
         let result = "";
         let ci = 0_u64;
         for vector c in conjugate {
            result = result + c.into(type(String));
            ci = ci + 1;
            if ci != conjugate.length then result = result + " + ";
         };
         result
      );
   }
);

let t0(tag: CString): Type = TGround(tag);

let $"&&"(lt: Type, rt: Type): Type = (
   match (lt, rt) {
      Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), lconjugate.length+rconjugate.length);
         for vector c in lconjugate { result = result.push(c) };
         for vector c in rconjugate { result = result.push(c) };
         TAnd(result)
      );
      Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), 1+rconjugate.length);
         result = result.push(first);
         for vector c in rconjugate { result = result.push(c) };
         TAnd(result)
      );
      Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
         let result = mk-vector(type(Type), lconjugate.length+1);
         for vector c in lconjugate { result = result.push(c) };
         result = result.push(second);
         TAnd(result)
      );
      Tuple{first=first,second=second} => (
         let result = mk-vector(type(Type), 2);
         result = result.push(first);
         result = result.push(second);
         TAnd(result)
      );
   };
);

let deep-hash(tt: Type): U64 = (
   match tt {
      TAnd{conjugate=conjugate} => (
         let result = 0_u64;
         for vector c in conjugate { result = result + deep-hash(c) };
         result
      );
      TGround{tag=tag} => deep-hash(tag);
   }
);

let .ground-tag-and-arity(tt: Type): (CString,U64) = (
   match tt {
      TGround { tag=tag } => (tag, 0_u64);
   }
);

# This test case exists to cover a double-free error
# The match case with rconjugate binds a value and releases it properly
# However, the value can persist into the second iteration of the loop if not properly zeroed out after release
# To fix this we added a `destroy(variable)` call that just zeroes out MustRelease variables upon release

# TODO: make this into a simpler more direct test case

let enrich-quick-prop(): Nil = (
   let quick-prop = {} : Hashtable<(CString,U64),List<(Type,Type)>>;
   let val = [] : List<(Type,Type)>;
   val = cons( (t0(c"B.2"),t0(c"B.3")), val );
   quick-prop = quick-prop.bind( (c"B.1",0_u64), val );
   let base = t0(c"B.1") && t0(c"B.2");
   let pre = base;
   let result = mk-vector(type(Type), 50);
   for vector c in mk-vector(type(Type)).push(t0(c"B.1")).push(t0(c"B.2")) {
      for list row in quick-prop.lookup( c.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
         c = c && row.second;
      };
      match c {
         TAnd{rconjugate=conjugate} => (); # This was getting released in both the 1st and 2nd iteration of the loop
         rc => ( result = result.push(rc); () );
      };
   };
);

enrich-quick-prop();

