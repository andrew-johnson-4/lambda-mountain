
import lib2/core/bedrock.lsts;

type Type zero TAny implies MustRetain, MustRelease
        = TGround { tag:CString }
        | TAnd { conjugate:Vector<Type> };

let .release(t: Type): Nil = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      (t as Tag::TAnd).conjugate.release;
   };
   mark-as-released(t);
);

let .retain(t: Type): Type = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      mark-as-released((t as Tag::TAnd).conjugate.retain);
   };
   t
);

let t0(tag: CString): Type = TGround(tag);

let $"&&"(lt: Type, rt: Type): Type = (
   match (lt, rt) {
      Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), lconjugate.length+rconjugate.length);
         for vector c in lconjugate { result = result.push(c) };
         for vector c in rconjugate { result = result.push(c) };
         TAnd(result)
      );
      Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), 1+rconjugate.length);
         result = result.push(first);
         for vector c in rconjugate { result = result.push(c) };
         TAnd(result)
      );
      Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
         let result = mk-vector(type(Type), lconjugate.length+1);
         for vector c in lconjugate { result = result.push(c) };
         result = result.push(second);
         TAnd(result)
      );
      Tuple{first=first,second=second} => (
         let result = mk-vector(type(Type), 2);
         result = result.push(first);
         result = result.push(second);
         TAnd(result)
      );
   };
);

let deep-hash(tt: Type): U64 = (
   match tt {
      TAnd{conjugate=conjugate} => (
         let result = 0_u64;
         for vector c in conjugate { result = result + deep-hash(c) };
         result
      );
      TGround{tag=tag} => deep-hash(tag);
   }
);

let .ground-tag-and-arity(tt: Type): (CString,U64) = (
   match tt {
      TGround { tag=tag } => (tag, 0_u64);
   }
);

let enrich-quick-prop(): Nil = (
   let quick-prop = {} : Hashtable<(CString,U64),List<(Type,Type)>>;
   print("Enrich 1.0\n");
   let val = [] : List<(Type,Type)>;
   print("Enrich 2.0\n");
   val = cons( (t0(c"B.2"),t0(c"B.3")), val );
   print("Enrich 3.0\n");
   quick-prop = quick-prop.bind( (c"B.1",0_u64), val );
   print("Enrich 4.0\n");
   let base = t0(c"B.1") && t0(c"B.2");
   print("Enrich 5.0\n");
   let pre = base;
   print("Enrich 6.0\n");
   let result = mk-vector(type(Type));
   print("Enrich 7.0\n");
   for vector c in mk-vector(type(Type)).push(t0(c"B.1")).push(t0(c"B.2")) {
      print("Enrich 8.0\n");
      for list row in quick-prop.lookup( c.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
         print("Enrich 8.1\n");
         c = c && row.second;
         print("Enrich 8.2\n");
      };
      print("Enrich 8.3\n");
      match c {
         TAnd{rconjugate=conjugate} => for vector rc in rconjugate { result = result.push(rc) };
         rc => ( result = result.push(rc); () );
      };
      print("Enrich 8.4\n");
   };
   print("Enrich END\n");
);

enrich-quick-prop();
print("Program END\n");
