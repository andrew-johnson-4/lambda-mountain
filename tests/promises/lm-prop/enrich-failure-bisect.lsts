
import lib2/core/bedrock.lsts;

type Type zero TAny implies MustRetain, MustRelease
        = TGround { tag:CString }
        | TAnd { conjugate:Vector<Type> };

let .release(t: Type): Nil = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      (t as Tag::TAnd).conjugate.release;
   };
   mark-as-released(t);
);

let .retain(t: Type): Type = (
   if t.discriminator-case-tag==(t as Tag::TAnd).discriminator-case-tag {
      mark-as-released((t as Tag::TAnd).conjugate.retain);
   };
   t
);

let t0(tag: CString): Type = TGround(tag);

let $"&&"(lt: Type, rt: Type): Type = (
   match (lt, rt) {
      Tuple{first:TAnd{lconjugate=conjugate},second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), lconjugate.length+rconjugate.length);
         for vector c in lconjugate { result = result.push(c) };
         for vector c in rconjugate { result = result.push(c) };
         result = result.sort;
         TAnd(result)
      );
      Tuple{first=first,second:TAnd{rconjugate=conjugate}} => (
         let result = mk-vector(type(Type), 1+rconjugate.length);
         result = result.push(first);
         for vector c in rconjugate { result = result.push(c) };
         result = result.sort;
         TAnd(result)
      );
      Tuple{first:TAnd{lconjugate=conjugate},second=second} => (
         let result = mk-vector(type(Type), lconjugate.length+1);
         for vector c in lconjugate { result = result.push(c) };
         result = result.push(second);
         result = result.sort;
         TAnd(result)
      );
      Tuple{first=first,second=second} => (
         let result = mk-vector(type(Type), 2);
         result = result.push(first);
         result = result.push(second);
         result = result.sort;
         TAnd(result)
      );
   };
);

let cmp(left: Type, right: Type): Ord = (
   match left {
      TGround { ltag=tag } => (match right {
         TGround { rtag=tag } => (
            cmp(ltag,rtag);
         );
         _ => cmp($".discriminator-case-tag"(left), $".discriminator-case-tag"(right));
      });
      TAnd{ lconjugate=conjugate } => (match right {
         TAnd{ rconjugate=conjugate } => (
            let result = Equal;
            if lconjugate.length < rconjugate.length then result = LessThan()
            else if lconjugate.length > rconjugate.length then result = GreaterThan()
            else {
               let ci = 0_sz;
               while ci < lconjugate.length and result==Equal {
                  result = result && cmp(lconjugate[ci], rconjugate[ci]);
                  ci = ci + 1;
               };
            };
            result;
         );
         _ => cmp($".discriminator-case-tag"(left), $".discriminator-case-tag"(right));
      });
   };
);

let deep-hash(tt: Type): U64 = (
   match tt {
      TAnd{conjugate=conjugate} => (
         let result = 0_u64;
         for vector c in conjugate { result = result + deep-hash(c) };
         result
      );
      TGround{tag=tag} => deep-hash(tag);
   }
);

let .ground-tag-and-arity(tt: Type): (CString,U64) = (
   match tt {
      TGround { tag:c"Array" } => (c"Array", 0_u64);
      TGround { tag:c"Sized" } => (c"", 9999999_u64);
      TGround { tag=tag } => (tag, 0_u64);
      TAnd { conjugate=conjugate } => (
         let result = (c"", 9999999_u64);
         for vector c in conjugate { if result.second==9999999 then result = c.ground-tag-and-arity };
         result
      );
   }
);

let enrich-quick-prop(): Nil = (
   let quick-prop = {} : Hashtable<(CString,U64),List<(Type,Type)>>;
   let val = [] : List<(Type,Type)>;
   val = cons( (t0(c"B.2"),t0(c"B.3")), val );
   quick-prop = quick-prop.bind( (c"B.1",0_u64), val );
   let base = t0(c"B.1") && t0(c"B.2");
   let pre = base;
   let result = mk-vector(type(Type));
   for vector c in mk-vector(type(Type)).push(t0(c"B.1")).push(t0(c"B.2")) {
      for list row in quick-prop.lookup( c.ground-tag-and-arity, ([] : List<(Type,Type)>) ) {
         c = c && row.second;
      };
      match c {
         TAnd{rconjugate=conjugate} => for vector rc in rconjugate { result = result.push(rc) };
         rc => ( result = result.push(rc); () );
      }
   };
);

enrich-quick-prop();
