
let least-upper-bound(left: Type, right: Type): Type? = (
   let rt = match (left, right) {
      Tuple{ first:TAnd{lconjugate=conjugate}, second:TAnd{rconjugate=conjugate} } => (
         let result = mk-vector(type(Type));
         let li = 0_u64;
         let ri = 0_u64;
         let accept = true;
         while accept && (li < lconjugate.length || ri < rconjugate.length) {
            if li < lconjugate.length && ri < rconjugate.length {
               let tt = least-upper-bound(lconjugate[li], rconjugate[ri]);
               if tt.is-some {
                  result = result.push(tt.get-or-panic);
                  li = li + 1;
                  ri = ri + 1;
               } else accept = false
            } else accept = false;
         };
         if accept then Some(TAnd(result)) else None : Type?
      );
      Tuple{ first:TGround{ltag=tag,lparameters=parameters}, second:TGround{rtag=tag,rparameters=parameters} } => (
         if ltag==rtag {
            let ps = least-upper-bound(lparameters, rparameters);
            if ps.is-some then Some(ts(ltag,ps.get-or-panic)) else None : Type?
         } else None : Type?
      );
      _ => None : Type?;
   };
   print("LUB\nleft \{left}\nright \{right}\nresult \{rt}\n");
   rt
);

let least-upper-bound(left: List<Type>, right: List<Type>): List<Type>? = (
   match (left, right) {
      Tuple{ first:[lt..ls], second:[rt..rs] } => (
         let tt = least-upper-bound(lt,rt);
         if tt.is-some {
            let ts = least-upper-bound(ls,rs);
            if ts.is-some then Some(cons(tt.get-or-panic,ts.get-or-panic)) else None : List<Type>?
         } else None : List<Type>?
      );
      Tuple{ first:[], second:[] } => Some([] : List<Type>);
      _ => None : List<Type>?;
   }
);
