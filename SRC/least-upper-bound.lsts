
let least-upper-bound(left: Type, right: Type): Type? = (
   match (left, right) {
      Tuple{ first:TAnd{lconjugate=conjugate}, second:TAnd{rconjugate=conjugate} } => (
         print("TODO conjugate\nleft \{left}\nright \{right}\n");
         None : Type?;
      );
      Tuple{ first:TGround{ltag=tag,lparameters=parameters}, second:TGround{rtag=tag,rparameters=parameters} } => (
         if ltag==rtag {
            let ps = least-upper-bound(lparameters, rparameters);
            if ps.is-some then Some(ts(ltag,ps.get-or-panic)) else None : Type?
         } else None : Type?
      );
      _ => None : Type?;
   }
);

let least-upper-bound(left: List<Type>, right: List<Type>): List<Type>? = (
   match (left, right) {
      Tuple{ first:[lt..ls], second:[rt..rs] } => (
         let tt = least-upper-bound(lt,rt);
         if tt.is-some {
            let ts = least-upper-bound(ls,rs);
            if ts.is-some then Some(cons(tt.get-or-panic,ts.get-or-panic)) else None : List<Type>?
         } else None : List<Type>?
      );
      Tuple{ first:[], second:[] } => Some([] : List<Type>);
      _ => None : List<Type>?;
   }
);
