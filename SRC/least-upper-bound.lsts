
let least-upper-bound(tctx: TypeContext?, left: Type, right: Type, blame: AST): (TypeContext?, Type?) = (
   print("LUB \{left} x \{right}\n");
   let rt = match (left, right) {
      Tuple{ first:TAnd{lconjugate=conjugate}, second:TAnd{rconjugate=conjugate} } => (
         let result = mk-vector(type(Type));
         let li = 0_u64;
         let ri = 0_u64;
         let accept = true;
         let left-phi-state = ta;
         let left-phi-id = c"";
         let right-phi-state = ta;
         let right-phi-id = c"";
         while accept && (li < lconjugate.length || ri < rconjugate.length) {
            if li < lconjugate.length && ( lconjugate[li].is-t(c"Constant",0)
                                        || lconjugate[li].is-t(c"Literal",0)
                                        || lconjugate[li].is-t(c"LocalVariable",0)
                                        || lconjugate[li].is-t(c"GlobalVariable",0)
                                        || lconjugate[li].is-t(c"MustNotMove",0)
            ) {
               li = li + 1;
            } else if ri < rconjugate.length && ( rconjugate[ri].is-t(c"Constant",0) 
                                               || rconjugate[ri].is-t(c"Literal",0)
                                               || rconjugate[ri].is-t(c"LocalVariable",0)
                                               || rconjugate[ri].is-t(c"GlobalVariable",0)
                                               || rconjugate[ri].is-t(c"MustNotMove",0)
            ) {
               ri = ri + 1;
            } else if li < lconjugate.length && lconjugate[li].is-t(c"Phi::Id",1) {
               left-phi-id = lconjugate[li].l1.simple-tag;
               li = li + 1;
            } else if ri < rconjugate.length && rconjugate[ri].is-t(c"Phi::Id",1) {
               right-phi-id = rconjugate[ri].l1.simple-tag;
               ri = ri + 1;
            } else if li < lconjugate.length && lconjugate[li].is-t(c"Phi::State",1) {
               left-phi-state = lconjugate[li].l1;
               li = li + 1;
            } else if ri < rconjugate.length && rconjugate[ri].is-t(c"Phi::State",1) {
               right-phi-state = rconjugate[ri].l1;
               ri = ri + 1;
            } else if li < lconjugate.length && ri < rconjugate.length {
               (tctx, let tt) = least-upper-bound(tctx,lconjugate[li], rconjugate[ri], blame);
               if tt.is-some {
                  result = result.push(tt.get-or-panic);
                  li = li + 1;
                  ri = ri + 1;
               } else accept = false
            } else accept = false;
         };
         if non-zero(left-phi-id) || non-zero(right-phi-id) || non-zero(left-phi-state) || non-zero(right-phi-state) {
            if not(non-zero(left-phi-id)) || not(non-zero(right-phi-id)) || not(non-zero(left-phi-state)) || not(non-zero(right-phi-state)) {
               exit-error("Unable to Merge Phi States: \{left-phi-state} x \{right-phi-state}", blame);
            };
            let new-phi-state = phi-merge(tctx,left-phi-state,right-phi-state,blame);
            tctx = tctx.bind-phi(left-phi-id, phi-linear-moved(new-phi-state), blame);
            tctx = tctx.bind-phi(right-phi-id, phi-linear-moved(new-phi-state), blame);
            let new-phi-id = uuid();
            result = result.push(t2(c"Phi::Id",t1(new-phi-id)));
            tctx = tctx.bind-phi(new-phi-id, new-phi-state, blame);
         };
         if accept then Some(TAnd(result)) else None : Type?
      );
      Tuple{ first:TGround{ltag=tag,lparameters=parameters}, second:TGround{rtag=tag,rparameters=parameters} } => (
         if ltag==rtag {
            (tctx, let ps) = least-upper-bound(tctx, lparameters, rparameters, blame);
            if ps.is-some then Some(ts(ltag,ps.get-or-panic)) else None : Type?
         } else None : Type?
      );
      Tuple{ first:TAny{}, second:TAny{} } => Some(ta);
      _ => None : Type?;
   };
   (tctx, rt)
);

let least-upper-bound(tctx: TypeContext?, left: List<Type>, right: List<Type>, blame: AST): (TypeContext?, List<Type>?) = (
   let tt = match (left, right) {
      Tuple{ first:[lt..ls], second:[rt..rs] } => (
         (tctx, let tt) = least-upper-bound(tctx,lt,rt,blame);
         if tt.is-some {
            (tctx, let ts) = least-upper-bound(tctx,ls,rs,blame);
            if ts.is-some then Some(cons(tt.get-or-panic,ts.get-or-panic)) else None : List<Type>?
         } else None : List<Type>?
      );
      Tuple{ first:[], second:[] } => Some([] : List<Type>);
      _ => None : List<Type>?;
   };
   (tctx, tt)
);
