
let least-upper-bound(left: Type, right: Type): Type? = (
   let rt = match (left, right) {
      Tuple{ first:TAnd{lconjugate=conjugate}, second:TAnd{rconjugate=conjugate} } => (
         let result = mk-vector(type(Type));
         let li = 0_u64;
         let ri = 0_u64;
         let accept = true;
         let left-phi-state = ta;
         let left-phi-id = c"";
         let right-phi-state = ta;
         let right-phi-id = c"";
         while accept && (li < lconjugate.length || ri < rconjugate.length) {
            if li < lconjugate.length && lconjugate[li].is-t(c"Phi::Id",1) {
               left-phi-id = lconjugate[li].l1.simple-tag;
               li = li + 1;
            } else if ri < rconjugate.length && rconjugate[ri].is-t(c"Phi::Id",1) {
               right-phi-id = rconjugate[ri].l1.simple-tag;
               ri = ri + 1;
            } else if li < lconjugate.length && lconjugate[li].is-t(c"Phi::State",1) {
               left-phi-state = lconjugate[li].l1;
               li = li + 1;
            } else if ri < rconjugate.length && rconjugate[ri].is-t(c"Phi::State",1) {
               right-phi-state = rconjugate[ri].l1;
               ri = ri + 1;
            } else if li < lconjugate.length && ri < rconjugate.length {
               let tt = least-upper-bound(lconjugate[li], rconjugate[ri]);
               if tt.is-some {
                  result = result.push(tt.get-or-panic);
                  li = li + 1;
                  ri = ri + 1;
               } else accept = false
            } else accept = false;
         };
         if non-zero(left-phi-id) || non-zero(right-phi-id) || non-zero(left-phi-state) || non-zero(right-phi-state) {
            print("Merge Phi States LUB\nleft id \{left-phi-id}\nright id \{right-phi-id}\nleft state \{left-phi-state}\nright state \{right-phi-state}\n");
         };
         if accept then Some(TAnd(result)) else None : Type?
      );
      Tuple{ first:TGround{ltag=tag,lparameters=parameters}, second:TGround{rtag=tag,rparameters=parameters} } => (
         if ltag==rtag {
            let ps = least-upper-bound(lparameters, rparameters);
            if ps.is-some then Some(ts(ltag,ps.get-or-panic)) else None : Type?
         } else None : Type?
      );
      _ => None : Type?;
   };
   print("LUB\nleft \{left}\nright \{right}\nresult \{rt}\n");
   rt
);

let least-upper-bound(left: List<Type>, right: List<Type>): List<Type>? = (
   match (left, right) {
      Tuple{ first:[lt..ls], second:[rt..rs] } => (
         let tt = least-upper-bound(lt,rt);
         if tt.is-some {
            let ts = least-upper-bound(ls,rs);
            if ts.is-some then Some(cons(tt.get-or-panic,ts.get-or-panic)) else None : List<Type>?
         } else None : List<Type>?
      );
      Tuple{ first:[], second:[] } => Some([] : List<Type>);
      _ => None : List<Type>?;
   }
);
