
let denormalize(tt: Type): Type = (
   tt = tt.rewrite-type-alias;
   tt = tt.enrich;
   tt = tt.sanitize-phi;
   tt
);

let denormalize-arrow(pt: Type): Type = (
   match pt {
      TAnd{ conjugate=conjugate } => (
         let result = mk-vector(type(Type), 0_u64);
         for c in conjugate {
            match denormalize-arrow(c) {
               TAnd{rconjugate=conjugate} => for rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then ta
         else if result.length==1 then result[0]
         else tand(result)
      );
      TGround{tag:c"Arrow", parameters:[rng.. dom..]} => (
         t2( c"Arrow", denormalize-cons(dom), rng )
      );
      TGround{tag:c"Array", parameters:[rng.. dom..]} => (
         t2( c"Array", denormalize-arrow(dom), rng )
      );
      TGround{} => denormalize(pt);
      _ => pt;
   }
);

let denormalize-cons(pt: Type): Type = (
   match pt {
      TAnd{ conjugate=conjugate } => (
         let result = mk-vector(type(Type), 0_u64);
         for c in conjugate {
            match denormalize-cons(c) {
               TAnd{rconjugate=conjugate} => for rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then ta
         else if result.length==1 then result[0]
         else tand(result)
      );
      TGround{tag:c"Cons", parameters:[rng.. dom..]} => (
         t2( c"Cons", denormalize-cons(dom), denormalize-cons(rng) )
      );
      TGround{} => denormalize(pt);
      _ => pt;
   }
);
