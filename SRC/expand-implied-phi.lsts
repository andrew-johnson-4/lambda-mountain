
let implied-phi-index = {} : HashtableEq<(CString,U64),Type>;

let .expand-implied-phi(tt: Type): Type = (
   let original-tt = tt;
   match tt {
      TAnd{conjugate=conjugate} => (
         for c in conjugate {
            let ga = c.ground-tag-and-arity;
            let ip = implied-phi-index.lookup(ga,ta);
            let ps = t2(c"Phi::State",ip);
            if non-zero(ip) && not(can-unify(ps, tt)) {
               tt = tt && ps
            }
         }
      );
      TGround{} => (
         let ga = tt.ground-tag-and-arity;
         let ip = implied-phi-index.lookup(ga,ta);
         let ps = t2(c"Phi::State",ip);
         if non-zero(ip) && not(can-unify(ps, tt)) {
            tt = tt && ps
         }
      );
      _ => ();
   };
   tt
);

let .expand-implied-phi(tctx: TypeContext?): TypeContext? = (
   let tctx-inner = tctx.get-or(mk-tctx());
   let tctx-expanded = [] : List<TypeContextRow>;
   for TypeContextRow{key=key, nt=nt, dt=dt, def=def} in tctx-inner.tctx.reverse {
      tctx-expanded = cons( TypeContextRow(key,nt,dt.expand-implied-phi,def), tctx-expanded )
   };
   tctx-inner.tctx = tctx-expanded;
   Some(tctx-inner)
);
