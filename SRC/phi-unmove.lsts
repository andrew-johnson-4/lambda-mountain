
let phi-unmove(tctx: TypeContext?, ftype: Type, args: Type, blame: AST): TypeContext? = (
   phi-unmove-args(tctx, ftype.domain, args, blame);
);

let phi-unmove-args(tctx: TypeContext?, params: Type, args: Type, blame: AST): TypeContext? = (
   if params.is-t(c"Cons",2) {
      tctx = phi-unmove-args(tctx, params.slot(c"Cons",2).l1, args.slot(c"Cons",2).l1, blame);
      tctx = phi-unmove-args(tctx, params.slot(c"Cons",2).l2, args.slot(c"Cons",2).l2, blame);
   } else {
      if params.is-t(c"MustNotMove",0) {
         print("Maybe unmove \{args}\n");
      };
      if params.is-t(c"MustNotMove",0) && args.slot(c"Phi::State",1).slot(c"MustRelease::ToRelease",1).slot(c"Linear",1).is-t(c"Phi::Moved",0) {
         let phi-id = args.slot(c"Phi::Id",1).l1.simple-tag;
         let phi-state = args.revive-linear;
         tctx = tctx.bind-phi(phi-id, phi-state, blame);
         print("Unmove \{params} <- \{phi-state}\n");
      }
   };
   tctx
);

let .revive-linear(tt: Type): Type = (
   match tt {
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type), 0_u64);
         for c in conjugate {
            c = c.revive-linear;
            if non-zero(c) then result = result.push(c);
         };
         if result.length==0 then ta
         else if result.length==1 then result[0]
         else tand(result)
      );
      TGround { tag:c"Phi::State", parameters:[
         TGround{tag=tag, parameters:[
            TGround{tag:c"Linear",parameters:[TGround{tag:c"Phi::Moved",parameters:[]}..]}
         ..]}
      ..]} => (
         t2(c"Phi::State", t2(tag, t2(c"Linear", t1(uuid()) )))
      );
      _ => tt;
   }
);
