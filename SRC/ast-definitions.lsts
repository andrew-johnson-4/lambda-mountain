
type SourceLocation = { filename: CString, line: U64, column: U64 };
type Token = { skey: String, key: CString, nonce: U64, location: SourceLocation };

type AST zero ASTEOF implements DefaultFormattable
         = Meta { val: AST[] }
         | ASTEOF
         | ASTNil
         | App { is-cons: U64, left: AST[], right: AST[] }
         | Var { key: CString, token: Token }
         | Lit { key: CString, token: Token }
         | Abs { lhs: AST[], rhs: AST[], tt: Type }
         | AType { tt: Type }
         | Seq { seq: Vector<AST> }
         | Glb { key: Token , val: AST[] }
         | Typedef2 { location: SourceLocation, lhs-type: Type, implies: Vector<Type>, implements: Vector<Type>,
                      size: Type, alias: Type, opaque-alias: Type, cases: Vector<(CString,Vector<(CString,Type)>)>,
                      misc-type: Type, implied-phi: Type };

# constructor with a default argument
let $"App"(left: AST[], right: AST[]): AST = App ( false, left, right );

type TypeContextRow = { key: CString, nt: Type, dt: Type, def: AST };
type PhiContextRow = { phi-id: CString, phi-tt: Type, blame: AST };
let .normalized-type(tr: TypeContextRow): Type = if non-zero(tr.nt) then tr.nt else normalize(tr.dt);
let .denormalized-type(tr: TypeContextRow): Type = if non-zero(tr.dt) then tr.dt else denormalize(tr.nt);
type TypeContext = { tctx:List<TypeContextRow>, pctx: List<PhiContextRow>, is-unsafe: U64, is-blob: U64 };
let mk-tctx(): TypeContext = TypeContext( [] : List<TypeContextRow>, [] : List<PhiContextRow>, false, false );
let .lookup(trs: List<TypeContextRow>, key: CString, default: TypeContextRow): TypeContextRow = (
   let continue = true;
   for tr in trs { if continue {
      if tr.key == key {
         default = tr;
         continue = false;
      }
   }};
   default
);
let .lookup(trs: List<PhiContextRow>, key: CString, default: Type): Type = (
   let continue = true;
   for tr in trs { if continue {
      if tr.phi-id == key {
         default = tr.phi-tt;
         continue = false;
      }
   }};
   default
);
let .into(tr: TypeContextRow, tt: Type<String>): String = "TypeContextRow{ key: \"\{tr.key}\", dt: \"\{tr.dt}\" }";

type alias AContext = List<(CString,AST)>;

type StackToSpecialize = { key:CString, pre-type:Type, ctx:Maybe<TypeContext>, post-type:Type };

type ParsePartial = PME{ term:AST , remainder:List<Token> };

type ApplyResult = { function-type:Type , return-type:Type };

type CompileMode = ModeTokenize | ModeParse | ModePreprocess | ModeTypecheck | ModeCompile;

type IsUsed = Used | Unused | Tail | Call { function-name: CString };
let .is-call(used: IsUsed): U64 = (
   match used {
      Call{} => true;
      _ => false;
   }
);
let .is-used(used: IsUsed): U64 = (
   match used {
      Used{} => true;
      _ => false;
   }
);
let .is-unused(used: IsUsed): U64 = (
   match used {
      Unused{} => true;
      _ => false;
   }
);
let .is-tail(used: IsUsed): U64 = (
   match used {
      Tail{} => true;
      _ => false;
   }
);

type FContext zero FCtxEOF = FCtxEOF | FCtxBind{ remainder:FContext[] , k:CString , kt:Type , kv:Fragment };

type Macro = { lhs:AST, rhs:AST };
type MacroList zero MEOF = MEOF | MSeq{ k:MacroList[], v:Macro };
