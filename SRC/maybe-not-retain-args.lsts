
let maybe-not-retain-args(tctx: TypeContext?, function-type: Type, term: AST): (TypeContext?, AST) = (
   print("maybe not retain \{term} : \{typeof-term(term)}\n");
   match term {
      App{left=left, right=right} => (
         (tctx, let new-right) = maybe-not-retain-args-each(tctx, function-type.domain, right);
         if not(is(right,new-right)) {
            let new-term = mk-app(left, new-right);
            ascript(new-term, typeof-term(term));
            term = new-term;
         };
         (tctx, term)
      );
   }
);

let maybe-not-retain-args-each(tctx: TypeContext?, args-type: Type, args: AST): (TypeContext?, AST) = (
   if args-type.is-t(c"Cons",2) then match args {
      App{left=left,right=right} => (
         (tctx, let new-left) = maybe-not-retain-args-each(tctx, args-type.slot(c"Cons",2).l1, left);
         (tctx, let new-right) = maybe-not-retain-args-one(tctx, args-type.slot(c"Cons",1).l2, right);
         if not(is(left,new-left)) || not(is(right,new-right)) {
            let new-args = mk-cons(new-left,new-right);
            ascript(new-args, t3(c"Cons",typeof-term(new-left),typeof-term(new-right)));
            args = new-args;
         };
         (tctx, args)
      );
   } else maybe-not-retain-args-one(tctx, args-type, args)
);

let maybe-not-retain-args-one(tctx: TypeContext?, args-type: Type, args: AST): (TypeContext?, AST) = (
   if args-type.is-t(c"MustNotRetain",0) then match args {
      App{left:Var{key:c".retain"},right=right} => args = right;
      _ => (
         if typeof-term(args).is-t(c"MustRetain",0) then exit-error("TODO: MustNotRetain arg cannot be structurally unretained",args);
      );
   };
   (tctx, args)
);
