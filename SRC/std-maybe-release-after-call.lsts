
let std-maybe-release-after-call(tctx: TypeContext?, function-type: Type, args: AST): (TypeContext?, AST, AST, AST, AST) = (
   if function-type.domain.is-any-arg-t(c"MustReleaseAfterCall",0)
   && is-paired-release(function-type.domain, typeof-term(args))
   then (
      let tmpresult = mk-var(uuid());
      (tctx, let prefix, let postfix, args) = std-release-after-call(tctx, function-type.domain, mk-eof(), mk-eof(), args);
      print("Release After Call \{function-type}\nPrefix \{prefix}\nPostfix \{postfix}\nArgs \{args}\nResult \{tmpresult}\n");
      (tctx, prefix, postfix, tmpresult, args)
   );
   else (tctx, mk-eof(), mk-eof(), mk-eof(), args)
);

let is-paired-release(pt: Type, at: Type): U64 = (
   if pt.is-t(c"Cons",2) or at.is-t(c"Cons",2)
   then (is-paired-release(pt.slot(c"Cons",2).l1, at.slot(c"Cons",2).l1)
      or is-paired-release(pt.slot(c"Cons",2).l2, at.slot(c"Cons",2).l2))
   else (pt.is-t(c"MustReleaseAfterCall",0) and at.is-t(c"MustRelease",0))
);

let std-release-after-call(tctx: TypeContext?, param-types: Type, prefix: AST, postfix: AST, args: AST): (TypeContext?, AST, AST, AST) = (
   if param-types.is-t(c"Cons",2) { match args {
      App{ left=left, right=right } => (
         (tctx, prefix, postfix, left) = std-release-after-call(tctx, param-types.slot(c"Cons",2).l1, prefix, postfix, left);
         (tctx, prefix, postfix, right) = std-release-after-call(tctx, param-types.slot(c"Cons",2).l2, prefix, postfix, right);
         let new-args = mk-cons(left, right);
         tctx = tctx.ascript(new-args, typeof-term(args));
         (tctx, prefix, postfix, new-args)
      );
   }} else {
      (tctx, let args-type) = tctx.phi-fresh(typeof-term(args), args);
      print("Fresh \{args-type}\n");

      let tmp-id = uuid();
      let tmp-var1 = mk-var(tmp-id); tctx = tctx.ascript(tmp-var1, args-type);
      let tmp-var2 = mk-var(tmp-id); tctx = tctx.ascript(tmp-var2, args-type);
      let tmp-direct = mk-var(tmp-id); tctx = tctx.ascript(tmp-direct, typeof-term(args));
      let tmp-nil = mk-nil(); tctx = tctx.ascript(tmp-nil, t0(c"Nil"));
      let declare = mk-abs(tmp-var1, tmp-nil, ta); tctx = tctx.ascript(declare, t0(c"Nil"));
      let bind = mk-app(declare, args); tctx = tctx.ascript(bind, t0(c"Nil"));

      if non-zero(prefix)
      then (prefix = mk-cons( prefix, bind ); tctx = tctx.ascript(prefix, t0(c"Nil"));)
      else prefix = bind;

      if param-types.is-t(c"MustReleaseAfterCall",0) and typeof-term(args).is-t(c"MustRelease",0)
      then {
         let release-type = tctx.find-callable(c".release", args-type, args ).dt;
         let release-var = mk-var(c".release"); tctx = tctx.ascript(release-var, release-type);
         (tctx, let release-return) = tctx.apply-callable(c".release", args-type, args);
         let do-release = mk-app(release-var, tmp-var2); tctx = tctx.ascript(do-release, release-return);
 
         if non-zero(postfix)
         then (postfix = mk-cons( postfix, do-release ); tctx = tctx.ascript(postfix, t0(c"Nil"));)
         else postfix = do-release;
      };

      (tctx, prefix, postfix, tmp-direct)
   }
);
