
let .without-nested-phi(tt: Type): Type = (
   match tt {
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type), 0_u64);
         for c in conjugate {
            match c.without-nested-phi {
               TAnd{rconjugate=conjugate} => for rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then ta
         else if result.length==1 then result[0]
         else tand(result)
      );
      TGround { tag:c"Cons", parameters:[c2..c1..] } => t2(c"Cons",c1.without-nested-phi,c2.without-nested-phi);
      TGround { tag=tag, parameters=parameters } => ts(tag,parameters.without-nested-phi);
      _ => tt;
   }
);

let .without-nested-phi(tt: List<Type>): List<Type> = (
   match tt {
      [thd..ttl] => cons(thd.without-nested-phi-param, ttl.without-nested-phi);
      _ => tt;
   }
);

let .without-nested-phi-param(tt: Type): Type = (
   match tt {
      TAnd { conjugate=conjugate } => (
         let result = mk-vector(type(Type), 0_u64);
         for c in conjugate {
            match c.without-nested-phi-param {
               TAnd{rconjugate=conjugate} => for rc in rconjugate { result = result.push(rc) };
               TAny{} => ();
               rc => ( result = result.push(rc); () );
            }
         };
         if result.length==0 then ta
         else if result.length==1 then result[0]
         else tand(result)
      );
      TGround { tag:c"Phi::State", parameters:[_..] } => ta;
      TGround { tag:c"Phi::Id", parameters:[_..] } => ta;
      TGround { tag=tag, parameters=parameters } => ts(tag,parameters.without-nested-phi);
      _ => tt;
   }
);
